<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://unpkg.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https: blob:;">
    <title>Sprite Sheet Extractor & Animator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6b1b7a 0%, #8b2d9e 50%, #c2185b 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        h1 {
            color: #ff6ec7;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            align-items: center;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            color: #e1bee7;
            font-size: 14px;
            margin-bottom: 5px;
        }

        input[type="file"] {
            background: rgba(139, 45, 158, 0.5);
            border: 1px solid rgba(255, 110, 199, 0.3);
            border-radius: 6px;
            padding: 10px;
            color: #e1bee7;
            cursor: pointer;
            width: 100%;
        }

        input[type="range"] {
            width: 100%;
        }

        button {
            background: #ff6ec7;
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

            button:hover:not(:disabled) {
                background: #ff4db8;
                transform: translateY(-2px);
            }

            button:disabled {
                background: #666;
                cursor: not-allowed;
                transform: none;
            }

        .status {
            text-align: center;
            padding: 20px;
            font-size: 1.1em;
            color: #ff6ec7;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 20px 0;
        }

        .preview-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            display: none;
            position: relative;
        }

            .preview-section.visible {
                display: block;
            }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

            .preview-header h3 {
                color: #ff6ec7;
            }

        .picker-mode {
            background: rgba(255, 110, 199, 0.2);
            padding: 8px 16px;
            border-radius: 6px;
            border: 2px solid #ff6ec7;
        }

        #previewCanvas {
            max-width: 100%;
            max-height: 500px;
            border: 2px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            display: block;
            margin: 0 auto 15px auto;
        }

            #previewCanvas.picking {
                cursor: crosshair;
                border-color: #ff6ec7;
                box-shadow: 0 0 20px rgba(255, 110, 199, 0.5);
            }

        #zoomPreview {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff6ec7;
            border-radius: 8px;
            display: none;
            z-index: 10;
        }

            #zoomPreview.visible {
                display: block;
            }

        #zoomCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .colors-display {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .color-swatch {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid rgba(255, 110, 199, 0.3);
        }

        .color-box {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .color-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .color-label {
            font-size: 12px;
            color: #ce93d8;
        }

        .color-value {
            font-size: 14px;
            color: #fff;
            font-weight: bold;
        }

        .sprites-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .sprite-card {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 110, 199, 0.2);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.3s;
        }

            .sprite-card:hover {
                border-color: rgba(255, 110, 199, 0.5);
                transform: translateY(-4px);
            }

        .sprite-preview {
            background: rgba(128, 128, 128, 0.3);
            border-radius: 4px;
            padding: 8px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            position: relative;
        }

            .sprite-preview img {
                max-width: 100%;
                max-height: 100px;
                image-rendering: pixelated;
            }

        .sprite-info {
            font-size: 11px;
            color: #ce93d8;
            margin-bottom: 8px;
            text-align: center;
        }

        .sprite-card button {
            width: 100%;
            padding: 6px;
            font-size: 12px;
        }

        .badge {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #000;
            color: #fff;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }

        .tab {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 110, 199, 0.3);
            color: #e1bee7;
            padding: 12px 30px;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

            .tab:hover {
                border-color: rgba(255, 110, 199, 0.5);
            }

            .tab.active {
                background: rgba(255, 110, 199, 0.3);
                border-color: #ff6ec7;
                color: #fff;
            }

        .tab-content {
            display: none;
        }

            .tab-content.active {
                display: block;
            }

        .animation-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .animation-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .animation-preview {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

            .animation-preview canvas {
                image-rendering: pixelated;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

        .frame-timeline {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            padding: 15px;
            min-height: 120px;
            margin-bottom: 20px;
        }

            .frame-timeline h4 {
                color: #ff6ec7;
                margin-bottom: 10px;
            }

        .frames-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
        }

        .frame-item {
            background: rgba(128, 128, 128, 0.3);
            border: 2px solid rgba(255, 110, 199, 0.3);
            border-radius: 6px;
            padding: 8px;
            min-width: 80px;
            cursor: move;
            position: relative;
            transition: all 0.2s;
        }

            .frame-item:hover {
                border-color: #ff6ec7;
                transform: scale(1.05);
            }

            .frame-item img {
                width: 64px;
                height: 64px;
                object-fit: contain;
                image-rendering: pixelated;
            }

            .frame-item .remove-frame {
                position: absolute;
                top: 2px;
                right: 2px;
                background: #ff4444;
                color: white;
                border: none;
                border-radius: 3px;
                width: 20px;
                height: 20px;
                cursor: pointer;
                font-size: 12px;
                line-height: 1;
                padding: 0;
            }

        .sprite-picker {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

            .sprite-picker h4 {
                color: #ff6ec7;
                margin-bottom: 10px;
            }

        .available-sprites {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
        }

        .pickable-sprite {
            background: rgba(128, 128, 128, 0.3);
            border: 2px solid rgba(255, 110, 199, 0.2);
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

            .pickable-sprite:hover {
                border-color: #ff6ec7;
                transform: scale(1.05);
            }

            .pickable-sprite img {
                width: 100%;
                height: 64px;
                object-fit: contain;
                image-rendering: pixelated;
            }

            .pickable-sprite .sprite-num {
                text-align: center;
                font-size: 10px;
                color: #ce93d8;
                margin-top: 4px;
            }

        input[type="text"] {
            background: rgba(139, 45, 158, 0.5);
            border: 1px solid rgba(255, 110, 199, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-size: 14px;
        }

        input[type="number"] {
            background: rgba(139, 45, 158, 0.5);
            border: 1px solid rgba(255, 110, 199, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            width: 80px;
        }

        .empty-state {
            text-align: center;
            color: #ce93d8;
            padding: 30px;
        }

        .dynamic-color-box {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎨 Sprite Sheet Extractor & Animator</h1>
            <p>Extract sprites and create animated GIFs!</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('extractor')">🖼️ Sprite Extractor</div>
            <div class="tab" onclick="switchTab('animator')" id="animatorTab">🎬 GIF Animator</div>
        </div>

        <div id="extractorContent" class="tab-content active">
            <div class="header">
                <div class="controls">
                    <div class="control-group">
                        <label for="fileInput">Upload Sprite Sheet:</label>
                        <input type="file" id="fileInput" accept="image/*">
                    </div>
                    <div class="control-group">
                        <label for="tolerance">Tolerance: <span id="toleranceValue">10</span></label>
                        <input type="range" id="tolerance" min="0" max="50" value="10">
                    </div>
                    <button id="extractBtn" disabled>▶️ Extract Sprites</button>
                    <button id="downloadAll" disabled>⬇️ Download All</button>
                </div>
            </div>

            <div id="status" class="status">👋 Upload a sprite sheet to get started!</div>

            <div id="previewSection" class="preview-section">
                <div class="preview-header">
                    <h3>Pick Background Colors (Click 2 colors on the image)</h3>
                    <div id="pickerStatus" class="picker-mode"></div>
                </div>
                <canvas id="previewCanvas"></canvas>
                <div id="zoomPreview">
                    <canvas id="zoomCanvas"></canvas>
                </div>
                <div class="colors-display" id="colorsDisplay"></div>
            </div>

            <div id="spritesGrid" class="sprites-grid"></div>
        </div>

        <div id="animatorContent" class="tab-content">
            <div class="animation-section">
                <h3 style="color: #ff6ec7; margin-bottom: 15px;">Animation Preview</h3>
                <div class="animation-preview">
                    <canvas id="animationCanvas"></canvas>
                </div>

                <div class="animation-controls">
                    <div class="control-group">
                        <label for="animFps">FPS:</label>
                        <input type="number" id="animFps" value="10" min="1" max="60">
                    </div>
                    <div class="control-group">
                        <label for="animName">Animation Name:</label>
                        <input type="text" id="animName" value="animation" placeholder="animation">
                    </div>
                    <button id="playBtn">▶️ Play</button>
                    <button id="stopBtn">⏹️ Stop</button>
                    <button id="exportGifBtn" disabled>💾 Export as GIF</button>
                    <button id="clearFramesBtn">🗑️ Clear All</button>
                </div>
            </div>

            <div class="frame-timeline">
                <h4>Frame Timeline (Click sprites below to add frames)</h4>
                <div class="frames-container" id="framesContainer">
                    <div class="empty-state">No frames yet. Click sprites below to add them!</div>
                </div>
            </div>

            <div class="sprite-picker">
                <h4>Available Sprites</h4>
                <div class="available-sprites" id="availableSprites">
                    <div class="empty-state">Extract sprites first in the Sprite Extractor tab!</div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="workCanvas" style="display: none;"></canvas>

    <script type="module">
        import { GIFEncoder, quantize, applyPalette } from 'https://unpkg.com/gifenc@1.0.3?module';
        window.GIFEncoder = GIFEncoder;
        window.quantize = quantize;
        window.applyPalette = applyPalette;
    </script>

    <script>
        // ===== EXTRACTOR VARIABLES =====
        const fileInput = document.getElementById('fileInput');
        const toleranceInput = document.getElementById('tolerance');
        const toleranceValue = document.getElementById('toleranceValue');
        const extractBtn = document.getElementById('extractBtn');
        const downloadAllBtn = document.getElementById('downloadAll');
        const statusDiv = document.getElementById('status');
        const previewSection = document.getElementById('previewSection');
        const previewCanvas = document.getElementById('previewCanvas');
        const pickerStatus = document.getElementById('pickerStatus');
        const colorsDisplay = document.getElementById('colorsDisplay');
        const spritesGrid = document.getElementById('spritesGrid');
        const workCanvas = document.getElementById('workCanvas');
        const zoomPreview = document.getElementById('zoomPreview');
        const zoomCanvas = document.getElementById('zoomCanvas');

        const previewCtx = previewCanvas.getContext('2d');
        const workCtx = workCanvas.getContext('2d');
        const zoomCtx = zoomCanvas.getContext('2d');

        let pickedColors = [];
        let currentImage = null;
        let extractedSprites = [];
        let zoomScale = 10; // 10x zoom
        let isPicking = false;

        // ===== ANIMATOR VARIABLES =====
        const animationCanvas = document.getElementById('animationCanvas');
        const animCtx = animationCanvas.getContext('2d');
        const animFpsInput = document.getElementById('animFps');
        const animNameInput = document.getElementById('animName');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const exportGifBtn = document.getElementById('exportGifBtn');
        const clearFramesBtn = document.getElementById('clearFramesBtn');
        const framesContainer = document.getElementById('framesContainer');
        const availableSprites = document.getElementById('availableSprites');

        let animationFrames = [];
        let animationInterval = null;
        let currentFrameIndex = 0;

        // ===== ANIMATOR FUNCTIONS (defined early) =====
        function updateAvailableSprites() {
            if (extractedSprites.length === 0) {
                availableSprites.innerHTML = '<div class="empty-state">Extract sprites first in the Sprite Extractor tab!</div>';
                return;
            }

            availableSprites.innerHTML = extractedSprites.map(sprite => `
                        <div class="pickable-sprite" onclick="addFrame(${sprite.id})">
                            <img src="${sprite.dataUrl}" alt="Sprite ${sprite.id}">
                            <div class="sprite-num">#${sprite.id}</div>
                        </div>
                    `).join('');
        }

        // ===== TAB SWITCHING =====
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            if (tabName === 'extractor') {
                document.querySelector('.tab:first-child').classList.add('active');
                document.getElementById('extractorContent').classList.add('active');
            } else {
                document.getElementById('animatorTab').classList.add('active');
                document.getElementById('animatorContent').classList.add('active');
                updateAvailableSprites();
            }
        }
        window.switchTab = switchTab;

        // ===== EXTRACTOR CODE =====

        toleranceInput.addEventListener('input', (e) => {
            toleranceValue.textContent = e.target.value;
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            loadImage(file);
        });

        // Mouse events for zoom preview
        previewCanvas.addEventListener('mousemove', (e) => {
            if (!isPicking) return;
            updateZoom(e);
        });

        previewCanvas.addEventListener('click', (e) => {
            if (pickedColors.length >= 2) return;
            pickColorFromCanvas(e);
        });

        // Hide zoom on mouse leave
        previewCanvas.addEventListener('mouseleave', () => {
            zoomPreview.classList.remove('visible');
        });

        extractBtn.addEventListener('click', () => {
            extractSprites();
        });

        downloadAllBtn.addEventListener('click', () => {
            extractedSprites.forEach((sprite, idx) => {
                setTimeout(() => downloadSprite(sprite, idx), idx * 100);
            });
        });

        function loadImage(file) {
            statusDiv.innerHTML = '<div class="status">📸 Loading image...</div>';
            const img = new Image();
            img.onload = () => {
                currentImage = img;
                workCanvas.width = img.width;
                workCanvas.height = img.height;
                workCtx.drawImage(img, 0, 0);

                previewCanvas.width = img.width;
                previewCanvas.height = img.height;
                previewCtx.drawImage(img, 0, 0);

                previewSection.classList.add('visible');
                previewCanvas.classList.add('picking');
                isPicking = true;
                pickedColors = [];
                updateColorsDisplay();
                updatePickerStatus();
                statusDiv.innerHTML = '<div class="status">✅ Image loaded! Click on 2 background colors in the preview.</div>';
            };
            img.src = URL.createObjectURL(file);
        }

        function updateZoom(e) {
            const rect = previewCanvas.getBoundingClientRect();
            const scaleX = workCanvas.width / rect.width;
            const scaleY = workCanvas.height / rect.height;
            let x = Math.floor((e.clientX - rect.left) * scaleX);
            let y = Math.floor((e.clientY - rect.top) * scaleY);

            // Clamp to bounds
            x = Math.max(0, Math.min(x, workCanvas.width - 1));
            y = Math.max(0, Math.min(y, workCanvas.height - 1));

            const zoomSize = zoomCanvas.width / zoomScale;
            const startX = Math.max(0, x - zoomSize / 2);
            const startY = Math.max(0, y - zoomSize / 2);

            zoomCtx.drawImage(
                workCanvas,
                startX, startY, zoomSize, zoomSize,
                0, 0, zoomCanvas.width, zoomCanvas.height
            );

            // Draw crosshair
            zoomCtx.strokeStyle = '#ff6ec7';
            zoomCtx.lineWidth = 1;
            zoomCtx.beginPath();
            zoomCtx.moveTo(zoomCanvas.width / 2, 0);
            zoomCtx.lineTo(zoomCanvas.width / 2, zoomCanvas.height);
            zoomCtx.moveTo(0, zoomCanvas.height / 2);
            zoomCtx.lineTo(zoomCanvas.width, zoomCanvas.height / 2);
            zoomCtx.stroke();

            zoomPreview.classList.add('visible');
        }

        function pickColorFromCanvas(e) {
            const rect = previewCanvas.getBoundingClientRect();
            const scaleX = workCanvas.width / rect.width;
            const scaleY = workCanvas.height / rect.height;
            let x = Math.floor((e.clientX - rect.left) * scaleX);
            let y = Math.floor((e.clientY - rect.top) * scaleY);

            const imageData = workCtx.getImageData(x, y, 1, 1);
            const [r, g, b] = imageData.data;

            pickedColors.push({ r, g, b });
            updateColorsDisplay();
            updatePickerStatus();

            if (pickedColors.length === 2) {
                previewCanvas.classList.remove('picking');
                isPicking = false;
                zoomPreview.classList.remove('visible');
                extractBtn.disabled = false;
                statusDiv.innerHTML = '<div class="status">✅ Colors picked! Click "Extract Sprites" to continue.</div>';
            }
        }

        function updatePickerStatus() {
            if (pickedColors.length < 2) {
                pickerStatus.textContent = `Color ${pickedColors.length + 1} of 2 - Click on image`;
                pickerStatus.style.display = 'block';
            } else {
                pickerStatus.style.display = 'none';
            }
        }

        function updateColorsDisplay() {
            colorsDisplay.innerHTML = pickedColors.map((color, i) => {
                const rgb = `rgb(${color.r}, ${color.g}, ${color.b})`;
                return `
                        <div class="color-swatch">
                            <div class="color-box dynamic-color-box" data-color="${rgb}"></div>
                            <div class="color-info">
                                <div class="color-label">Color ${i + 1}</div>
                                <div class="color-value">RGB(${color.r}, ${color.g}, ${color.b})</div>
                            </div>
                        </div>
                    `;
            }).join('');

            // Apply styles after DOM update to avoid CSP issues
            document.querySelectorAll('.dynamic-color-box').forEach(el => {
                el.style.backgroundColor = el.dataset.color;
            });
        }

        function isBackground(r, g, b, tolerance) {
            for (let color of pickedColors) {
                if (Math.abs(r - color.r) <= tolerance &&
                    Math.abs(g - color.g) <= tolerance &&
                    Math.abs(b - color.b) <= tolerance) {
                    return true;
                }
            }
            return false;
        }

        function extractSprites() {
            statusDiv.innerHTML = '<div class="status">🔄 Extracting sprites...</div>';
            spritesGrid.innerHTML = '';
            extractedSprites = [];

            const imageData = workCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
            const data = imageData.data;
            const width = workCanvas.width;
            const height = workCanvas.height;
            const tolerance = parseInt(toleranceInput.value);
            const visited = new Uint8Array(width * height);

            const islands = [];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (visited[idx]) continue;

                    const pixelIdx = idx * 4;
                    const r = data[pixelIdx];
                    const g = data[pixelIdx + 1];
                    const b = data[pixelIdx + 2];

                    if (isBackground(r, g, b, tolerance)) continue;

                    const island = floodFill(x, y, data, width, height, visited, tolerance);
                    if (island && island.pixels > 20) {
                        islands.push(island);
                    }
                }
            }

            islands.forEach((island, idx) => {
                const sprite = createSprite(island, data, width, tolerance, idx);
                extractedSprites.push(sprite);
            });

            displaySprites();
            statusDiv.innerHTML = `<div class="status">✅ Found ${islands.length} sprites!</div>`;
            downloadAllBtn.disabled = false;
        }

        function floodFill(startX, startY, data, width, height, visited, tolerance) {
            const stack = [[startX, startY]];
            let minX = startX, maxX = startX, minY = startY, maxY = startY;
            let pixels = 0;

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;

                const idx = y * width + x;
                if (visited[idx]) continue;

                const pixelIdx = idx * 4;
                const r = data[pixelIdx];
                const g = data[pixelIdx + 1];
                const b = data[pixelIdx + 2];

                if (isBackground(r, g, b, tolerance)) continue;

                visited[idx] = 1;
                pixels++;

                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            return { minX, maxX, minY, maxY, pixels };
        }

        function createSprite(island, data, width, tolerance, id) {
            const spriteWidth = island.maxX - island.minX + 1;
            const spriteHeight = island.maxY - island.minY + 1;

            const spriteCanvas = document.createElement('canvas');
            spriteCanvas.width = spriteWidth;
            spriteCanvas.height = spriteHeight;
            const spriteCtx = spriteCanvas.getContext('2d');

            spriteCtx.drawImage(
                workCanvas,
                island.minX, island.minY, spriteWidth, spriteHeight,
                0, 0, spriteWidth, spriteHeight
            );

            // Always remove background colors
            const spriteData = spriteCtx.getImageData(0, 0, spriteWidth, spriteHeight);
            const pixels = spriteData.data;

            for (let i = 0; i < pixels.length; i += 4) {
                if (isBackground(pixels[i], pixels[i + 1], pixels[i + 2], tolerance)) {
                    pixels[i + 3] = 0;
                }
            }

            spriteCtx.putImageData(spriteData, 0, 0);

            return {
                id,
                dataUrl: spriteCanvas.toDataURL('image/png'),
                width: spriteWidth,
                height: spriteHeight
            };
        }

        function displaySprites() {
            spritesGrid.innerHTML = extractedSprites.map(sprite => `
                        <div class="sprite-card">
                            <div class="sprite-preview">
                                <img src="${sprite.dataUrl}" alt="Sprite ${sprite.id}">
                            </div>
                            <div class="sprite-info">#${sprite.id} • ${sprite.width}×${sprite.height}</div>
                            <button onclick="downloadSpriteById(${sprite.id})">⬇️ Download</button>
                        </div>
                    `).join('');

            // Update animator sprites
            updateAvailableSprites();
        }

        function downloadSprite(sprite, index) {
            const link = document.createElement('a');
            link.download = `sprite_${String(index).padStart(3, '0')}.png`;
            link.href = sprite.dataUrl;
            link.click();
        }

        window.downloadSpriteById = function (id) {
            const sprite = extractedSprites.find(s => s.id === id);
            if (sprite) downloadSprite(sprite, id);
        };

        // ===== ANIMATOR CODE =====
        function addFrame(spriteId) {
            const sprite = extractedSprites.find(s => s.id === spriteId);
            if (!sprite) return;

            animationFrames.push({ ...sprite });
            updateFrameTimeline();
            exportGifBtn.disabled = animationFrames.length === 0;
        }
        window.addFrame = addFrame;

        function removeFrame(index) {
            animationFrames.splice(index, 1);
            updateFrameTimeline();
            exportGifBtn.disabled = animationFrames.length === 0;
        }
        window.removeFrame = removeFrame;

        function updateFrameTimeline() {
            if (animationFrames.length === 0) {
                framesContainer.innerHTML = '<div class="empty-state">No frames yet. Click sprites below to add them!</div>';
                return;
            }

            framesContainer.innerHTML = animationFrames.map((frame, idx) => `
                        <div class="frame-item">
                            <button class="remove-frame" onclick="removeFrame(${idx})">×</button>
                            <img src="${frame.dataUrl}" alt="Frame ${idx}">
                        </div>
                    `).join('');
        }

        function playAnimation() {
            if (animationFrames.length === 0) return;

            stopAnimation();

            const fps = parseInt(animFpsInput.value) || 10;
            const delay = 1000 / fps;

            // Set canvas size to largest frame
            const maxWidth = Math.max(...animationFrames.map(f => f.width));
            const maxHeight = Math.max(...animationFrames.map(f => f.height));
            animationCanvas.width = maxWidth;
            animationCanvas.height = maxHeight;

            currentFrameIndex = 0;

            const drawFrame = () => {
                const frame = animationFrames[currentFrameIndex];
                const img = new Image();
                img.onload = () => {
                    animCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                    const x = (animationCanvas.width - frame.width) / 2;
                    const y = (animationCanvas.height - frame.height) / 2;
                    animCtx.drawImage(img, x, y);
                };
                img.src = frame.dataUrl;

                currentFrameIndex = (currentFrameIndex + 1) % animationFrames.length;
            };

            drawFrame();
            animationInterval = setInterval(drawFrame, delay);
        }

        function stopAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        async function exportGif() {
            if (animationFrames.length === 0) return;

            if (typeof GIFEncoder === 'undefined') {
                alert('GIF library not loaded. Please refresh the page.');
                return;
            }

            exportGifBtn.disabled = true;
            exportGifBtn.textContent = '⏳ Generating GIF...';

            const fps = parseInt(animFpsInput.value) || 10;
            const delay = Math.round(100 / fps); // centiseconds for GIF

            const maxWidth = Math.max(...animationFrames.map(f => f.width));
            const maxHeight = Math.max(...animationFrames.map(f => f.height));

            const gif = GIFEncoder();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = maxWidth;
            tempCanvas.height = maxHeight;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

            const format = 'rgba4444'; // Supports alpha

            let loadedFrames = 0;

            const processFrame = (frame) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        tempCtx.clearRect(0, 0, maxWidth, maxHeight);
                        const x = (maxWidth - frame.width) / 2;
                        const y = (maxHeight - frame.height) / 2;
                        tempCtx.drawImage(img, x, y);

                        const data = tempCtx.getImageData(0, 0, maxWidth, maxHeight).data;
                        const palette = quantize(data, 256, {
                            format,
                            oneBitAlpha: true,
                            clearAlpha: true,
                            clearAlphaThreshold: 0,
                            clearAlphaColor: 0x00
                        });
                        const index = applyPalette(data, palette, format);
                        gif.writeFrame(index, maxWidth, maxHeight, {
                            palette,
                            delay,
                            transparent: true,
                            transparentIndex: 0
                        });

                        loadedFrames++;
                        if (loadedFrames === animationFrames.length) {
                            gif.finish();
                            const buffer = gif.bytesView();
                            const blob = new Blob([buffer], { type: 'image/gif' });
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.download = `${animNameInput.value || 'animation'}.gif`;
                            link.href = url;
                            link.click();
                            URL.revokeObjectURL(url);
                            exportGifBtn.disabled = false;
                            exportGifBtn.textContent = '💾 Export as GIF';
                        }
                        resolve();
                    };
                    img.src = frame.dataUrl;
                });
            };

            for (const frame of animationFrames) {
                await processFrame(frame);
            }
        }

        // Initialize zoom canvas
        zoomCanvas.width = 120;
        zoomCanvas.height = 120;

        playBtn.addEventListener('click', playAnimation);
        stopBtn.addEventListener('click', stopAnimation);
        exportGifBtn.addEventListener('click', exportGif);
        clearFramesBtn.addEventListener('click', () => {
            animationFrames = [];
            updateFrameTimeline();
            stopAnimation();
            animCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
            exportGifBtn.disabled = true;
        });
    </script>
</body>
</html>