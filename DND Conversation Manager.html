<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced D&D Narrative Weaver - Professional Edition</title>
    <style>
        :root {
            --bg-primary: #0a0b16;
            --bg-secondary: #1a1b2e;
            --bg-tertiary: #16213e;
            --accent: #242954;
            --text-primary: #f0f4f8;
            --text-secondary: #a8b2d1;
            --text-muted: #6b7280;
            --highlight: #e94560;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --purple: #8b5cf6;
            --border: #374151;
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            --glow: 0 0 20px rgba(233, 69, 96, 0.4);
            --glow-success: 0 0 20px rgba(16, 185, 129, 0.4);
            --glow-info: 0 0 20px rgba(59, 130, 246, 0.4);
            --card-bg: rgba(26, 27, 46, 0.95);
            --glass-bg: rgba(36, 41, 84, 0.8);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar main inspector"
                "sidebar main inspector";
            grid-template-columns: 320px 1fr 350px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }

        .header {
            grid-area: header;
            background: var(--card-bg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid var(--border);
            backdrop-filter: blur(10px);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--highlight);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .sidebar {
            grid-area: sidebar;
            background: var(--card-bg);
            overflow-y: auto;
            border-right: 1px solid var(--border);
        }

        .main-canvas {
            grid-area: main;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .main-canvas:active {
            cursor: grabbing;
        }

        .inspector {
            grid-area: inspector;
            background: var(--card-bg);
            border-left: 1px solid var(--border);
            overflow-y: auto;
        }

        /* Sidebar Sections */
        .section {
            margin: 15px;
            background: var(--glass-bg);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border);
            backdrop-filter: blur(5px);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--highlight);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .section-header .icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .form-input, .form-textarea, .form-select {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: all 0.2s ease;
            resize: vertical;
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: var(--highlight);
            box-shadow: 0 0 0 3px rgba(233, 69, 96, 0.1);
        }

        .form-textarea {
            min-height: 80px;
            font-family: inherit;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--highlight);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            justify-content: center;
            min-height: 40px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.3);
        }

        .btn.btn-secondary {
            background: var(--success);
        }

        .btn.btn-secondary:hover {
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }

        .btn.btn-info {
            background: var(--info);
        }

        .btn.btn-info:hover {
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.3);
        }

        .btn.btn-warning {
            background: var(--warning);
        }

        .btn.btn-warning:hover {
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }

        .btn.btn-danger {
            background: var(--danger);
        }

        .btn.btn-danger:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3);
        }

        .btn.btn-purple {
            background: var(--purple);
        }

        .btn.btn-purple:hover {
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.3);
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.8rem;
            min-height: 32px;
        }

        /* Canvas Elements */
        .canvas-viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: top left;
            transition: transform 0.2s ease-out;
        }

        .canvas-connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        /* Story Nodes */
        .story-node {
            position: absolute;
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            min-width: 280px;
            max-width: 350px;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 2;
            backdrop-filter: blur(10px);
            user-select: none;
        }

        .story-node:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow), var(--glow);
            border-color: var(--highlight);
        }

        .story-node.selected {
            border-color: var(--highlight);
            box-shadow: var(--shadow), var(--glow);
        }

        .story-node.dragging {
            z-index: 100;
            transform: scale(1.05);
            opacity: 0.9;
        }

        /* Node Types */
        .story-node.type-root {
            border-color: var(--purple);
            background: linear-gradient(135deg, var(--card-bg), rgba(139, 92, 246, 0.1));
        }

        .story-node.type-combat {
            border-color: var(--danger);
            background: linear-gradient(135deg, var(--card-bg), rgba(239, 68, 68, 0.1));
        }

        .story-node.type-social {
            border-color: var(--success);
            background: linear-gradient(135deg, var(--card-bg), rgba(16, 185, 129, 0.1));
        }

        .story-node.type-exploration {
            border-color: var(--info);
            background: linear-gradient(135deg, var(--card-bg), rgba(59, 130, 246, 0.1));
        }

        .story-node.type-mystery {
            border-color: var(--warning);
            background: linear-gradient(135deg, var(--card-bg), rgba(245, 158, 11, 0.1));
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .node-type-badge {
            background: var(--accent);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .node-probability {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-weight: 500;
        }

        .node-content {
            margin-bottom: 12px;
            line-height: 1.5;
            font-size: 0.95rem;
        }

        .node-content.editing {
            background: var(--bg-tertiary);
            border: 1px solid var(--highlight);
            border-radius: 6px;
            padding: 8px;
        }

        .node-metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
        }

        .metadata-tag {
            background: var(--accent);
            color: var(--text-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .node-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        /* Canvas Controls */
        .canvas-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .control-group {
            display: flex;
            gap: 5px;
            background: var(--glass-bg);
            border-radius: 8px;
            padding: 5px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
        }

        .control-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .control-btn:hover {
            background: var(--highlight);
            border-color: var(--highlight);
        }

        /* NPC Management */
        .npc-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .npc-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .npc-item:hover {
            border-color: var(--highlight);
            transform: translateY(-1px);
        }

        .npc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .npc-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .npc-details {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .npc-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .stat-item {
            text-align: center;
            padding: 4px;
            background: var(--accent);
            border-radius: 4px;
            font-size: 0.75rem;
        }

        /* Story State Panel */
        .state-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .state-item {
            background: var(--bg-tertiary);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .state-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--highlight);
            margin-bottom: 2px;
        }

        .state-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Plot Threads */
        .plot-thread {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .thread-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .thread-title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .thread-status {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .thread-status.active {
            background: var(--success);
            color: white;
        }

        .thread-status.dormant {
            background: var(--warning);
            color: white;
        }

        .thread-status.resolved {
            background: var(--text-muted);
            color: white;
        }

        .thread-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Search and Filters */
        .search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .search-input {
            width: 100%;
            padding: 10px 40px 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        /* Timeline */
        .timeline {
            margin-top: 15px;
        }

        .timeline-item {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .timeline-marker {
            width: 8px;
            height: 8px;
            background: var(--highlight);
            border-radius: 50%;
            margin-top: 6px;
            flex-shrink: 0;
        }

        .timeline-content {
            flex: 1;
        }

        .timeline-title {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .timeline-description {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.3;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--highlight);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--danger);
            color: white;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--glass-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            max-width: 350px;
            z-index: 1001;
            backdrop-filter: blur(10px);
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-color: var(--success);
        }

        .notification.error {
            border-color: var(--danger);
        }

        .notification.info {
            border-color: var(--info);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-areas: 
                    "header header"
                    "main main"
                    "sidebar inspector";
                grid-template-columns: 1fr 1fr;
                grid-template-rows: 60px 1fr 400px;
            }

            .main-canvas {
                order: 1;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "main"
                    "sidebar"
                    "inspector";
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr auto auto;
            }

            .story-node {
                min-width: 250px;
                max-width: 300px;
            }

            .canvas-controls {
                top: 10px;
                right: 10px;
            }
        }

        /* Animations */
        @keyframes nodeAppear {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .story-node.new {
            animation: nodeAppear 0.5s ease-out;
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: var(--shadow), 0 0 10px rgba(233, 69, 96, 0.3); }
            50% { box-shadow: var(--shadow), 0 0 20px rgba(233, 69, 96, 0.6); }
        }

        .story-node.highlighted {
            animation: pulseGlow 2s infinite;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Loading States */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--highlight);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Application Container -->
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <span>🎲</span>
                <span>Narrative Nexus</span>
                <span style="font-size: 0.8rem; color: var(--text-secondary); font-weight: normal;">Professional Campaign Weaver</span>
            </div>
            <div class="header-controls">
                <button class="btn btn-small btn-info" onclick="window.location.href='DND.html'">
                    ⚔️ Back to Combat Manager
                </button>
                <button class="btn btn-small btn-purple" onclick="showCampaignSettings()">
                    ⚙️ Campaign Settings
                </button>
                <button class="btn btn-small btn-info" onclick="exportCampaign()">
                    📤 Export
                </button>
                <button class="btn btn-small btn-secondary" onclick="showImportModal()">
                    📥 Import
                </button>
                <button class="btn btn-small btn-warning" onclick="quickSave()">
                    💾 Quick Save
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Scene Creation -->
            <div class="section">
                <div class="section-header">
                    <span class="icon">🌟</span>
                    <span>Scene Genesis</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Initial Scene Context</label>
                    <textarea 
                        id="sceneContext" 
                        class="form-textarea" 
                        placeholder="Describe the opening scene with rich detail: location, atmosphere, key NPCs present, ongoing tensions, environmental factors, and immediate plot hooks..."
                        rows="4"
                    ></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Narrative Focus</label>
                    <select id="narrativeFocus" class="form-select">
                        <option value="balanced">Balanced Dynamics</option>
                        <option value="party-driven">Party-Driven Choices</option>
                        <option value="npc-driven">NPC-Driven Events</option>
                        <option value="environmental">Environmental Forces</option>
                        <option value="mystery">Mystery & Investigation</option>
                        <option value="political">Political Intrigue</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Story Tension Level</label>
                    <select id="tensionLevel" class="form-select">
                        <option value="low">Peaceful & Exploratory</option>
                        <option value="medium">Moderate Tension</option>
                        <option value="high">High Stakes Drama</option>
                        <option value="climactic">Climactic Moments</option>
                    </select>
                </div>
                <button class="btn" onclick="initializeNarrative()" id="initBtn">
                    ✨ Weave Initial Paths
                </button>
            </div>

            <!-- NPC Management -->
            <div class="section">
                <div class="section-header">
                    <span class="icon">👥</span>
                    <span>Living Characters</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Character Name</label>
                    <input type="text" id="npcName" class="form-input" placeholder="e.g., Marcus Thornfield">
                </div>
                <div class="form-group">
                    <label class="form-label">Role & Archetype</label>
                    <select id="npcArchetype" class="form-select">
                        <option value="ally">Trusted Ally</option>
                        <option value="mentor">Wise Mentor</option>
                        <option value="rival">Complex Rival</option>
                        <option value="antagonist">Primary Antagonist</option>
                        <option value="neutral">Neutral Party</option>
                        <option value="informant">Information Broker</option>
                        <option value="merchant">Merchant/Trader</option>
                        <option value="authority">Authority Figure</option>
                        <option value="mystic">Mystic/Sage</option>
                        <option value="commoner">Common Folk</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Core Motivation</label>
                    <input type="text" id="npcMotivation" class="form-input" placeholder="What drives this character?">
                </div>
                <div class="form-group">
                    <label class="form-label">Key Relationships</label>
                    <input type="text" id="npcRelationships" class="form-input" placeholder="Who do they know? How do they feel about the party?">
                </div>
                <div class="form-group">
                    <label class="form-label">Secrets & Knowledge</label>
                    <textarea id="npcSecrets" class="form-textarea" placeholder="What do they know that others don't?" rows="2"></textarea>
                </div>
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="addNPC()">
                        ➕ Add Character
                    </button>
                    <button class="btn btn-small btn-info" onclick="generateRandomNPC()">
                        🎲 Random
                    </button>
                </div>
                <div class="npc-list" id="npcList">
                    <!-- NPCs will be populated here -->
                </div>
            </div>

            <!-- Plot Thread Tracker -->
            <div class="section">
                <div class="section-header">
                    <span class="icon">🧵</span>
                    <span>Plot Threads</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Thread Title</label>
                    <input type="text" id="threadTitle" class="form-input" placeholder="e.g., The Missing Heir">
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea id="threadDescription" class="form-textarea" placeholder="Detailed description of this plot thread..." rows="2"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Status</label>
                    <select id="threadStatus" class="form-select">
                        <option value="active">Active</option>
                        <option value="dormant">Dormant</option>
                        <option value="resolved">Resolved</option>
                    </select>
                </div>
                <button class="btn btn-secondary" onclick="addPlotThread()">
                    ➕ Add Thread
                </button>
                <div id="plotThreadsList">
                    <!-- Plot threads will be populated here -->
                </div>
            </div>
        </aside>

        <!-- Main Canvas -->
        <main class="main-canvas" id="mainCanvas">
            <div class="canvas-viewport" id="canvasViewport">
                <svg class="canvas-connections" id="canvasConnections"></svg>
                <!-- Story nodes will be populated here -->
            </div>

            <!-- Canvas Controls -->
            <div class="canvas-controls">
                <div class="control-group">
                    <div class="control-btn" onclick="zoomIn()" title="Zoom In">+</div>
                    <div class="control-btn" onclick="zoomOut()" title="Zoom Out">−</div>
                    <div class="control-btn" onclick="resetView()" title="Reset View">⌂</div>
                    <div class="control-btn" onclick="autoLayout()" title="Auto Layout">⚡</div>
                </div>
                <div class="control-group">
                    <div class="control-btn" onclick="toggleMinimap()" title="Minimap">🗺️</div>
                    <div class="control-btn" onclick="fullscreen()" title="Fullscreen">⛶</div>
                </div>
            </div>
        </main>

        <!-- Inspector Panel -->
        <aside class="inspector">
            <!-- Campaign State -->
            <div class="section">
                <div class="section-header">
                    <span class="icon">📊</span>
                    <span>Campaign State</span>
                </div>
                <div class="state-grid">
                    <div class="state-item">
                        <div class="state-value" id="totalNodes">0</div>
                        <div class="state-label">Total Nodes</div>
                    </div>
                    <div class="state-item">
                        <div class="state-value" id="activeThreads">0</div>
                        <div class="state-label">Active Threads</div>
                    </div>
                    <div class="state-item">
                        <div class="state-value" id="storyDepth">0</div>
                        <div class="state-label">Story Depth</div>
                    </div>
                    <div class="state-item">
                        <div class="state-value" id="totalNPCs">0</div>
                        <div class="state-label">NPCs</div>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Session Progress</label>
                    <div style="background: var(--bg-tertiary); border-radius: 6px; padding: 8px; margin-top: 5px;">
                        <div style="background: var(--success); height: 6px; border-radius: 3px; width: 65%; transition: width 0.3s ease;"></div>
                    </div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 4px;">Session Goal: Resolve merchant crisis</div>
                </div>
            </div>

            <!-- Selected Node Details -->
            <div class="section" id="nodeInspector" style="display: none;">
                <div class="section-header">
                    <span class="icon">🔍</span>
                    <span>Node Details</span>
                </div>
                <div id="nodeInspectorContent">
                    <!-- Selected node details will be populated here -->
                </div>
            </div>

            <!-- Search & Navigation -->
            <div class="section">
                <div class="section-header">
                    <span class="icon">🔎</span>
                    <span>Navigate & Search</span>
                </div>
                <div class="search-container">
                    <input type="text" id="searchInput" class="search-input" placeholder="Search nodes, NPCs, threads...">
                    <span class="search-icon">🔍</span>
                </div>
                <div class="btn-group">
                    <button class="btn btn-small btn-info" onclick="searchStory()">Search</button>
                    <button class="btn btn-small btn-secondary" onclick="clearSearch()">Clear</button>
                    <button class="btn btn-small btn-warning" onclick="focusRandomNode()">Random</button>
                </div>
                <div id="searchResults">
                    <!-- Search results will be populated here -->
                </div>
            </div>

            <!-- Narrative Tools -->
            <div class="section">
                <div class="section-header">
                    <span class="icon">🎭</span>
                    <span>Narrative Tools</span>
                </div>
                <div class="btn-group">
                    <button class="btn btn-small btn-purple" onclick="generatePlotTwist()">
                        🌪️ Plot Twist
                    </button>
                    <button class="btn btn-small btn-warning" onclick="rollFateCheck()">
                        🎲 Fate Check
                    </button>
                </div>
                <div class="btn-group">
                    <button class="btn btn-small btn-info" onclick="analyzeNarrative()">
                        📈 Analyze Flow
                    </button>
                    <button class="btn btn-small btn-secondary" onclick="suggestNextScene()">
                        💡 Suggest Scene
                    </button>
                </div>
            </div>

            <!-- Timeline -->
            <div class="section">
                <div class="section-header">
                    <span class="icon">⏰</span>
                    <span>Session Timeline</span>
                </div>
                <div class="timeline" id="sessionTimeline">
                    <!-- Timeline events will be populated here -->
                </div>
            </div>
        </aside>
    </div>

    <!-- Modals -->
    <div id="modalOverlay" class="modal-overlay" style="display: none;">
        <div class="modal" id="modalContent">
            <!-- Modal content will be populated dynamically -->
        </div>
    </div>

    <!-- Notifications -->
    <div id="notification" class="notification">
        <!-- Notification content will be populated dynamically -->
    </div>

    <script>
        // ==================== CORE APPLICATION STATE ====================
        
        class NarrativeState {
            constructor() {
                this.storyTree = null;
                this.npcs = new Map();
                this.plotThreads = new Map();
                this.storyHistory = [];
                this.currentSession = {
                    startTime: Date.now(),
                    events: [],
                    decisions: [],
                    progress: 0
                };
                this.worldState = {
                    locations: new Map(),
                    factions: new Map(),
                    resources: new Map(),
                    timeContext: 'present',
                    weatherPattern: 'clear',
                    politicalClimate: 'stable'
                };
                this.narrativeContext = {
                    genre: 'fantasy',
                    tone: 'adventure',
                    themes: ['heroism', 'discovery'],
                    currentAct: 1,
                    tensionLevel: 'medium',
                    pacingState: 'building'
                };
            }

            // Deep state management methods
            updateWorldState(key, value) {
                this.worldState[key] = value;
                this.triggerStateChange('worldState', key, value);
            }

            addHistoryEvent(event) {
                this.storyHistory.push({
                    timestamp: Date.now(),
                    event: event,
                    consequences: [],
                    affectedNPCs: [],
                    storyImpact: 'minor'
                });
                this.analyzeConsequences(event);
            }

            analyzeConsequences(event) {
                // Analyze how this event affects future story generation
                const affectedNPCs = this.findAffectedNPCs(event);
                const plotImpacts = this.findPlotThreadImpacts(event);
                
                // Update NPC states based on event
                affectedNPCs.forEach(npc => {
                    this.updateNPCState(npc.id, event);
                });

                // Update plot thread states
                plotImpacts.forEach(thread => {
                    this.updatePlotThreadState(thread.id, event);
                });
            }

            findAffectedNPCs(event) {
                const affected = [];
                const eventText = event.text.toLowerCase();
                
                this.npcs.forEach((npc, id) => {
                    // Check if NPC is mentioned or would be affected
                    if (eventText.includes(npc.name.toLowerCase()) ||
                        this.wouldNPCBeAffected(npc, event)) {
                        affected.push({ id, npc });
                    }
                });
                
                return affected;
            }

            wouldNPCBeAffected(npc, event) {
                // Advanced logic to determine if an NPC would be affected
                const eventLocation = this.extractLocation(event.text);
                const eventType = this.determineEventType(event.text);
                
                // Check if NPC would care about this type of event
                return npc.interests.some(interest => 
                    event.text.toLowerCase().includes(interest.toLowerCase())
                ) || npc.currentLocation === eventLocation;
            }

            updateNPCState(npcId, event) {
                const npc = this.npcs.get(npcId);
                if (!npc) return;

                // Update NPC's knowledge
                npc.knowledge.push({
                    event: event.text,
                    timestamp: Date.now(),
                    reliability: this.calculateReliability(npc, event)
                });

                // Update relationships based on event
                this.updateNPCRelationships(npc, event);

                // Update NPC's emotional state
                this.updateNPCEmotionalState(npc, event);
            }

            calculateReliability(npc, event) {
                // Determine how accurately the NPC knows about this event
                let reliability = 0.8; // Base reliability

                if (event.involvedNPCs && event.involvedNPCs.includes(npc.id)) {
                    reliability = 1.0; // Direct involvement
                } else if (npc.traits.includes('well-informed')) {
                    reliability = 0.9;
                } else if (npc.traits.includes('gossip')) {
                    reliability = 0.6; // Might have distorted information
                }

                return reliability;
            }

            triggerStateChange(category, key, value) {
                // Emit state change events for reactive updates
                document.dispatchEvent(new CustomEvent('narrativeStateChange', {
                    detail: { category, key, value, timestamp: Date.now() }
                }));
            }
        }

        // ==================== STORY NODE SYSTEM ====================

        class StoryNode {
            constructor(options = {}) {
                this.id = options.id || this.generateId();
                this.text = options.text || '';
                this.type = options.type || 'exploration';
                this.probability = options.probability || 0.5;
                this.consequences = options.consequences || [];
                this.requirements = options.requirements || [];
                this.tags = options.tags || [];
                this.involvedNPCs = options.involvedNPCs || [];
                this.affectedPlotThreads = options.affectedPlotThreads || [];
                this.position = options.position || { x: 0, y: 0 };
                this.children = [];
                this.parent = null;
                this.depth = options.depth || 0;
                this.timestamp = Date.now();
                this.metadata = {
                    difficulty: options.difficulty || 'medium',
                    estimated_duration: options.duration || '15-30 minutes',
                    tone: options.tone || 'neutral',
                    pacing: options.pacing || 'moderate'
                };
            }

            generateId() {
                return 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            addChild(childNode) {
                childNode.parent = this;
                childNode.depth = this.depth + 1;
                this.children.push(childNode);
                return childNode;
            }

            removeChild(childId) {
                this.children = this.children.filter(child => child.id !== childId);
            }

            getAncestors() {
                const ancestors = [];
                let current = this.parent;
                while (current) {
                    ancestors.unshift(current);
                    current = current.parent;
                }
                return ancestors;
            }

            getDescendants() {
                const descendants = [];
                const traverse = (node) => {
                    node.children.forEach(child => {
                        descendants.push(child);
                        traverse(child);
                    });
                };
                traverse(this);
                return descendants;
            }

            calculateNarrativeWeight() {
                // Calculate the importance of this node in the overall narrative
                let weight = this.probability;
                
                // Boost weight based on involved NPCs
                weight += this.involvedNPCs.length * 0.1;
                
                // Boost weight based on affected plot threads
                weight += this.affectedPlotThreads.length * 0.15;
                
                // Boost weight based on consequences
                weight += this.consequences.length * 0.05;
                
                return Math.min(weight, 1.0);
            }

            updateProbability(narrativeState) {
                // Dynamically update probability based on current narrative state
                let baseProbability = this.probability;
                
                // Adjust based on story history
                const relevantHistory = narrativeState.storyHistory.filter(event => 
                    this.isRelevantToEvent(event)
                );
                
                if (relevantHistory.length > 0) {
                    // Recent similar events might reduce probability (avoid repetition)
                    baseProbability *= (1 - (relevantHistory.length * 0.1));
                }
                
                // Adjust based on NPC states
                this.involvedNPCs.forEach(npcId => {
                    const npc = narrativeState.npcs.get(npcId);
                    if (npc) {
                        baseProbability *= this.calculateNPCInfluence(npc);
                    }
                });
                
                // Adjust based on plot thread states
                this.affectedPlotThreads.forEach(threadId => {
                    const thread = narrativeState.plotThreads.get(threadId);
                    if (thread && thread.status === 'active') {
                        baseProbability *= 1.2; // Boost active plot threads
                    }
                });
                
                this.probability = Math.max(0.1, Math.min(1.0, baseProbability));
            }

            isRelevantToEvent(event) {
                // Check if this node is similar to a historical event
                const eventWords = event.event.text.toLowerCase().split(' ');
                const nodeWords = this.text.toLowerCase().split(' ');
                
                const commonWords = eventWords.filter(word => 
                    nodeWords.includes(word) && word.length > 3
                );
                
                return commonWords.length >= 2;
            }

            calculateNPCInfluence(npc) {
                // Calculate how an NPC's current state affects this node's probability
                let influence = 1.0;
                
                // Check NPC's emotional state
                if (npc.emotionalState) {
                    switch (this.type) {
                        case 'combat':
                            if (npc.emotionalState === 'aggressive') influence *= 1.3;
                            if (npc.emotionalState === 'fearful') influence *= 0.7;
                            break;
                        case 'social':
                            if (npc.emotionalState === 'friendly') influence *= 1.2;
                            if (npc.emotionalState === 'suspicious') influence *= 0.8;
                            break;
                    }
                }
                
                // Check NPC's current goals
                if (npc.currentGoals) {
                    npc.currentGoals.forEach(goal => {
                        if (this.text.toLowerCase().includes(goal.toLowerCase())) {
                            influence *= 1.4; // Strong boost for goal-aligned actions
                        }
                    });
                }
                
                return influence;
            }

            serialize() {
                return {
                    id: this.id,
                    text: this.text,
                    type: this.type,
                    probability: this.probability,
                    consequences: this.consequences,
                    requirements: this.requirements,
                    tags: this.tags,
                    involvedNPCs: this.involvedNPCs,
                    affectedPlotThreads: this.affectedPlotThreads,
                    position: this.position,
                    depth: this.depth,
                    metadata: this.metadata,
                    children: this.children.map(child => child.serialize())
                };
            }

            static deserialize(data) {
                const node = new StoryNode(data);
                node.children = data.children.map(childData => {
                    const child = StoryNode.deserialize(childData);
                    child.parent = node;
                    return child;
                });
                return node;
            }
        }

        // ==================== ADVANCED NPC SYSTEM ====================

        class AdvancedNPC {
            constructor(options = {}) {
                this.id = options.id || this.generateId();
                this.name = options.name || '';
                this.archetype = options.archetype || 'neutral';
                this.coreMotivation = options.coreMotivation || '';
                this.relationships = new Map();
                this.secrets = options.secrets || [];
                this.knowledge = options.knowledge || [];
                this.currentGoals = options.currentGoals || [];
                this.traits = options.traits || [];
                this.stats = options.stats || this.generateStats();
                this.emotionalState = options.emotionalState || 'neutral';
                this.currentLocation = options.currentLocation || 'unknown';
                this.loyalties = new Map(); // Faction loyalties
                this.resources = options.resources || [];
                this.schedule = options.schedule || {};
                this.history = [];
                this.reputation = options.reputation || {};
                this.interests = options.interests || [];
                this.fears = options.fears || [];
                this.timestamp = Date.now();
            }

            generateId() {
                return 'npc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            generateStats() {
                return {
                    strength: this.rollStat(),
                    dexterity: this.rollStat(),
                    constitution: this.rollStat(),
                    intelligence: this.rollStat(),
                    wisdom: this.rollStat(),
                    charisma: this.rollStat()
                };
            }

            rollStat() {
                // 4d6 drop lowest
                const rolls = [1,2,3,4].map(() => Math.floor(Math.random() * 6) + 1);
                rolls.sort((a, b) => b - a);
                return rolls.slice(0, 3).reduce((sum, roll) => sum + roll, 0);
            }

            updateRelationship(targetId, type, strength, reason = '') {
                this.relationships.set(targetId, {
                    type: type, // 'ally', 'enemy', 'neutral', 'romantic', 'family', etc.
                    strength: strength, // -10 to +10
                    reason: reason,
                    history: this.relationships.get(targetId)?.history || [],
                    lastUpdated: Date.now()
                });
            }

            addGoal(goal, priority = 'medium', deadline = null) {
                this.currentGoals.push({
                    id: this.generateId(),
                    description: goal,
                    priority: priority, // 'low', 'medium', 'high', 'critical'
                    deadline: deadline,
                    status: 'active',
                    progress: 0,
                    obstacles: [],
                    createdAt: Date.now()
                });
            }

            updateGoalProgress(goalId, progress, obstacles = []) {
                const goal = this.currentGoals.find(g => g.id === goalId);
                if (goal) {
                    goal.progress = progress;
                    goal.obstacles = obstacles;
                    goal.lastUpdated = Date.now();
                    
                    if (progress >= 100) {
                        goal.status = 'completed';
                        this.addHistoryEvent(`Completed goal: ${goal.description}`);
                    }
                }
            }

            addSecretKnowledge(secret, reliability = 1.0, source = 'unknown') {
                this.secrets.push({
                    id: this.generateId(),
                    content: secret,
                    reliability: reliability,
                    source: source,
                    discoveredAt: Date.now(),
                    shared: false,
                    importance: this.assessSecretImportance(secret)
                });
            }

            assessSecretImportance(secret) {
                // Simple keyword-based importance assessment
                const highImportanceWords = ['king', 'queen', 'murder', 'treasure', 'conspiracy', 'war'];
                const mediumImportanceWords = ['affair', 'debt', 'illness', 'plan', 'meeting'];
                
                const secretLower = secret.toLowerCase();
                
                if (highImportanceWords.some(word => secretLower.includes(word))) {
                    return 'critical';
                } else if (mediumImportanceWords.some(word => secretLower.includes(word))) {
                    return 'important';
                } else {
                    return 'minor';
                }
            }

            reactToEvent(event, narrativeState) {
                // Generate an NPC's reaction to a story event
                const reaction = {
                    emotional: this.calculateEmotionalReaction(event),
                    behavioral: this.calculateBehavioralReaction(event),
                    goals: this.adjustGoalsBasedOnEvent(event),
                    relationships: this.adjustRelationshipsBasedOnEvent(event, narrativeState)
                };

                this.applyReaction(reaction);
                return reaction;
            }

            calculateEmotionalReaction(event) {
                let emotionalChange = 0;
                const eventType = this.determineEventType(event.text);
                
                // Base reactions based on archetype
                switch (this.archetype) {
                    case 'ally':
                        if (eventType === 'party_success') emotionalChange = 2;
                        if (eventType === 'party_failure') emotionalChange = -1;
                        break;
                    case 'rival':
                        if (eventType === 'party_success') emotionalChange = -1;
                        if (eventType === 'party_failure') emotionalChange = 1;
                        break;
                    case 'antagonist':
                        if (eventType === 'party_success') emotionalChange = -2;
                        if (eventType === 'conflict') emotionalChange = 1;
                        break;
                }

                // Modify based on personal interests
                this.interests.forEach(interest => {
                    if (event.text.toLowerCase().includes(interest.toLowerCase())) {
                        emotionalChange += 1;
                    }
                });

                // Modify based on fears
                this.fears.forEach(fear => {
                    if (event.text.toLowerCase().includes(fear.toLowerCase())) {
                        emotionalChange -= 2;
                    }
                });

                return emotionalChange;
            }

            calculateBehavioralReaction(event) {
                // Determine what actions the NPC might take
                const possibleActions = [];
                
                if (this.isDirectlyAffected(event)) {
                    possibleActions.push('seek_information');
                    possibleActions.push('change_plans');
                }

                if (this.hasRelevantSecrets(event)) {
                    possibleActions.push('share_information');
                    possibleActions.push('hide_information');
                }

                if (this.currentGoals.some(goal => this.eventAffectsGoal(event, goal))) {
                    possibleActions.push('adjust_goals');
                    possibleActions.push('accelerate_plans');
                }

                return possibleActions;
            }

            adjustGoalsBasedOnEvent(event) {
                const adjustments = [];
                
                this.currentGoals.forEach(goal => {
                    if (this.eventAffectsGoal(event, goal)) {
                        if (this.eventHelpsGoal(event, goal)) {
                            adjustments.push({
                                goalId: goal.id,
                                type: 'progress_boost',
                                amount: 10
                            });
                        } else if (this.eventHindersGoal(event, goal)) {
                            adjustments.push({
                                goalId: goal.id,
                                type: 'add_obstacle',
                                obstacle: event.text
                            });
                        }
                    }
                });

                return adjustments;
            }

            determineEventType(eventText) {
                const text = eventText.toLowerCase();
                
                if (text.includes('succeed') || text.includes('victory') || text.includes('win')) {
                    return 'party_success';
                } else if (text.includes('fail') || text.includes('defeat') || text.includes('lose')) {
                    return 'party_failure';
                } else if (text.includes('fight') || text.includes('battle') || text.includes('attack')) {
                    return 'conflict';
                } else if (text.includes('negotiate') || text.includes('talk') || text.includes('discuss')) {
                    return 'social';
                } else {
                    return 'general';
                }
            }

            isDirectlyAffected(event) {
                return event.text.toLowerCase().includes(this.name.toLowerCase()) ||
                       event.involvedNPCs.includes(this.id);
            }

            hasRelevantSecrets(event) {
                return this.secrets.some(secret => 
                    this.isSecretRelevantToEvent(secret, event)
                );
            }

            isSecretRelevantToEvent(secret, event) {
                const secretWords = secret.content.toLowerCase().split(' ');
                const eventWords = event.text.toLowerCase().split(' ');
                
                return secretWords.some(word => 
                    eventWords.includes(word) && word.length > 3
                );
            }

            eventAffectsGoal(event, goal) {
                const goalWords = goal.description.toLowerCase().split(' ');
                const eventWords = event.text.toLowerCase().split(' ');
                
                return goalWords.some(word => 
                    eventWords.includes(word) && word.length > 3
                );
            }

            eventHelpsGoal(event, goal) {
                // Simple heuristic - if event contains positive words and relates to goal
                const positiveWords = ['succeed', 'win', 'complete', 'achieve', 'find', 'discover'];
                const eventText = event.text.toLowerCase();
                
                return positiveWords.some(word => eventText.includes(word)) &&
                       this.eventAffectsGoal(event, goal);
            }

            eventHindersGoal(event, goal) {
                // Simple heuristic - if event contains negative words and relates to goal
                const negativeWords = ['fail', 'lose', 'block', 'prevent', 'destroy', 'stop'];
                const eventText = event.text.toLowerCase();
                
                return negativeWords.some(word => eventText.includes(word)) &&
                       this.eventAffectsGoal(event, goal);
            }

            applyReaction(reaction) {
                // Apply the calculated reaction to the NPC's state
                if (reaction.emotional !== 0) {
                    this.updateEmotionalState(reaction.emotional);
                }

                reaction.goals.forEach(adjustment => {
                    this.applyGoalAdjustment(adjustment);
                });

                this.addHistoryEvent(`Reacted to event with ${reaction.behavioral.join(', ')}`);
            }

            updateEmotionalState(change) {
                const currentEmotionValue = this.getEmotionValue(this.emotionalState);
                const newValue = Math.max(-5, Math.min(5, currentEmotionValue + change));
                this.emotionalState = this.getEmotionFromValue(newValue);
            }

            getEmotionValue(emotion) {
                const emotionMap = {
                    'furious': -5, 'angry': -3, 'irritated': -1,
                    'neutral': 0,
                    'pleased': 1, 'happy': 3, 'ecstatic': 5,
                    'fearful': -4, 'suspicious': -2, 'trusting': 2, 'loyal': 4
                };
                return emotionMap[emotion] || 0;
            }

            getEmotionFromValue(value) {
                if (value <= -5) return 'furious';
                if (value <= -3) return 'angry';
                if (value <= -1) return 'irritated';
                if (value === 0) return 'neutral';
                if (value >= 5) return 'ecstatic';
                if (value >= 3) return 'happy';
                if (value >= 1) return 'pleased';
                return 'neutral';
            }

            applyGoalAdjustment(adjustment) {
                const goal = this.currentGoals.find(g => g.id === adjustment.goalId);
                if (!goal) return;

                switch (adjustment.type) {
                    case 'progress_boost':
                        goal.progress = Math.min(100, goal.progress + adjustment.amount);
                        break;
                    case 'add_obstacle':
                        goal.obstacles.push(adjustment.obstacle);
                        break;
                    case 'change_priority':
                        goal.priority = adjustment.newPriority;
                        break;
                }
            }

            addHistoryEvent(event) {
                this.history.push({
                    timestamp: Date.now(),
                    event: event,
                    emotionalState: this.emotionalState,
                    activeGoals: this.currentGoals.length
                });

                // Keep history manageable
                if (this.history.length > 50) {
                    this.history.shift();
                }
            }

            serialize() {
                return {
                    id: this.id,
                    name: this.name,
                    archetype: this.archetype,
                    coreMotivation: this.coreMotivation,
                    relationships: Array.from(this.relationships.entries()),
                    secrets: this.secrets,
                    knowledge: this.knowledge,
                    currentGoals: this.currentGoals,
                    traits: this.traits,
                    stats: this.stats,
                    emotionalState: this.emotionalState,
                    currentLocation: this.currentLocation,
                    loyalties: Array.from(this.loyalties.entries()),
                    resources: this.resources,
                    schedule: this.schedule,
                    history: this.history,
                    reputation: this.reputation,
                    interests: this.interests,
                    fears: this.fears,
                    timestamp: this.timestamp
                };
            }

            static deserialize(data) {
                const npc = new AdvancedNPC(data);
                npc.relationships = new Map(data.relationships);
                npc.loyalties = new Map(data.loyalties);
                return npc;
            }
        }

        // ==================== INTELLIGENT STORY GENERATOR ====================

        class IntelligentStoryGenerator {
            constructor(narrativeState) {
                this.narrativeState = narrativeState;
                this.storyTemplates = this.initializeTemplates();
                this.causality = new CausalityEngine();
                this.contextAnalyzer = new ContextAnalyzer();
            }

            initializeTemplates() {
                return {
                    combat: [
                        {
                            pattern: "{threat} {action} the party because {reason}",
                            requirements: ['threat_present', 'motivation'],
                            consequences: ['reputation_change', 'resource_loss', 'npc_reaction']
                        },
                        {
                            pattern: "A conflict erupts between {npc1} and {npc2} over {resource}",
                            requirements: ['multiple_npcs', 'contested_resource'],
                            consequences: ['relationship_change', 'power_shift']
                        }
                    ],
                    social: [
                        {
                            pattern: "{npc} reveals {secret} to gain {party_asset}",
                            requirements: ['npc_with_secrets', 'party_has_asset'],
                            consequences: ['secret_known', 'trust_change', 'information_spread']
                        },
                        {
                            pattern: "A negotiation begins between {faction1} and {faction2} regarding {issue}",
                            requirements: ['multiple_factions', 'contested_issue'],
                            consequences: ['political_change', 'alliance_formation']
                        }
                    ],
                    exploration: [
                        {
                            pattern: "The party discovers {discovery} in {location}, revealing {implication}",
                            requirements: ['unexplored_location', 'hidden_information'],
                            consequences: ['new_location', 'plot_advancement', 'resource_gain']
                        },
                        {
                            pattern: "{environmental_factor} forces the party to {adaptation}",
                            requirements: ['environmental_pressure'],
                            consequences: ['route_change', 'resource_expenditure', 'time_pressure']
                        }
                    ],
                    mystery: [
                        {
                            pattern: "New evidence suggests {revelation} about {mystery_element}",
                            requirements: ['active_mystery', 'investigative_action'],
                            consequences: ['mystery_progression', 'red_herring', 'breakthrough']
                        },
                        {
                            pattern: "{witness} provides {testimony} that contradicts {previous_belief}",
                            requirements: ['available_witness', 'conflicting_information'],
                            consequences: ['doubt_creation', 'investigation_redirection']
                        }
                    ]
                };
            }

            generateBranches(parentNode, numBranches = 3) {
                const context = this.buildRichContext(parentNode);
                const branches = [];

                // Analyze what should happen next based on narrative structure
                const narrativeNeeds = this.analyzeNarrativeNeeds(context);
                
                // Generate branches that address these needs
                for (let i = 0; i < numBranches; i++) {
                    const branch = this.generateSingleBranch(context, narrativeNeeds, i);
                    if (branch) {
                        branches.push(branch);
                    }
                }

                // Ensure variety in branch types
                this.ensureBranchVariety(branches, context);

                return branches;
            }

            buildRichContext(parentNode) {
                return {
                    parentNode: parentNode,
                    storyHistory: this.narrativeState.storyHistory,
                    activeNPCs: this.getActiveNPCs(parentNode),
                    currentPlotThreads: this.getActivePlotThreads(),
                    worldState: this.narrativeState.worldState,
                    narrativeContext: this.narrativeState.narrativeContext,
                    recentEvents: this.getRecentEvents(5),
                    availableLocations: this.getAvailableLocations(),
                    timeContext: this.narrativeState.worldState.timeContext,
                    tensionLevel: this.narrativeState.narrativeContext.tensionLevel
                };
            }

            analyzeNarrativeNeeds(context) {
                const needs = {
                    pacing: this.analyzePacingNeeds(context),
                    characterDevelopment: this.analyzeCharacterNeeds(context),
                    plotProgression: this.analyzePlotNeeds(context),
                    worldBuilding: this.analyzeWorldBuildingNeeds(context),
                    emotionalBeats: this.analyzeEmotionalNeeds(context)
                };

                return needs;
            }

            analyzePacingNeeds(context) {
                const recentNodeTypes = context.recentEvents.map(event => event.type);
                const lastThreeTypes = recentNodeTypes.slice(-3);

                if (lastThreeTypes.every(type => type === 'combat')) {
                    return { needsCalm: true, needsIntensity: false };
                } else if (lastThreeTypes.every(type => type === 'social')) {
                    return { needsAction: true, needsQuiet: false };
                } else if (context.tensionLevel === 'high' && lastThreeTypes.length >= 2) {
                    return { needsRelease: true, needsBuildup: false };
                } else {
                    return { needsBuildup: true, needsVariety: true };
                }
            }

            analyzeCharacterNeeds(context) {
                const needs = {
                    underdevelopedNPCs: [],
                    stagnantRelationships: [],
                    unresolved_character_arcs: []
                };

                // Find NPCs that haven't been featured recently
                context.activeNPCs.forEach(npc => {
                    const recentMentions = context.recentEvents.filter(event => 
                        event.involvedNPCs.includes(npc.id)
                    ).length;

                    if (recentMentions === 0) {
                        needs.underdevelopedNPCs.push(npc);
                    }
                });

                return needs;
            }

            analyzePlotNeeds(context) {
                const needs = {
                    threadsToAdvance: [],
                    threadsToIntroduce: [],
                    threadsToResolve: []
                };

                context.currentPlotThreads.forEach(thread => {
                    const timeSinceLastUpdate = Date.now() - thread.lastUpdated;
                    const daysSinceUpdate = timeSinceLastUpdate / (1000 * 60 * 60 * 24);

                    if (thread.status === 'active' && daysSinceUpdate > 1) {
                        needs.threadsToAdvance.push(thread);
                    } else if (thread.status === 'dormant' && daysSinceUpdate > 3) {
                        needs.threadsToIntroduce.push(thread);
                    } else if (thread.progress > 80) {
                        needs.threadsToResolve.push(thread);
                    }
                });

                return needs;
            }

            analyzeWorldBuildingNeeds(context) {
                const needs = {
                    unexploredLocations: [],
                    underdevelopedFactions: [],
                    missingWorldElements: [],
                    consistencyIssues: []
                };

                // Check for locations that haven't been explored
                if (context.availableLocations && Array.isArray(context.availableLocations)) {
                    needs.unexploredLocations = context.availableLocations.filter(loc => 
                        loc && !loc.explored && !context.recentEvents.some(event => 
                            event.text && event.text.toLowerCase().includes((loc.name || '').toLowerCase())
                        )
                    );
                }

                // Check for underdeveloped factions - handle both Map and Object
                const factions = this.narrativeState.worldState.factions;
                let factionsArray = [];
                if (factions instanceof Map) {
                    factionsArray = Array.from(factions.values());
                } else if (factions && typeof factions === 'object') {
                    factionsArray = Object.values(factions);
                }
                
                needs.underdevelopedFactions = factionsArray.filter(faction => {
                    if (!faction || !faction.name) return false;
                    const recentMentions = context.recentEvents.filter(event =>
                        event.text && event.text.toLowerCase().includes(faction.name.toLowerCase())
                    ).length;
                    return recentMentions === 0 && (faction.importance || 0) > 0.5;
                });

                // Identify missing world elements based on story context
                if (context.parentNode && context.parentNode.text) {
                    const storyElements = this.extractWorldElements(context.parentNode.text);
                    if (storyElements.needsWeather && !context.worldState.weatherPattern) {
                        needs.missingWorldElements.push('weather_description');
                    }
                    if (storyElements.needsTime && !context.timeContext) {
                        needs.missingWorldElements.push('time_context');
                    }
                    if (storyElements.needsLocation && context.availableLocations.length === 0) {
                        needs.missingWorldElements.push('location_details');
                    }
                }

                return needs;
            }

            analyzeEmotionalNeeds(context) {
                const needs = {
                    tensionBuildup: false,
                    tensionRelease: false,
                    characterBonding: false,
                    emotionalPayoff: false,
                    moodShift: false
                };

                // Analyze recent emotional trajectory
                const recentEmotions = context.recentEvents.map(event => 
                    this.contextAnalyzer.analyzeEmotionalTone(event.text)
                );

                // Check if we need tension buildup
                if (recentEmotions.length >= 2) {
                    const lastTwo = recentEmotions.slice(-2);
                    const isFlat = lastTwo.every(emotion => 
                        emotion.intensity < 0.3 && emotion.dominant === 'neutral'
                    );
                    if (isFlat && context.tensionLevel === 'low') {
                        needs.tensionBuildup = true;
                    }
                }

                // Check if we need tension release
                const highTensionEvents = recentEmotions.filter(emotion => 
                    emotion.intensity > 0.7 && 
                    ['fear', 'anger', 'anticipation'].includes(emotion.dominant)
                ).length;
                if (highTensionEvents >= 2) {
                    needs.tensionRelease = true;
                }

                // Check for character bonding opportunities
                const recentSocialEvents = context.recentEvents.filter(event =>
                    event.type === 'social' || event.text.toLowerCase().includes('talk')
                ).length;
                if (recentSocialEvents === 0 && context.activeNPCs.length > 1) {
                    needs.characterBonding = true;
                }

                // Check for emotional payoff needs
                const setupEvents = context.recentEvents.filter(event =>
                    event.text.toLowerCase().includes('setup') || 
                    event.text.toLowerCase().includes('plan') ||
                    event.text.toLowerCase().includes('prepare')
                ).length;
                if (setupEvents > 0 && !recentEmotions.some(e => e.dominant === 'joy')) {
                    needs.emotionalPayoff = true;
                }

                // Check if we need a mood shift
                const dominantMood = this.findDominantMood(recentEmotions);
                if (dominantMood && recentEmotions.length >= 3) {
                    const consistentMood = recentEmotions.slice(-3).every(emotion => 
                        emotion.dominant === dominantMood
                    );
                    if (consistentMood) {
                        needs.moodShift = true;
                    }
                }

                return needs;
            }

            extractWorldElements(text) {
                const textLower = text.toLowerCase();
                return {
                    needsWeather: textLower.includes('outside') || textLower.includes('travel') || textLower.includes('journey'),
                    needsTime: textLower.includes('when') || textLower.includes('time') || textLower.includes('hour'),
                    needsLocation: textLower.includes('where') || textLower.includes('place') || textLower.includes('location'),
                    needsPolitics: textLower.includes('kingdom') || textLower.includes('ruler') || textLower.includes('law'),
                    needsEconomy: textLower.includes('trade') || textLower.includes('money') || textLower.includes('merchant')
                };
            }

            findDominantMood(emotions) {
                if (emotions.length === 0) return null;
                
                const moodCount = {};
                emotions.forEach(emotion => {
                    moodCount[emotion.dominant] = (moodCount[emotion.dominant] || 0) + 1;
                });
                
                return Object.keys(moodCount).reduce((a, b) => 
                    moodCount[a] > moodCount[b] ? a : b
                );
            }

            generateSingleBranch(context, needs, index) {
                // Determine the best branch type for this position
                const branchType = this.determineBranchType(context, needs, index);
                const template = this.selectTemplate(branchType, context);
                
                if (!template) return null;

                // Fill in the template with contextually appropriate content
                const filledTemplate = this.fillTemplate(template, context);
                
                // Calculate probability based on multiple factors
                const probability = this.calculateIntelligentProbability(filledTemplate, context, needs);

                // Determine consequences
                const consequences = this.predictConsequences(filledTemplate, context);

                // Create the node
                const branch = new StoryNode({
                    text: filledTemplate.text,
                    type: branchType,
                    probability: probability,
                    consequences: consequences,
                    involvedNPCs: filledTemplate.involvedNPCs || [],
                    affectedPlotThreads: filledTemplate.affectedPlotThreads || [],
                    tags: filledTemplate.tags || [],
                    requirements: template.requirements || []
                });

                return branch;
            }

            determineBranchType(context, needs, index) {
                const pacingNeeds = needs.pacing;
                const availableTypes = ['combat', 'social', 'exploration', 'mystery'];

                // Filter types based on pacing needs
                let suitableTypes = availableTypes;

                if (pacingNeeds.needsCalm) {
                    suitableTypes = ['social', 'exploration'];
                } else if (pacingNeeds.needsAction) {
                    suitableTypes = ['combat', 'exploration'];
                } else if (pacingNeeds.needsIntensity) {
                    suitableTypes = ['combat', 'mystery'];
                }

                // Ensure the first branch addresses the most pressing need
                if (index === 0) {
                    if (needs.plotProgression.threadsToAdvance.length > 0) {
                        const thread = needs.plotProgression.threadsToAdvance[0];
                        return thread.preferredBranchType || 'social';
                    }
                    if (needs.characterDevelopment.underdevelopedNPCs.length > 0) {
                        return 'social';
                    }
                }

                // For subsequent branches, provide variety
                return suitableTypes[index % suitableTypes.length];
            }

            selectTemplate(branchType, context) {
                const templates = this.storyTemplates[branchType] || [];
                
                // Filter templates by requirements
                const availableTemplates = templates.filter(template => 
                    this.checkRequirements(template.requirements, context)
                );

                if (availableTemplates.length === 0) {
                    return templates[0]; // Fallback to first template
                }

                // Select based on context relevance
                return this.selectMostRelevantTemplate(availableTemplates, context);
            }

            checkRequirements(requirements, context) {
                return requirements.every(req => {
                    switch (req) {
                        case 'threat_present':
                            return context.activeNPCs.some(npc => 
                                npc.archetype === 'antagonist' || npc.archetype === 'rival'
                            );
                        case 'multiple_npcs':
                            return context.activeNPCs.length >= 2;
                        case 'npc_with_secrets':
                            return context.activeNPCs.some(npc => npc.secrets.length > 0);
                        case 'active_mystery':
                            return context.currentPlotThreads.some(thread => 
                                thread.type === 'mystery' && thread.status === 'active'
                            );
                        case 'unexplored_location':
                            return context.availableLocations.some(loc => !loc.explored);
                        default:
                            return true;
                    }
                });
            }

            selectMostRelevantTemplate(templates, context) {
                // Score each template based on how well it fits the current context
                const scoredTemplates = templates.map(template => ({
                    template,
                    score: this.scoreTemplateRelevance(template, context)
                }));

                scoredTemplates.sort((a, b) => b.score - a.score);
                return scoredTemplates[0].template;
            }

            scoreTemplateRelevance(template, context) {
                let score = 0;

                // Score based on recent events (avoid repetition)
                const recentPatterns = context.recentEvents.map(event => 
                    this.extractPattern(event.text)
                );
                const templatePattern = template.pattern;

                if (!recentPatterns.some(pattern => 
                    this.patternsAreSimilar(pattern, templatePattern)
                )) {
                    score += 2; // Bonus for novelty
                }

                // Score based on available NPCs
                const requiredNPCs = this.extractNPCRequirements(template.pattern);
                const availableNPCs = context.activeNPCs.filter(npc => 
                    requiredNPCs.some(req => this.npcMeetsRequirement(npc, req))
                );

                score += Math.min(requiredNPCs.length, availableNPCs.length);

                // Score based on plot thread relevance
                const templateConsequences = template.consequences || [];
                const relevantThreads = context.currentPlotThreads.filter(thread =>
                    templateConsequences.some(consequence => 
                        this.consequenceAffectsThread(consequence, thread)
                    )
                );

                score += relevantThreads.length * 0.5;

                return score;
            }

            fillTemplate(template, context) {
                let filledText = template.pattern;
                const involvedNPCs = [];
                const affectedPlotThreads = [];
                const tags = [];

                // Extract placeholder variables
                const placeholders = filledText.match(/\{[^}]+\}/g) || [];

                placeholders.forEach(placeholder => {
                    const varName = placeholder.slice(1, -1); // Remove braces
                    const replacement = this.getReplacementForVariable(varName, context);
                    
                    if (replacement) {
                        filledText = filledText.replace(placeholder, replacement.text);
                        
                        if (replacement.npcId) {
                            involvedNPCs.push(replacement.npcId);
                        }
                        if (replacement.threadId) {
                            affectedPlotThreads.push(replacement.threadId);
                        }
                        if (replacement.tags) {
                            tags.push(...replacement.tags);
                        }
                    }
                });

                return {
                    text: filledText,
                    involvedNPCs: [...new Set(involvedNPCs)], // Remove duplicates
                    affectedPlotThreads: [...new Set(affectedPlotThreads)],
                    tags: [...new Set(tags)]
                };
            }

            getReplacementForVariable(varName, context) {
                switch (varName) {
                    case 'threat':
                        const threats = context.activeNPCs.filter(npc => 
                            npc.archetype === 'antagonist' || npc.archetype === 'rival'
                        );
                        if (threats.length > 0) {
                            const threat = threats[Math.floor(Math.random() * threats.length)];
                            return { 
                                text: threat.name || 'Unknown threat', 
                                npcId: threat.id,
                                tags: ['threat', 'npc']
                            };
                        }
                        return { text: 'a dangerous adversary', tags: ['threat'] };

                    case 'npc':
                    case 'npc1':
                    case 'npc2':
                        const availableNPCs = context.activeNPCs.filter(npc => 
                            !context.recentEvents.some(event => 
                                event.involvedNPCs && event.involvedNPCs.includes(npc.id)
                            )
                        );
                        if (availableNPCs.length > 0) {
                            const npc = availableNPCs[Math.floor(Math.random() * availableNPCs.length)];
                            return { 
                                text: npc.name || 'Unknown character', 
                                npcId: npc.id,
                                tags: ['npc', npc.archetype || 'unknown']
                            };
                        }
                        return { text: 'a mysterious figure', tags: ['npc', 'mystery'] };

                    case 'secret':
                        const npcsWithSecrets = context.activeNPCs.filter(npc => 
                            npc.secrets && npc.secrets.length > 0
                        );
                        if (npcsWithSecrets.length > 0) {
                            const npc = npcsWithSecrets[Math.floor(Math.random() * npcsWithSecrets.length)];
                            const secret = npc.secrets[Math.floor(Math.random() * npc.secrets.length)];
                            return { 
                                text: (secret && secret.content) ? secret.content : 'a mysterious secret',
                                npcId: npc.id,
                                tags: ['secret', 'information']
                            };
                        }
                        return { text: 'a hidden truth', tags: ['secret'] };

                    case 'location':
                        const locations = context.availableLocations || [];
                        if (locations.length > 0) {
                            const location = locations[Math.floor(Math.random() * locations.length)];
                            return { 
                                text: (location && location.name) ? location.name : 'a mysterious place',
                                tags: ['location', (location && location.type) ? location.type : 'unknown']
                            };
                        }
                        return { text: 'a nearby area', tags: ['location'] };

                    case 'action':
                        const actions = this.getContextualActions(context);
                        const action = actions[Math.floor(Math.random() * actions.length)];
                        return { text: action || 'acts', tags: ['action'] };

                    case 'reason':
                        const reasons = this.getContextualReasons(context);
                        const reason = reasons[Math.floor(Math.random() * reasons.length)];
                        return { text: reason || 'unknown reasons', tags: ['motivation'] };

                    default:
                        return { text: `[${varName}]`, tags: ['placeholder'] };
                }
            }

            getContextualActions(context) {
                const baseActions = ['approaches', 'confronts', 'follows', 'investigates', 'challenges'];
                
                // Add context-specific actions
                if (context.tensionLevel === 'high') {
                    baseActions.push('attacks', 'threatens', 'ambushes');
                }
                if (context.narrativeContext && context.narrativeContext.currentAct >= 2) {
                    baseActions.push('betrays', 'reveals', 'manipulates');
                }

                return baseActions;
            }

            getContextualReasons(context) {
                const baseReasons = ['of a past grievance', 'of conflicting interests', 'of a misunderstanding'];
                
                // Add reasons based on active plot threads
                if (context.currentPlotThreads) {
                    context.currentPlotThreads.forEach(thread => {
                        if (thread.status === 'active' && thread.title) {
                            baseReasons.push(`of the ${thread.title.toLowerCase()}`);
                        }
                    });
                }

                // Add reasons based on NPC motivations
                if (context.activeNPCs) {
                    context.activeNPCs.forEach(npc => {
                        if (npc.coreMotivation) {
                            baseReasons.push(`of their desire to ${npc.coreMotivation.toLowerCase()}`);
                        }
                    });
                }

                return baseReasons;
            }

            calculateIntelligentProbability(filledTemplate, context, needs) {
                let baseProbability = 0.5;

                // Adjust based on narrative needs
                if (this.addressesNarrativeNeed(filledTemplate, needs)) {
                    baseProbability += 0.3;
                }

                // Adjust based on NPC states
                filledTemplate.involvedNPCs.forEach(npcId => {
                    const npc = context.activeNPCs.find(n => n.id === npcId);
                    if (npc) {
                        baseProbability += this.calculateNPCProbabilityModifier(npc, filledTemplate);
                    }
                });

                // Adjust based on recent events (avoid repetition)
                const similarity = this.calculateSimilarityToRecentEvents(filledTemplate, context);
                baseProbability -= similarity * 0.2;

                // Adjust based on world state
                baseProbability += this.calculateWorldStateModifier(filledTemplate, context);

                // Clamp between 0.1 and 0.9
                return Math.max(0.1, Math.min(0.9, baseProbability));
            }

            addressesNarrativeNeed(filledTemplate, needs) {
                // Check if this template addresses any identified narrative needs
                if (needs.characterDevelopment.underdevelopedNPCs.some(npc => 
                    filledTemplate.involvedNPCs.includes(npc.id)
                )) {
                    return true;
                }

                if (needs.plotProgression.threadsToAdvance.some(thread => 
                    filledTemplate.affectedPlotThreads.includes(thread.id)
                )) {
                    return true;
                }

                return false;
            }

            calculateNPCProbabilityModifier(npc, filledTemplate) {
                let modifier = 0;

                // Check if action aligns with NPC's current goals
                npc.currentGoals.forEach(goal => {
                    if (this.actionSupportsGoal(filledTemplate.text, goal)) {
                        modifier += 0.1 * (goal.priority === 'high' ? 2 : goal.priority === 'medium' ? 1 : 0.5);
                    }
                });

                // Check emotional state compatibility
                if (this.actionMatchesEmotionalState(filledTemplate.text, npc.emotionalState)) {
                    modifier += 0.1;
                }

                // Check archetype compatibility
                modifier += this.getArchetypeActionModifier(npc.archetype, filledTemplate.text);

                return modifier;
            }

            actionSupportsGoal(actionText, goal) {
                const actionWords = actionText.toLowerCase().split(' ');
                const goalWords = goal.description.toLowerCase().split(' ');
                
                return goalWords.some(word => 
                    actionWords.includes(word) && word.length > 3
                );
            }

            actionMatchesEmotionalState(actionText, emotionalState) {
                const aggressiveActions = ['attacks', 'threatens', 'confronts', 'challenges'];
                const peacefulActions = ['approaches', 'negotiates', 'helps', 'supports'];
                const actionText_lower = actionText.toLowerCase();

                switch (emotionalState) {
                    case 'angry':
                    case 'furious':
                        return aggressiveActions.some(action => actionText_lower.includes(action));
                    case 'happy':
                    case 'pleased':
                        return peacefulActions.some(action => actionText_lower.includes(action));
                    case 'fearful':
                        return actionText_lower.includes('flee') || actionText_lower.includes('hide');
                    default:
                        return true; // Neutral emotions don't strongly influence actions
                }
            }

            getArchetypeActionModifier(archetype, actionText) {
                const actionText_lower = actionText.toLowerCase();

                switch (archetype) {
                    case 'antagonist':
                        if (actionText_lower.includes('attack') || actionText_lower.includes('threaten')) {
                            return 0.2;
                        }
                        if (actionText_lower.includes('help') || actionText_lower.includes('support')) {
                            return -0.2;
                        }
                        break;
                    case 'ally':
                        if (actionText_lower.includes('help') || actionText_lower.includes('support')) {
                            return 0.2;
                        }
                        if (actionText_lower.includes('attack') || actionText_lower.includes('betray')) {
                            return -0.3;
                        }
                        break;
                    case 'neutral':
                        return 0; // No strong preferences
                    case 'mentor':
                        if (actionText_lower.includes('teach') || actionText_lower.includes('guide')) {
                            return 0.15;
                        }
                        break;
                }

                return 0;
            }

            calculateSimilarityToRecentEvents(filledTemplate, context) {
                if (context.recentEvents.length === 0) return 0;

                const templateWords = filledTemplate.text.toLowerCase().split(' ');
                let totalSimilarity = 0;

                context.recentEvents.forEach(event => {
                    const eventWords = event.text.toLowerCase().split(' ');
                    const commonWords = templateWords.filter(word => 
                        eventWords.includes(word) && word.length > 3
                    );
                    const similarity = commonWords.length / Math.max(templateWords.length, eventWords.length);
                    totalSimilarity += similarity;
                });

                return totalSimilarity / context.recentEvents.length;
            }

            calculateWorldStateModifier(filledTemplate, context) {
                let modifier = 0;

                // Weather and environmental factors
                if (context.worldState.weatherPattern === 'stormy' && 
                    filledTemplate.text.toLowerCase().includes('outdoor')) {
                    modifier -= 0.1;
                }

                // Political climate
                if (context.worldState.politicalClimate === 'unstable' && 
                    filledTemplate.tags.includes('political')) {
                    modifier += 0.15;
                }

                // Time context
                if (context.timeContext === 'night' && 
                    filledTemplate.tags.includes('stealth')) {
                    modifier += 0.1;
                }

                return modifier;
            }

            predictConsequences(filledTemplate, context) {
                const consequences = [];

                // Predict based on action type
                if (filledTemplate.text.toLowerCase().includes('attack')) {
                    consequences.push({
                        type: 'combat_outcome',
                        description: 'Combat resolution will affect party resources and reputation',
                        likelihood: 0.9
                    });
                }

                if (filledTemplate.text.toLowerCase().includes('reveal')) {
                    consequences.push({
                        type: 'information_spread',
                        description: 'Secret information becomes known to other parties',
                        likelihood: 0.8
                    });
                }

                // Predict based on involved NPCs
                filledTemplate.involvedNPCs.forEach(npcId => {
                    const npc = context.activeNPCs.find(n => n.id === npcId);
                    if (npc) {
                        consequences.push(...this.predictNPCConsequences(npc, filledTemplate));
                    }
                });

                // Predict based on affected plot threads
                filledTemplate.affectedPlotThreads.forEach(threadId => {
                    const thread = context.currentPlotThreads.find(t => t.id === threadId);
                    if (thread) {
                        consequences.push({
                            type: 'plot_advancement',
                            description: `Progress on "${thread.title}"`,
                            likelihood: 0.7
                        });
                    }
                });

                return consequences;
            }

            predictNPCConsequences(npc, filledTemplate) {
                const consequences = [];

                // Relationship consequences
                if (filledTemplate.text.toLowerCase().includes(npc.name.toLowerCase())) {
                    consequences.push({
                        type: 'relationship_change',
                        description: `${npc.name}'s relationship with the party may change`,
                        likelihood: 0.6
                    });
                }

                // Goal consequences
                npc.currentGoals.forEach(goal => {
                    if (this.actionAffectsGoal(filledTemplate.text, goal)) {
                        consequences.push({
                            type: 'goal_impact',
                            description: `Impact on ${npc.name}'s goal: ${goal.description}`,
                            likelihood: 0.5
                        });
                    }
                });

                return consequences;
            }

            actionAffectsGoal(actionText, goal) {
                const actionWords = actionText.toLowerCase().split(' ');
                const goalWords = goal.description.toLowerCase().split(' ');
                
                return goalWords.some(word => 
                    actionWords.includes(word) && word.length > 3
                );
            }

            ensureBranchVariety(branches, context) {
                // Ensure we have variety in branch types
                const typeCount = {};
                branches.forEach(branch => {
                    typeCount[branch.type] = (typeCount[branch.type] || 0) + 1;
                });

                // If all branches are the same type, modify some
                if (Object.keys(typeCount).length === 1 && branches.length > 1) {
                    const alternativeTypes = ['combat', 'social', 'exploration', 'mystery'];
                    const currentType = branches[0].type;
                    const alternatives = alternativeTypes.filter(type => type !== currentType);

                    for (let i = 1; i < branches.length && i < alternatives.length + 1; i++) {
                        branches[i].type = alternatives[(i - 1) % alternatives.length];
                        // Adjust probability based on new type
                        branches[i].probability *= 0.8; // Slight penalty for forced variety
                    }
                }
            }

            // Helper methods for extracting patterns and requirements
            extractPattern(text) {
                // Extract a simplified pattern from text for similarity comparison
                const words = text.toLowerCase().split(' ');
                const significantWords = words.filter(word => 
                    word.length > 3 && !['the', 'and', 'with', 'that', 'this'].includes(word)
                );
                return significantWords.slice(0, 5).join(' ');
            }

            patternsAreSimilar(pattern1, pattern2) {
                const words1 = pattern1.split(' ');
                const words2 = pattern2.split(' ');
                const commonWords = words1.filter(word => words2.includes(word));
                return commonWords.length >= 2;
            }

            extractNPCRequirements(pattern) {
                const npcPlaceholders = pattern.match(/\{npc[^}]*\}/g) || [];
                return npcPlaceholders.map(placeholder => {
                    if (placeholder.includes('threat')) return 'threat';
                    if (placeholder.includes('ally')) return 'ally';
                    return 'any';
                });
            }

            npcMeetsRequirement(npc, requirement) {
                switch (requirement) {
                    case 'threat':
                        return npc.archetype === 'antagonist' || npc.archetype === 'rival';
                    case 'ally':
                        return npc.archetype === 'ally' || npc.archetype === 'mentor';
                    case 'any':
                    default:
                        return true;
                }
            }

            consequenceAffectsThread(consequence, thread) {
                const consequenceWords = consequence.toLowerCase().split(' ');
                const threadWords = thread.title.toLowerCase().split(' ');
                return consequenceWords.some(word => threadWords.includes(word));
            }

            getActiveNPCs(parentNode) {
                // Get NPCs that are currently relevant to the story
                const allNPCs = Array.from(this.narrativeState.npcs.values());
                return allNPCs.filter(npc => {
                    // Include NPCs mentioned in recent events
                    const recentlyMentioned = this.narrativeState.storyHistory
                        .slice(-5)
                        .some(event => event.involvedNPCs && event.involvedNPCs.includes(npc.id));
                    
                    // Include NPCs with active goals
                    const hasActiveGoals = npc.currentGoals && npc.currentGoals.some(goal => goal.status === 'active');
                    
                    // Include NPCs in the current location
                    const inCurrentLocation = parentNode && parentNode.metadata && parentNode.metadata.location && 
                                            npc.currentLocation === parentNode.metadata.location;
                    
                    return recentlyMentioned || hasActiveGoals || inCurrentLocation;
                });
            }

            getActivePlotThreads() {
                return Array.from(this.narrativeState.plotThreads.values())
                    .filter(thread => thread.status === 'active' || thread.status === 'dormant');
            }

            getRecentEvents(count) {
                return this.narrativeState.storyHistory.slice(-count) || [];
            }

            getAvailableLocations() {
                // Return available locations from world state - handle both Map and Object
                const locations = this.narrativeState.worldState.locations;
                if (!locations) return [];
                
                if (locations instanceof Map) {
                    return Array.from(locations.values());
                } else if (typeof locations === 'object') {
                    return Object.values(locations);
                } else {
                    return [];
                }
            }

            // Helper method to ensure Maps are properly initialized
            ensureWorldStateIntegrity() {
                if (!this.narrativeState.worldState.locations || typeof this.narrativeState.worldState.locations !== 'object') {
                    this.narrativeState.worldState.locations = new Map();
                }
                if (!this.narrativeState.worldState.factions || typeof this.narrativeState.worldState.factions !== 'object') {
                    this.narrativeState.worldState.factions = new Map();
                }
                if (!this.narrativeState.worldState.resources || typeof this.narrativeState.worldState.resources !== 'object') {
                    this.narrativeState.worldState.resources = new Map();
                }
                
                // Convert plain objects back to Maps if needed (from localStorage)
                if (this.narrativeState.worldState.locations && !(this.narrativeState.worldState.locations instanceof Map)) {
                    const locationsObj = this.narrativeState.worldState.locations;
                    this.narrativeState.worldState.locations = new Map(Object.entries(locationsObj));
                }
                if (this.narrativeState.worldState.factions && !(this.narrativeState.worldState.factions instanceof Map)) {
                    const factionsObj = this.narrativeState.worldState.factions;
                    this.narrativeState.worldState.factions = new Map(Object.entries(factionsObj));
                }
                if (this.narrativeState.worldState.resources && !(this.narrativeState.worldState.resources instanceof Map)) {
                    const resourcesObj = this.narrativeState.worldState.resources;
                    this.narrativeState.worldState.resources = new Map(Object.entries(resourcesObj));
                }
            }

            extractLocation(text) {
                if (!text) return 'unknown';
                const locations = ['tavern', 'forest', 'castle', 'city', 'village', 'dungeon', 'mountain', 'sea'];
                const textLower = text.toLowerCase();
                return locations.find(loc => textLower.includes(loc)) || 'unknown';
            }

            determineEventType(text) {
                if (!text) return 'general_event';
                const textLower = text.toLowerCase();
                
                if (textLower.includes('fight') || textLower.includes('battle') || textLower.includes('attack')) {
                    if (textLower.includes('win') || textLower.includes('defeat') || textLower.includes('victory')) {
                        return 'combat_victory';
                    }
                    return 'combat_event';
                }
                
                if (textLower.includes('reveal') || textLower.includes('tell') || textLower.includes('confess')) {
                    return 'secret_revealed';
                }
                
                if (textLower.includes('die') || textLower.includes('kill') || textLower.includes('death')) {
                    return 'npc_death';
                }
                
                if (textLower.includes('alliance') || textLower.includes('ally') || textLower.includes('join forces')) {
                    return 'alliance_formed';
                }
                
                if (textLower.includes('treasure') || textLower.includes('gold') || textLower.includes('artifact')) {
                    return 'treasure_found';
                }
                
                return 'general_event';
            }
        }

        // ==================== CAUSALITY ENGINE ====================

        class CausalityEngine {
            constructor() {
                this.causalRules = this.initializeCausalRules();
                this.consequenceHistory = new Map();
            }

            initializeCausalRules() {
                return [
                    {
                        trigger: 'combat_victory',
                        consequences: [
                            { type: 'reputation_increase', probability: 0.8, delay: 'immediate' },
                            { type: 'enemy_retaliation', probability: 0.6, delay: 'delayed' },
                            { type: 'witness_report', probability: 0.7, delay: 'short' }
                        ]
                    },
                    {
                        trigger: 'secret_revealed',
                        consequences: [
                            { type: 'trust_change', probability: 0.9, delay: 'immediate' },
                            { type: 'information_spread', probability: 0.8, delay: 'short' },
                            { type: 'blackmail_opportunity', probability: 0.4, delay: 'delayed' }
                        ]
                    },
                    {
                        trigger: 'npc_death',
                        consequences: [
                            { type: 'faction_reaction', probability: 1.0, delay: 'short' },
                            { type: 'power_vacuum', probability: 0.7, delay: 'delayed' },
                            { type: 'inheritance_dispute', probability: 0.5, delay: 'delayed' }
                        ]
                    },
                    {
                        trigger: 'alliance_formed',
                        consequences: [
                            { type: 'resource_sharing', probability: 0.8, delay: 'immediate' },
                            { type: 'enemy_response', probability: 0.6, delay: 'short' },
                            { type: 'political_shift', probability: 0.5, delay: 'delayed' }
                        ]
                    },
                    {
                        trigger: 'treasure_found',
                        consequences: [
                            { type: 'greed_motivation', probability: 0.7, delay: 'immediate' },
                            { type: 'theft_attempt', probability: 0.5, delay: 'short' },
                            { type: 'curse_activation', probability: 0.3, delay: 'random' }
                        ]
                    }
                ];
            }

            analyzeEvent(event, narrativeState) {
                const eventType = this.categorizeEvent(event);
                const applicableRules = this.causalRules.filter(rule => 
                    this.eventMatchesRule(event, rule, eventType)
                );

                const predictions = [];
                applicableRules.forEach(rule => {
                    rule.consequences.forEach(consequence => {
                        if (Math.random() < consequence.probability) {
                            predictions.push({
                                ...consequence,
                                sourceEvent: event.id,
                                triggerTime: this.calculateTriggerTime(consequence.delay),
                                details: this.generateConsequenceDetails(consequence, event, narrativeState)
                            });
                        }
                    });
                });

                return predictions;
            }

            categorizeEvent(event) {
                const text = event.text.toLowerCase();
                
                if (text.includes('fight') || text.includes('battle') || text.includes('attack')) {
                    if (text.includes('win') || text.includes('defeat') || text.includes('victory')) {
                        return 'combat_victory';
                    }
                    return 'combat_event';
                }
                
                if (text.includes('reveal') || text.includes('tell') || text.includes('confess')) {
                    return 'secret_revealed';
                }
                
                if (text.includes('die') || text.includes('kill') || text.includes('death')) {
                    return 'npc_death';
                }
                
                if (text.includes('alliance') || text.includes('ally') || text.includes('join forces')) {
                    return 'alliance_formed';
                }
                
                if (text.includes('treasure') || text.includes('gold') || text.includes('artifact')) {
                    return 'treasure_found';
                }
                
                return 'general_event';
            }

            eventMatchesRule(event, rule, eventType) {
                if (rule.trigger === eventType) return true;
                
                // Check for partial matches
                const triggerWords = rule.trigger.split('_');
                const eventWords = event.text.toLowerCase().split(' ');
                
                return triggerWords.some(word => 
                    eventWords.some(eventWord => eventWord.includes(word))
                );
            }

            calculateTriggerTime(delay) {
                const now = Date.now();
                switch (delay) {
                    case 'immediate':
                        return now;
                    case 'short':
                        return now + (Math.random() * 30 * 60 * 1000); // 0-30 minutes
                    case 'delayed':
                        return now + (Math.random() * 24 * 60 * 60 * 1000); // 0-24 hours
                    case 'random':
                        return now + (Math.random() * 7 * 24 * 60 * 60 * 1000); // 0-7 days
                    default:
                        return now + (Math.random() * 60 * 60 * 1000); // 0-60 minutes
                }
            }

            generateConsequenceDetails(consequence, sourceEvent, narrativeState) {
                switch (consequence.type) {
                    case 'reputation_increase':
                        return {
                            amount: Math.floor(Math.random() * 3) + 1,
                            faction: this.determineAffectedFaction(sourceEvent, narrativeState),
                            reason: `Victory in ${sourceEvent.text}`
                        };
                    
                    case 'enemy_retaliation':
                        return {
                            intensity: Math.random() > 0.5 ? 'escalated' : 'proportional',
                            method: this.selectRetaliationMethod(sourceEvent, narrativeState),
                            timeline: 'within days'
                        };
                    
                    case 'trust_change':
                        const involvedNPCs = sourceEvent.involvedNPCs || [];
                        return {
                            npcs: involvedNPCs,
                            direction: this.determineTrustDirection(sourceEvent),
                            magnitude: Math.floor(Math.random() * 3) + 1
                        };
                    
                    case 'information_spread':
                        return {
                            speed: Math.random() > 0.3 ? 'fast' : 'slow',
                            accuracy: Math.random() > 0.4 ? 'accurate' : 'distorted',
                            reach: this.determineInformationReach(sourceEvent, narrativeState)
                        };
                    
                    default:
                        return {
                            description: `Consequence of ${sourceEvent.text}`,
                            severity: Math.random() > 0.5 ? 'minor' : 'moderate'
                        };
                }
            }

            determineAffectedFaction(event, narrativeState) {
                // Find factions that would care about this event
                const factions = Array.from(narrativeState.worldState.factions.values());
                return factions.find(faction => 
                    faction.interests.some(interest => 
                        event.text.toLowerCase().includes(interest.toLowerCase())
                    )
                ) || { name: 'Local Community', interests: ['peace', 'order'] };
            }

            selectRetaliationMethod(event, narrativeState) {
                const methods = ['direct_confrontation', 'sabotage', 'political_pressure', 'economic_warfare', 'information_warfare'];
                
                // Choose method based on event severity and available resources
                if (event.type === 'combat' && event.text.includes('public')) {
                    return 'political_pressure';
                } else if (event.involvedNPCs.length > 0) {
                    return 'direct_confrontation';
                } else {
                    return methods[Math.floor(Math.random() * methods.length)];
                }
            }

            determineTrustDirection(event) {
                if (event.text.toLowerCase().includes('betray') || event.text.toLowerCase().includes('lie')) {
                    return 'decrease';
                } else if (event.text.toLowerCase().includes('help') || event.text.toLowerCase().includes('save')) {
                    return 'increase';
                } else {
                    return Math.random() > 0.5 ? 'increase' : 'decrease';
                }
            }

            determineInformationReach(event, narrativeState) {
                const baseReach = ['immediate_witnesses', 'local_area'];
                
                if (event.text.includes('public') || event.text.includes('crowd')) {
                    baseReach.push('regional_network');
                }
                
                if (event.involvedNPCs.some(npcId => {
                    const npc = narrativeState.npcs.get(npcId);
                    return npc && npc.traits.includes('well-connected');
                })) {
                    baseReach.push('political_circles');
                }
                
                return baseReach;
            }

            processPendingConsequences(narrativeState) {
                const now = Date.now();
                const triggeredConsequences = [];
                
                this.consequenceHistory.forEach((consequences, eventId) => {
                    consequences.forEach((consequence, index) => {
                        if (consequence.triggerTime <= now && !consequence.triggered) {
                            consequence.triggered = true;
                            triggeredConsequences.push(consequence);
                        }
                    });
                });
                
                return triggeredConsequences;
            }

            addConsequence(eventId, consequence) {
                if (!this.consequenceHistory.has(eventId)) {
                    this.consequenceHistory.set(eventId, []);
                }
                this.consequenceHistory.get(eventId).push(consequence);
            }
        }

        // ==================== CONTEXT ANALYZER ====================

        class ContextAnalyzer {
            constructor() {
                this.emotionalKeywords = this.initializeEmotionalKeywords();
                this.tensionIndicators = this.initializeTensionIndicators();
                this.pacingMarkers = this.initializePacingMarkers();
            }

            initializeEmotionalKeywords() {
                return {
                    joy: ['celebrate', 'victory', 'success', 'triumph', 'delight', 'elated'],
                    fear: ['terrified', 'afraid', 'horror', 'dread', 'panic', 'nightmare'],
                    anger: ['furious', 'rage', 'wrath', 'anger', 'hostile', 'violence'],
                    sadness: ['grief', 'sorrow', 'despair', 'melancholy', 'tragic', 'loss'],
                    surprise: ['shocked', 'amazed', 'stunned', 'unexpected', 'sudden', 'revelation'],
                    disgust: ['revolting', 'vile', 'abhorrent', 'repulsive', 'loathe'],
                    trust: ['loyal', 'faithful', 'reliable', 'honor', 'bond', 'alliance'],
                    anticipation: ['eager', 'excited', 'hopeful', 'expect', 'await', 'anticipate']
                };
            }

            initializeTensionIndicators() {
                return {
                    high: ['crisis', 'urgent', 'desperate', 'critical', 'emergency', 'life-or-death'],
                    medium: ['concern', 'worry', 'problem', 'issue', 'challenge', 'difficulty'],
                    low: ['peaceful', 'calm', 'serene', 'gentle', 'relaxed', 'tranquil']
                };
            }

            initializePacingMarkers() {
                return {
                    fast: ['quickly', 'rapidly', 'suddenly', 'immediately', 'rushed', 'hurried'],
                    slow: ['slowly', 'gradually', 'leisurely', 'methodically', 'carefully', 'patiently'],
                    building: ['growing', 'increasing', 'mounting', 'developing', 'escalating'],
                    climactic: ['peak', 'climax', 'culmination', 'finale', 'decisive', 'ultimate']
                };
            }

            analyzeEmotionalTone(text) {
                const words = text.toLowerCase().split(/\W+/);
                const emotionScores = {};
                
                Object.keys(this.emotionalKeywords).forEach(emotion => {
                    emotionScores[emotion] = 0;
                    this.emotionalKeywords[emotion].forEach(keyword => {
                        words.forEach(word => {
                            if (word.includes(keyword) || keyword.includes(word)) {
                                emotionScores[emotion]++;
                            }
                        });
                    });
                });
                
                // Find dominant emotion
                const dominantEmotion = Object.keys(emotionScores).reduce((a, b) =>
                    emotionScores[a] > emotionScores[b] ? a : b
                );
                
                return {
                    dominant: dominantEmotion,
                    scores: emotionScores,
                    intensity: Math.max(...Object.values(emotionScores)) / words.length
                };
            }

            analyzeTensionLevel(text, storyHistory) {
                const words = text.toLowerCase().split(/\W+/);
                let tensionScore = 0;
                
                // Analyze current text
                Object.keys(this.tensionIndicators).forEach(level => {
                    const multiplier = level === 'high' ? 3 : level === 'medium' ? 1 : -1;
                    this.tensionIndicators[level].forEach(indicator => {
                        words.forEach(word => {
                            if (word.includes(indicator) || indicator.includes(word)) {
                                tensionScore += multiplier;
                            }
                        });
                    });
                });
                
                // Analyze recent history for tension build-up
                const recentEvents = storyHistory.slice(-3);
                recentEvents.forEach(event => {
                    const eventTension = this.analyzeTensionLevel(event.event.text, []);
                    tensionScore += eventTension.score * 0.5; // Weighted influence
                });
                
                return {
                    score: tensionScore,
                    level: tensionScore > 5 ? 'high' : tensionScore > 0 ? 'medium' : 'low',
                    trend: this.calculateTensionTrend(storyHistory)
                };
            }

            calculateTensionTrend(storyHistory) {
                if (storyHistory.length < 3) return 'stable';
                
                const recent = storyHistory.slice(-3);
                const tensionScores = recent.map(event => 
                    this.analyzeTensionLevel(event.event.text, []).score
                );
                
                const avgEarly = (tensionScores[0] + tensionScores[1]) / 2;
                const latest = tensionScores[2];
                
                if (latest > avgEarly + 2) return 'rising';
                if (latest < avgEarly - 2) return 'falling';
                return 'stable';
            }

            analyzePacing(text, timeContext) {
                const words = text.toLowerCase().split(/\W+/);
                const pacingScores = {};
                
                Object.keys(this.pacingMarkers).forEach(pace => {
                    pacingScores[pace] = 0;
                    this.pacingMarkers[pace].forEach(marker => {
                        words.forEach(word => {
                            if (word.includes(marker) || marker.includes(word)) {
                                pacingScores[pace]++;
                            }
                        });
                    });
                });
                
                // Consider sentence structure
                const sentenceCount = text.split(/[.!?]+/).length;
                const avgSentenceLength = words.length / sentenceCount;
                
                if (avgSentenceLength < 8) {
                    pacingScores.fast += 2; // Short sentences suggest fast pacing
                } else if (avgSentenceLength > 15) {
                    pacingScores.slow += 2; // Long sentences suggest slow pacing
                }
                
                const dominantPacing = Object.keys(pacingScores).reduce((a, b) =>
                    pacingScores[a] > pacingScores[b] ? a : b
                );
                
                return {
                    dominant: dominantPacing,
                    scores: pacingScores,
                    avgSentenceLength: avgSentenceLength,
                    recommendation: this.recommendPacingAdjustment(dominantPacing, timeContext)
                };
            }

            recommendPacingAdjustment(currentPacing, timeContext) {
                if (currentPacing === 'fast' && timeContext.consecutiveFastScenes > 2) {
                    return 'Consider slowing down for character development';
                } else if (currentPacing === 'slow' && timeContext.consecutiveSlowScenes > 2) {
                    return 'Consider adding action or urgency';
                } else if (currentPacing === 'climactic' && timeContext.currentAct < 3) {
                    return 'Save climactic moments for later acts';
                } else {
                    return 'Pacing seems appropriate';
                }
            }

            extractThemes(text, narrativeHistory) {
                const themeKeywords = {
                    heroism: ['hero', 'brave', 'courage', 'sacrifice', 'noble', 'valor'],
                    betrayal: ['betray', 'backstab', 'deceive', 'treachery', 'double-cross'],
                    redemption: ['redeem', 'atone', 'forgive', 'second chance', 'reform'],
                    power: ['control', 'dominance', 'authority', 'rule', 'command', 'influence'],
                    love: ['love', 'romance', 'affection', 'devotion', 'passion', 'heart'],
                    loss: ['death', 'grief', 'mourn', 'farewell', 'goodbye', 'end'],
                    discovery: ['find', 'discover', 'reveal', 'uncover', 'learn', 'knowledge'],
                    justice: ['justice', 'fair', 'right', 'wrong', 'law', 'punishment']
                };
                
                const words = text.toLowerCase().split(/\W+/);
                const themeScores = {};
                
                Object.keys(themeKeywords).forEach(theme => {
                    themeScores[theme] = 0;
                    themeKeywords[theme].forEach(keyword => {
                        words.forEach(word => {
                            if (word.includes(keyword) || keyword.includes(word)) {
                                themeScores[theme]++;
                            }
                        });
                    });
                });
                
                // Boost themes that have appeared in narrative history
                if (narrativeHistory.length > 0) {
                    const historicalThemes = this.extractHistoricalThemes(narrativeHistory);
                    Object.keys(themeScores).forEach(theme => {
                        if (historicalThemes.includes(theme)) {
                            themeScores[theme] *= 1.5; // Boost recurring themes
                        }
                    });
                }
                
                return Object.keys(themeScores)
                    .filter(theme => themeScores[theme] > 0)
                    .sort((a, b) => themeScores[b] - themeScores[a])
                    .slice(0, 3); // Return top 3 themes
            }

            extractHistoricalThemes(narrativeHistory) {
                const allThemes = [];
                narrativeHistory.forEach(event => {
                    const eventThemes = this.extractThemes(event.event.text, []);
                    allThemes.push(...eventThemes);
                });
                
                // Count theme frequency
                const themeCount = {};
                allThemes.forEach(theme => {
                    themeCount[theme] = (themeCount[theme] || 0) + 1;
                });
                
                // Return themes that appear more than once
                return Object.keys(themeCount).filter(theme => themeCount[theme] > 1);
            }

            analyzeCharacterArcs(text, involvedNPCs, narrativeState) {
                const arcAnalysis = {};
                
                involvedNPCs.forEach(npcId => {
                    const npc = narrativeState.npcs.get(npcId);
                    if (!npc) return;
                    
                    arcAnalysis[npcId] = {
                        name: npc.name,
                        currentStage: this.determineArcStage(npc, narrativeState),
                        development: this.analyzeCharacterDevelopment(npc, text),
                        nextSuggestion: this.suggestNextArcBeat(npc, narrativeState)
                    };
                });
                
                return arcAnalysis;
            }

            determineArcStage(npc, narrativeState) {
                const history = npc.history || [];
                const goalProgress = npc.currentGoals.reduce((sum, goal) => sum + goal.progress, 0) / npc.currentGoals.length;
                
                if (history.length < 3) return 'introduction';
                if (goalProgress < 30) return 'inciting_incident';
                if (goalProgress < 70) return 'rising_action';
                if (goalProgress < 90) return 'climax';
                return 'resolution';
            }

            analyzeCharacterDevelopment(npc, currentEventText) {
                const developmentIndicators = {
                    growth: ['learn', 'realize', 'understand', 'change', 'evolve'],
                    setback: ['fail', 'mistake', 'wrong', 'regret', 'loss'],
                    revelation: ['discover', 'reveal', 'truth', 'secret', 'hidden'],
                    relationship: ['trust', 'betray', 'love', 'hate', 'friend', 'enemy']
                };
                
                const words = currentEventText.toLowerCase().split(/\W+/);
                const developments = [];
                
                Object.keys(developmentIndicators).forEach(type => {
                    developmentIndicators[type].forEach(indicator => {
                        if (words.some(word => word.includes(indicator))) {
                            developments.push(type);
                        }
                    });
                });
                
                return developments;
            }

            suggestNextArcBeat(npc, narrativeState) {
                const currentStage = this.determineArcStage(npc, narrativeState);
                const archetype = npc.archetype;
                
                const suggestions = {
                    introduction: {
                        ally: 'Establish their helpful nature and connection to the party',
                        antagonist: 'Reveal their opposition and initial threat',
                        neutral: 'Show their motivations and potential for either side'
                    },
                    inciting_incident: {
                        ally: 'Present a challenge that tests their loyalty',
                        antagonist: 'Escalate their threat or reveal deeper motives',
                        neutral: 'Force them to choose a side'
                    },
                    rising_action: {
                        ally: 'Develop their relationship with party members',
                        antagonist: 'Increase pressure and stakes',
                        neutral: 'Reveal hidden depths or past connections'
                    },
                    climax: {
                        ally: 'Moment of ultimate sacrifice or support',
                        antagonist: 'Final confrontation or revelation',
                        neutral: 'Decisive action that reveals true nature'
                    },
                    resolution: {
                        ally: 'Reflect on growth and future relationship',
                        antagonist: 'Face consequences or unexpected redemption',
                        neutral: 'Establish new role in the world'
                    }
                };
                
                return suggestions[currentStage]?.[archetype] || 'Continue developing this character\'s story';
            }
        }

        // ==================== CANVAS LAYOUT ENGINE ====================

        class CanvasLayoutEngine {
            constructor() {
                this.layoutAlgorithms = {
                    hierarchical: this.hierarchicalLayout.bind(this),
                    force: this.forceDirectedLayout.bind(this),
                    radial: this.radialLayout.bind(this),
                    timeline: this.timelineLayout.bind(this)
                };
                this.currentAlgorithm = 'hierarchical';
            }

            calculateLayout(rootNode, canvasWidth, canvasHeight, algorithm = null) {
                const layoutMethod = this.layoutAlgorithms[algorithm || this.currentAlgorithm];
                if (!layoutMethod) {
                    console.warn(`Unknown layout algorithm: ${algorithm}. Using hierarchical.`);
                    return this.hierarchicalLayout(rootNode, canvasWidth, canvasHeight);
                }
                
                return layoutMethod(rootNode, canvasWidth, canvasHeight);
            }

            hierarchicalLayout(rootNode, canvasWidth, canvasHeight) {
                const nodePositions = new Map();
                const levelNodes = new Map(); // Track nodes at each level
                
                // First pass: assign levels and collect nodes per level
                this.assignLevels(rootNode, 0, levelNodes);
                
                // Calculate spacing
                const maxLevel = Math.max(...levelNodes.keys());
                const levelHeight = canvasHeight / (maxLevel + 2); // +2 for padding
                const padding = 50;
                
                // Position nodes level by level
                levelNodes.forEach((nodes, level) => {
                    const y = padding + level * levelHeight;
                    const levelWidth = canvasWidth - 2 * padding;
                    const nodeSpacing = levelWidth / (nodes.length + 1);
                    
                    nodes.forEach((node, index) => {
                        const x = padding + (index + 1) * nodeSpacing;
                        nodePositions.set(node.id, { x, y });
                        node.position = { x, y };
                    });
                });
                
                return nodePositions;
            }

            assignLevels(node, level, levelNodes) {
                if (!levelNodes.has(level)) {
                    levelNodes.set(level, []);
                }
                levelNodes.get(level).push(node);
                
                node.children.forEach(child => {
                    this.assignLevels(child, level + 1, levelNodes);
                });
            }

            forceDirectedLayout(rootNode, canvasWidth, canvasHeight) {
                const nodes = this.collectAllNodes(rootNode);
                const nodePositions = new Map();
                
                // Initialize random positions
                nodes.forEach(node => {
                    const x = Math.random() * (canvasWidth - 200) + 100;
                    const y = Math.random() * (canvasHeight - 200) + 100;
                    nodePositions.set(node.id, { x, y, vx: 0, vy: 0 });
                });
                
                // Force simulation parameters
                const iterations = 150;
                const repulsionForce = 5000;
                const attractionForce = 0.01;
                const damping = 0.9;
                
                // Run simulation
                for (let i = 0; i < iterations; i++) {
                    const forces = new Map();
                    
                    // Initialize forces
                    nodes.forEach(node => {
                        forces.set(node.id, { fx: 0, fy: 0 });
                    });
                    
                    // Repulsion forces (all nodes repel each other)
                    for (let j = 0; j < nodes.length; j++) {
                        for (let k = j + 1; k < nodes.length; k++) {
                            const node1 = nodes[j];
                            const node2 = nodes[k];
                            const pos1 = nodePositions.get(node1.id);
                            const pos2 = nodePositions.get(node2.id);
                            
                            const dx = pos2.x - pos1.x;
                            const dy = pos2.y - pos1.y;
                            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                            
                            const force = repulsionForce / (distance * distance);
                            const fx = (dx / distance) * force;
                            const fy = (dy / distance) * force;
                            
                            forces.get(node1.id).fx -= fx;
                            forces.get(node1.id).fy -= fy;
                            forces.get(node2.id).fx += fx;
                            forces.get(node2.id).fy += fy;
                        }
                    }
                    
                    // Attraction forces (connected nodes attract)
                    nodes.forEach(parent => {
                        parent.children.forEach(child => {
                            const parentPos = nodePositions.get(parent.id);
                            const childPos = nodePositions.get(child.id);
                            
                            const dx = childPos.x - parentPos.x;
                            const dy = childPos.y - parentPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                            
                            const force = attractionForce * distance;
                            const fx = (dx / distance) * force;
                            const fy = (dy / distance) * force;
                            
                            forces.get(parent.id).fx += fx;
                            forces.get(parent.id).fy += fy;
                            forces.get(child.id).fx -= fx;
                            forces.get(child.id).fy -= fy;
                        });
                    });
                    
                    // Apply forces and update positions
                    nodes.forEach(node => {
                        const pos = nodePositions.get(node.id);
                        const force = forces.get(node.id);
                        
                        pos.vx = (pos.vx + force.fx) * damping;
                        pos.vy = (pos.vy + force.fy) * damping;
                        
                        pos.x += pos.vx;
                        pos.y += pos.vy;
                        
                        // Keep nodes within bounds
                        pos.x = Math.max(50, Math.min(canvasWidth - 50, pos.x));
                        pos.y = Math.max(50, Math.min(canvasHeight - 50, pos.y));
                    });
                }
                
                // Update node positions
                nodes.forEach(node => {
                    const pos = nodePositions.get(node.id);
                    node.position = { x: pos.x, y: pos.y };
                });
                
                return nodePositions;
            }

            radialLayout(rootNode, canvasWidth, canvasHeight) {
                const nodePositions = new Map();
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                
                // Position root at center
                nodePositions.set(rootNode.id, { x: centerX, y: centerY });
                rootNode.position = { x: centerX, y: centerY };
                
                // Position children in concentric circles
                this.positionRadialChildren(rootNode, centerX, centerY, 0, nodePositions);
                
                return nodePositions;
            }

            positionRadialChildren(parentNode, centerX, centerY, level, nodePositions) {
                if (parentNode.children.length === 0) return;
                
                const radius = 200 + level * 150; // Increase radius for each level
                const angleStep = (2 * Math.PI) / parentNode.children.length;
                const startAngle = level * 0.5; // Rotate each level slightly
                
                parentNode.children.forEach((child, index) => {
                    const angle = startAngle + index * angleStep;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    nodePositions.set(child.id, { x, y });
                    child.position = { x, y };
                    
                    // Recursively position grandchildren
                    this.positionRadialChildren(child, centerX, centerY, level + 1, nodePositions);
                });
            }

            timelineLayout(rootNode, canvasWidth, canvasHeight) {
                const nodes = this.collectAllNodes(rootNode);
                const nodePositions = new Map();
                
                // Sort nodes by timestamp
                nodes.sort((a, b) => a.timestamp - b.timestamp);
                
                const padding = 100;
                const usableWidth = canvasWidth - 2 * padding;
                const usableHeight = canvasHeight - 2 * padding;
                
                // Create timeline tracks to avoid overlaps
                const tracks = [];
                
                nodes.forEach(node => {
                    // Find an available track
                    let trackIndex = tracks.findIndex(track => 
                        !track.some(existingNode => this.nodesOverlap(node, existingNode))
                    );
                    
                    if (trackIndex === -1) {
                        // Create new track
                        trackIndex = tracks.length;
                        tracks.push([]);
                    }
                    
                    tracks[trackIndex].push(node);
                });
                
                // Position nodes
                const trackHeight = usableHeight / tracks.length;
                
                tracks.forEach((track, trackIndex) => {
                    const y = padding + trackIndex * trackHeight + trackHeight / 2;
                    
                    track.forEach((node, nodeIndex) => {
                        const x = padding + (nodeIndex / (track.length - 1 || 1)) * usableWidth;
                        nodePositions.set(node.id, { x, y });
                        node.position = { x, y };
                    });
                });
                
                return nodePositions;
            }

            collectAllNodes(rootNode) {
                const nodes = [rootNode];
                const traverse = (node) => {
                    node.children.forEach(child => {
                        nodes.push(child);
                        traverse(child);
                    });
                };
                traverse(rootNode);
                return nodes;
            }

            nodesOverlap(node1, node2) {
                // Simple overlap detection based on timestamp proximity
                const timeDiff = Math.abs(node1.timestamp - node2.timestamp);
                return timeDiff < 5 * 60 * 1000; // 5 minutes
            }

            optimizeLayout(nodePositions, canvasWidth, canvasHeight) {
                // Post-processing to improve layout
                const nodes = Array.from(nodePositions.keys());
                
                // Detect and resolve overlaps
                this.resolveOverlaps(nodePositions, nodes);
                
                // Center the layout
                this.centerLayout(nodePositions, canvasWidth, canvasHeight);
                
                // Ensure all nodes are visible
                this.constrainToCanvas(nodePositions, canvasWidth, canvasHeight);
                
                return nodePositions;
            }

            resolveOverlaps(nodePositions, nodes) {
                const minDistance = 100; // Minimum distance between nodes
                
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const pos1 = nodePositions.get(nodes[i]);
                        const pos2 = nodePositions.get(nodes[j]);
                        
                        const dx = pos2.x - pos1.x;
                        const dy = pos2.y - pos1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance) {
                            // Move nodes apart
                            const moveDistance = (minDistance - distance) / 2;
                            const moveX = (dx / distance) * moveDistance;
                            const moveY = (dy / distance) * moveDistance;
                            
                            pos1.x -= moveX;
                            pos1.y -= moveY;
                            pos2.x += moveX;
                            pos2.y += moveY;
                        }
                    }
                }
            }

            centerLayout(nodePositions, canvasWidth, canvasHeight) {
                const positions = Array.from(nodePositions.values());
                if (positions.length === 0) return;
                
                // Calculate current bounds
                const minX = Math.min(...positions.map(p => p.x));
                const maxX = Math.max(...positions.map(p => p.x));
                const minY = Math.min(...positions.map(p => p.y));
                const maxY = Math.max(...positions.map(p => p.y));
                
                // Calculate center offset
                const currentCenterX = (minX + maxX) / 2;
                const currentCenterY = (minY + maxY) / 2;
                const targetCenterX = canvasWidth / 2;
                const targetCenterY = canvasHeight / 2;
                
                const offsetX = targetCenterX - currentCenterX;
                const offsetY = targetCenterY - currentCenterY;
                
                // Apply offset to all positions
                positions.forEach(pos => {
                    pos.x += offsetX;
                    pos.y += offsetY;
                });
            }

            constrainToCanvas(nodePositions, canvasWidth, canvasHeight) {
                const margin = 50;
                
                nodePositions.forEach(pos => {
                    pos.x = Math.max(margin, Math.min(canvasWidth - margin, pos.x));
                    pos.y = Math.max(margin, Math.min(canvasHeight - margin, pos.y));
                });
            }
        }

        // ==================== GLOBAL APPLICATION STATE ====================

        let narrativeState;
        let storyGenerator;
        let layoutEngine;
        let selectedNode = null;
        let canvasTransform = { scale: 1, translateX: 0, translateY: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragType = null; // 'node', 'canvas'
        let dragNode = null;

        // ==================== INITIALIZATION ====================

        function initializeApplication() {
            narrativeState = new NarrativeState();
            storyGenerator = new IntelligentStoryGenerator(narrativeState);
            layoutEngine = new CanvasLayoutEngine();
            
            // Ensure data structure integrity
            ensureDataIntegrity();
            
            setupEventListeners();
            loadFromLocalStorage();
            updateUI();
            
            showNotification('Welcome to Narrative Nexus! Create your first scene to begin weaving your story.', 'info');
        }

        function ensureDataIntegrity() {
            // Ensure all Maps are properly initialized
            if (!narrativeState.npcs || !(narrativeState.npcs instanceof Map)) {
                if (narrativeState.npcs && typeof narrativeState.npcs === 'object') {
                    // Convert object to Map
                    const npcEntries = Object.entries(narrativeState.npcs);
                    narrativeState.npcs = new Map(npcEntries);
                } else {
                    narrativeState.npcs = new Map();
                }
            }
            
            if (!narrativeState.plotThreads || !(narrativeState.plotThreads instanceof Map)) {
                if (narrativeState.plotThreads && typeof narrativeState.plotThreads === 'object') {
                    // Convert object to Map
                    const threadEntries = Object.entries(narrativeState.plotThreads);
                    narrativeState.plotThreads = new Map(threadEntries);
                } else {
                    narrativeState.plotThreads = new Map();
                }
            }
            
            // Ensure worldState exists and has proper structure
            if (!narrativeState.worldState) {
                narrativeState.worldState = {
                    locations: new Map(),
                    factions: new Map(),
                    resources: new Map(),
                    timeContext: 'present',
                    weatherPattern: 'clear',
                    politicalClimate: 'stable'
                };
            }
            
            // Ensure worldState Maps are properly initialized
            ['locations', 'factions', 'resources'].forEach(key => {
                if (!narrativeState.worldState[key] || !(narrativeState.worldState[key] instanceof Map)) {
                    if (narrativeState.worldState[key] && typeof narrativeState.worldState[key] === 'object') {
                        // Convert object to Map
                        const entries = Object.entries(narrativeState.worldState[key]);
                        narrativeState.worldState[key] = new Map(entries);
                    } else {
                        narrativeState.worldState[key] = new Map();
                    }
                }
            });
            
            // Ensure other required properties exist
            if (!narrativeState.storyHistory) {
                narrativeState.storyHistory = [];
            }
            
            if (!narrativeState.narrativeContext) {
                narrativeState.narrativeContext = {
                    genre: 'fantasy',
                    tone: 'adventure',
                    themes: ['heroism', 'discovery'],
                    currentAct: 1,
                    tensionLevel: 'medium',
                    pacingState: 'building'
                };
            }
            
            if (!narrativeState.currentSession) {
                narrativeState.currentSession = {
                    startTime: Date.now(),
                    events: [],
                    decisions: [],
                    progress: 0
                };
            }
            
            if (!narrativeState.campaignName) {
                narrativeState.campaignName = 'Untitled Campaign';
            }
        }

        function setupEventListeners() {
            // Canvas interaction
            const canvas = document.getElementById('mainCanvas');
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('wheel', handleCanvasWheel);
            
            // Search functionality
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', handleSearchInput);
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') searchStory();
            });
            
            // Auto-save
            setInterval(autoSave, 30000); // Auto-save every 30 seconds
            
            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            // State change listeners
            document.addEventListener('narrativeStateChange', handleStateChange);
            
            // Window resize
            window.addEventListener('resize', handleWindowResize);
        }

        // ==================== EVENT HANDLERS ====================

        function handleCanvasMouseDown(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = (e.clientX - rect.left - canvasTransform.translateX) / canvasTransform.scale;
            const y = (e.clientY - rect.top - canvasTransform.translateY) / canvasTransform.scale;
            
            // Check if clicking on a node
            const clickedNode = findNodeAtPosition(x, y);
            
            if (clickedNode) {
                selectNode(clickedNode);
                if (e.detail === 2) { // Double-click
                    editNodeContent(clickedNode);
                } else {
                    startNodeDrag(clickedNode, e);
                }
            } else {
                deselectNode();
                startCanvasPan(e);
            }
            
            e.preventDefault();
        }

        function handleCanvasMouseMove(e) {
            if (!isDragging) return;
            
            if (dragType === 'node' && dragNode) {
                updateNodePosition(dragNode, e);
            } else if (dragType === 'canvas') {
                updateCanvasPan(e);
            }
        }

        function handleCanvasMouseUp(e) {
            if (dragType === 'node' && dragNode) {
                endNodeDrag();
            } else if (dragType === 'canvas') {
                endCanvasPan();
            }
            
            isDragging = false;
            dragType = null;
            dragNode = null;
        }

        function handleCanvasWheel(e) {
            e.preventDefault();
            
            const rect = e.currentTarget.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9;
            zoomCanvas(scaleFactor, x, y);
        }

        function handleSearchInput(e) {
            const query = e.target.value.trim();
            if (query.length > 2) {
                performSearch(query);
            } else {
                clearSearchResults();
            }
        }

        function handleKeyboardShortcuts(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        quickSave();
                        break;
                    case 'z':
                        if (e.shiftKey) {
                            e.preventDefault();
                            redo();
                        } else {
                            e.preventDefault();
                            undo();
                        }
                        break;
                    case 'f':
                        e.preventDefault();
                        document.getElementById('searchInput').focus();
                        break;
                    case 'n':
                        e.preventDefault();
                        if (selectedNode) {
                            generateSubBranches(selectedNode.id);
                        }
                        break;
                }
            }
            
            switch (e.key) {
                case 'Delete':
                    if (selectedNode && selectedNode.id !== 'root') {
                        deleteNode(selectedNode.id);
                    }
                    break;
                case 'Escape':
                    deselectNode();
                    clearSearchResults();
                    break;
                case 'F11':
                    e.preventDefault();
                    fullscreen();
                    break;
            }
        }

        function handleStateChange(e) {
            const { category, key, value } = e.detail;
            updateUI();
            
            // Auto-layout if significant changes
            if (category === 'storyTree' && narrativeState.storyTree) {
                requestAnimationFrame(() => {
                    updateLayout();
                });
            }
        }

        function handleWindowResize() {
            if (narrativeState.storyTree) {
                updateLayout();
            }
        }

        // ==================== STORY MANAGEMENT ====================

        function initializeNarrative() {
            const sceneContext = document.getElementById('sceneContext').value.trim();
            const narrativeFocus = document.getElementById('narrativeFocus').value;
            const tensionLevel = document.getElementById('tensionLevel').value;
            
            if (!sceneContext) {
                showNotification('Please provide an initial scene context.', 'error');
                return;
            }
            
            const initBtn = document.getElementById('initBtn');
            initBtn.classList.add('loading');
            initBtn.textContent = 'Weaving Narrative...';
            
            try {
                // Create root node
                const rootNode = new StoryNode({
                    id: 'root',
                    text: sceneContext,
                    type: 'root',
                    probability: 1.0,
                    depth: 0,
                    position: { x: 0, y: 0 }
                });
                
                // Update narrative context
                narrativeState.narrativeContext.tensionLevel = tensionLevel;
                narrativeState.narrativeContext.focus = narrativeFocus;
                
                // Generate initial branches
                const branches = storyGenerator.generateBranches(rootNode, 4);
                branches.forEach(branch => rootNode.addChild(branch));
                
                // Set as story tree
                narrativeState.storyTree = rootNode;
                
                // Add to history
                narrativeState.addHistoryEvent({
                    id: 'init',
                    text: `Campaign initialized: ${sceneContext}`,
                    involvedNPCs: [],
                    timestamp: Date.now()
                });
                
                // Update layout and UI
                updateLayout();
                updateUI();
                
                showNotification('Narrative successfully initialized! Your story begins...', 'success');
                
            } catch (error) {
                console.error('Error initializing narrative:', error);
                showNotification('Error initializing narrative. Please try again.', 'error');
            } finally {
                initBtn.classList.remove('loading');
                initBtn.textContent = '✨ Weave Initial Paths';
            }
        }

        function generateSubBranches(nodeId) {
            const node = findNodeById(narrativeState.storyTree, nodeId);
            if (!node) return;
            
            if (node.children.length > 0) {
                showNotification('This node already has branches. Try adding a custom event instead.', 'info');
                return;
            }
            
            try {
                const branches = storyGenerator.generateBranches(node, 3);
                branches.forEach(branch => node.addChild(branch));
                
                narrativeState.addHistoryEvent({
                    id: Date.now().toString(),
                    text: `Generated branches from: ${node.text.substring(0, 50)}...`,
                    involvedNPCs: branches.flatMap(b => b.involvedNPCs),
                    timestamp: Date.now()
                });
                
                updateLayout();
                updateUI();
                
                showNotification(`Generated ${branches.length} new story branches!`, 'success');
                
            } catch (error) {
                console.error('Error generating branches:', error);
                showNotification('Error generating branches. Please try again.', 'error');
            }
        }

        function addCustomEvent(nodeId, eventText) {
            const parentNode = findNodeById(narrativeState.storyTree, nodeId);
            if (!parentNode || !eventText.trim()) return;
            
            const customNode = new StoryNode({
                text: eventText.trim(),
                type: 'exploration', // Default type, can be analyzed
                probability: 1.0,
                depth: parentNode.depth + 1
            });
            
            // Analyze the custom event for better typing and metadata
            const context = storyGenerator.buildRichContext(parentNode);
            const eventType = storyGenerator.causality.categorizeEvent({ text: eventText });
            customNode.type = eventType.includes('combat') ? 'combat' :
                             eventType.includes('social') ? 'social' :
                             eventType.includes('mystery') ? 'mystery' : 'exploration';
            
            parentNode.addChild(customNode);
            
            // Generate follow-up branches for the custom event
            const followUps = storyGenerator.generateBranches(customNode, 2);
            followUps.forEach(branch => customNode.addChild(branch));
            
            narrativeState.addHistoryEvent({
                id: customNode.id,
                text: eventText,
                involvedNPCs: customNode.involvedNPCs,
                timestamp: Date.now()
            });
            
            updateLayout();
            updateUI();
            
            showNotification('Custom event added and follow-up branches generated!', 'success');
        }

        function deleteNode(nodeId) {
            if (nodeId === 'root') {
                showNotification('Cannot delete the root node.', 'error');
                return;
            }
            
            const parentNode = findParentNode(narrativeState.storyTree, nodeId);
            if (!parentNode) return;
            
            if (confirm('Delete this story branch and all its children?')) {
                parentNode.removeChild(nodeId);
                
                if (selectedNode && selectedNode.id === nodeId) {
                    deselectNode();
                }
                
                updateLayout();
                updateUI();
                
                showNotification('Story branch deleted.', 'info');
            }
        }

        // ==================== NPC MANAGEMENT ====================

        function addNPC() {
            const name = document.getElementById('npcName').value.trim();
            const archetype = document.getElementById('npcArchetype').value;
            const motivation = document.getElementById('npcMotivation').value.trim();
            const relationships = document.getElementById('npcRelationships').value.trim();
            const secrets = document.getElementById('npcSecrets').value.trim();
            
            if (!name) {
                showNotification('Please provide a character name.', 'error');
                return;
            }
            
            const npc = new AdvancedNPC({
                name: name,
                archetype: archetype,
                coreMotivation: motivation,
                secrets: secrets ? [{ content: secrets, importance: 'important' }] : [],
                interests: motivation ? [motivation] : [],
                currentLocation: 'scene'
            });
            
            // Parse relationships
            if (relationships) {
                relationships.split(',').forEach(rel => {
                    const trimmed = rel.trim();
                    if (trimmed) {
                        npc.addGoal(`Develop relationship: ${trimmed}`, 'medium');
                    }
                });
            }
            
            narrativeState.npcs.set(npc.id, npc);
            
            clearNPCForm();
            updateNPCList();
            updateUI();
            
            showNotification(`${name} has joined your narrative!`, 'success');
        }

        function generateRandomNPC() {
            const archetypes = ['ally', 'mentor', 'rival', 'antagonist', 'neutral', 'informant', 'merchant', 'authority'];
            const names = ['Elara', 'Gareth', 'Lydia', 'Marcus', 'Seraphina', 'Thorne', 'Vera', 'Damien', 'Isla', 'Rowan'];
            const motivations = [
                'gain political power', 'protect family', 'seek revenge', 'find lost love',
                'uncover ancient secrets', 'restore honor', 'accumulate wealth', 'serve the realm'
            ];
            
            const archetype = archetypes[Math.floor(Math.random() * archetypes.length)];
            const name = names[Math.floor(Math.random() * names.length)];
            const motivation = motivations[Math.floor(Math.random() * motivations.length)];
            
            document.getElementById('npcName').value = name;
            document.getElementById('npcArchetype').value = archetype;
            document.getElementById('npcMotivation').value = motivation;
            
            showNotification('Random character generated! Customize as needed.', 'info');
        }

        function removeNPC(npcId) {
            narrativeState.npcs.delete(npcId);
            updateNPCList();
            updateUI();
            showNotification('Character removed from narrative.', 'info');
        }

        function clearNPCForm() {
            document.getElementById('npcName').value = '';
            document.getElementById('npcMotivation').value = '';
            document.getElementById('npcRelationships').value = '';
            document.getElementById('npcSecrets').value = '';
        }

        function updateNPCList() {
            const npcList = document.getElementById('npcList');
            const npcs = Array.from(narrativeState.npcs.values());
            
            if (npcs.length === 0) {
                npcList.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No characters yet. Add some to bring your story to life!</div>';
                return;
            }
            
            npcList.innerHTML = npcs.map(npc => `
                <div class="npc-item">
                    <div class="npc-header">
                        <span class="npc-name">${npc.name}</span>
                        <button class="btn btn-small btn-danger" onclick="removeNPC('${npc.id}')">✕</button>
                    </div>
                    <div class="npc-details">
                        <div><strong>Role:</strong> ${npc.archetype}</div>
                        <div><strong>Motivation:</strong> ${npc.coreMotivation || 'Unknown'}</div>
                        <div><strong>Emotional State:</strong> ${npc.emotionalState}</div>
                        <div><strong>Active Goals:</strong> ${npc.currentGoals.filter(g => g.status === 'active').length}</div>
                    </div>
                    <div class="npc-stats">
                        <div class="stat-item">STR ${npc.stats.strength}</div>
                        <div class="stat-item">DEX ${npc.stats.dexterity}</div>
                        <div class="stat-item">INT ${npc.stats.intelligence}</div>
                    </div>
                </div>
            `).join('');
        }

        // ==================== PLOT THREAD MANAGEMENT ====================

        function addPlotThread() {
            const title = document.getElementById('threadTitle').value.trim();
            const description = document.getElementById('threadDescription').value.trim();
            const status = document.getElementById('threadStatus').value;
            
            if (!title) {
                showNotification('Please provide a thread title.', 'error');
                return;
            }
            
            const thread = {
                id: Date.now().toString(),
                title: title,
                description: description || 'No description provided.',
                status: status,
                progress: 0,
                createdAt: Date.now(),
                lastUpdated: Date.now(),
                events: [],
                type: 'general'
            };
            
            narrativeState.plotThreads.set(thread.id, thread);
            
            document.getElementById('threadTitle').value = '';
            document.getElementById('threadDescription').value = '';
            
            updatePlotThreadsList();
            updateUI();
            
            showNotification(`Plot thread "${title}" added!`, 'success');
        }

        function updatePlotThreadsList() {
            const container = document.getElementById('plotThreadsList');
            const threads = Array.from(narrativeState.plotThreads.values());
            
            if (threads.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No plot threads yet. Add some to track your story arcs!</div>';
                return;
            }
            
            container.innerHTML = threads.map(thread => `
                <div class="plot-thread">
                    <div class="thread-header">
                        <span class="thread-title">${thread.title}</span>
                        <span class="thread-status ${thread.status}">${thread.status}</span>
                    </div>
                    <div class="thread-description">${thread.description}</div>
                    <div style="margin-top: 8px; font-size: 0.8rem; color: var(--text-muted);">
                        Progress: ${thread.progress}% | Updated: ${new Date(thread.lastUpdated).toLocaleDateString()}
                    </div>
                </div>
            `).join('');
        }

        // ==================== CANVAS AND LAYOUT MANAGEMENT ====================

        function updateLayout() {
            if (!narrativeState.storyTree) return;
            
            const canvas = document.getElementById('mainCanvas');
            const rect = canvas.getBoundingClientRect();
            
            // Calculate layout
            const nodePositions = layoutEngine.calculateLayout(
                narrativeState.storyTree,
                rect.width,
                rect.height,
                layoutEngine.currentAlgorithm
            );
            
            // Render nodes
            renderNodes();
            
            // Draw connections
            renderConnections();
            
            // Update transform to show all nodes
            if (canvasTransform.scale === 1 && canvasTransform.translateX === 0 && canvasTransform.translateY === 0) {
                fitNodesToView();
            }
        }

        function renderNodes() {
            const viewport = document.getElementById('canvasViewport');
            
            // Clear existing nodes
            const existingNodes = viewport.querySelectorAll('.story-node');
            existingNodes.forEach(node => node.remove());
            
            // Render all nodes
            renderNodeRecursive(narrativeState.storyTree, viewport);
        }

        function renderNodeRecursive(node, container) {
            const nodeElement = createNodeElement(node);
            container.appendChild(nodeElement);
            
            // Render children
            node.children.forEach(child => {
                renderNodeRecursive(child, container);
            });
        }

        function createNodeElement(node) {
            const nodeEl = document.createElement('div');
            nodeEl.className = `story-node type-${node.type}`;
            nodeEl.id = `node-${node.id}`;
            nodeEl.dataset.nodeId = node.id;
            nodeEl.style.left = node.position.x + 'px';
            nodeEl.style.top = node.position.y + 'px';
            
            if (selectedNode && selectedNode.id === node.id) {
                nodeEl.classList.add('selected');
            }
            
            const probPercent = Math.round(node.probability * 100);
            const typeIcon = getTypeIcon(node.type);
            const depthBadge = node.depth === 0 ? 'ROOT' : `L${node.depth}`;
            
            nodeEl.innerHTML = `
                <div class="node-header">
                    <span class="node-type-badge">${typeIcon} ${depthBadge}</span>
                    <span class="node-probability">${probPercent}%</span>
                </div>
                <div class="node-content" contenteditable="false">${node.text}</div>
                <div class="node-metadata">
                    ${node.tags.map(tag => `<span class="metadata-tag">${tag}</span>`).join('')}
                    ${node.involvedNPCs.length > 0 ? `<span class="metadata-tag">👥 ${node.involvedNPCs.length}</span>` : ''}
                    ${node.affectedPlotThreads.length > 0 ? `<span class="metadata-tag">📖 ${node.affectedPlotThreads.length}</span>` : ''}
                </div>
                <div class="node-actions">
                    <button class="btn btn-small btn-secondary" onclick="generateSubBranches('${node.id}')">
                        🌿 Branch
                    </button>
                    <button class="btn btn-small btn-info" onclick="showAddEventModal('${node.id}')">
                        ➕ Event
                    </button>
                    <button class="btn btn-small btn-warning" onclick="rollFateFromNode('${node.id}')">
                        🎲 Fate
                    </button>
                    ${node.id !== 'root' ? `<button class="btn btn-small btn-danger" onclick="deleteNode('${node.id}')">🗑️</button>` : ''}
                </div>
            `;
            
            return nodeEl;
        }

        function getTypeIcon(type) {
            const icons = {
                root: '🌟',
                combat: '⚔️',
                social: '💬',
                exploration: '🗺️',
                mystery: '🔍'
            };
            return icons[type] || '📝';
        }

        function renderConnections() {
            const svg = document.getElementById('canvasConnections');
            svg.innerHTML = '';
            
            if (!narrativeState.storyTree) return;
            
            drawConnectionsRecursive(narrativeState.storyTree, svg);
        }

        function drawConnectionsRecursive(node, svg) {
            node.children.forEach(child => {
                const line = createConnectionLine(node, child);
                svg.appendChild(line);
                
                drawConnectionsRecursive(child, svg);
            });
        }

        function createConnectionLine(parentNode, childNode) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            const startX = parentNode.position.x + 140; // Node width/2
            const startY = parentNode.position.y + 75;  // Node height/2
            const endX = childNode.position.x + 140;
            const endY = childNode.position.y + 75;
            
            // Create a curved path
            const controlY = startY + (endY - startY) * 0.7;
            const path = `M ${startX} ${startY} Q ${startX} ${controlY} ${endX} ${endY}`;
            
            line.setAttribute('d', path);
            line.setAttribute('stroke', getConnectionColor(childNode.type));
            line.setAttribute('stroke-width', '2');
            line.setAttribute('fill', 'none');
            line.setAttribute('opacity', '0.7');
            
            // Add arrow marker
            const markerId = `arrow-${childNode.type}`;
            if (!document.getElementById(markerId)) {
                createArrowMarker(document.getElementById('canvasConnections'), markerId, getConnectionColor(childNode.type));
            }
            line.setAttribute('marker-end', `url(#${markerId})`);
            
            return line;
        }

        function getConnectionColor(nodeType) {
            const colors = {
                combat: 'var(--danger)',
                social: 'var(--success)',
                exploration: 'var(--info)',
                mystery: 'var(--warning)',
                root: 'var(--purple)'
            };
            return colors[nodeType] || 'var(--text-secondary)';
        }

        function createArrowMarker(svg, id, color) {
            const defs = svg.querySelector('defs') || svg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'defs'));
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            
            marker.setAttribute('id', id);
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0,0 0,6 9,3');
            polygon.setAttribute('fill', color);
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
        }

        // ==================== CANVAS INTERACTION ====================

        function findNodeAtPosition(x, y) {
            if (!narrativeState.storyTree) return null;
            
            const nodeWidth = 280;
            const nodeHeight = 150;
            
            return findNodeAtPositionRecursive(narrativeState.storyTree, x, y, nodeWidth, nodeHeight);
        }

        function findNodeAtPositionRecursive(node, x, y, nodeWidth, nodeHeight) {
            // Check if position is within this node
            if (x >= node.position.x && x <= node.position.x + nodeWidth &&
                y >= node.position.y && y <= node.position.y + nodeHeight) {
                return node;
            }
            
            // Check children
            for (const child of node.children) {
                const found = findNodeAtPositionRecursive(child, x, y, nodeWidth, nodeHeight);
                if (found) return found;
            }
            
            return null;
        }

        function selectNode(node) {
            // Remove previous selection
            document.querySelectorAll('.story-node.selected').forEach(el => {
                el.classList.remove('selected');
            });
            
            selectedNode = node;
            
            // Add selection to DOM element
            const nodeEl = document.getElementById(`node-${node.id}`);
            if (nodeEl) {
                nodeEl.classList.add('selected');
            }
            
            updateNodeInspector(node);
        }

        function deselectNode() {
            document.querySelectorAll('.story-node.selected').forEach(el => {
                el.classList.remove('selected');
            });
            
            selectedNode = null;
            hideNodeInspector();
        }

        function startNodeDrag(node, e) {
            isDragging = true;
            dragType = 'node';
            dragNode = node;
            
            const rect = e.currentTarget.getBoundingClientRect();
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
            
            const nodeEl = document.getElementById(`node-${node.id}`);
            if (nodeEl) {
                nodeEl.classList.add('dragging');
            }
        }

        function updateNodePosition(node, e) {
            const deltaX = (e.clientX - dragStart.x) / canvasTransform.scale;
            const deltaY = (e.clientY - dragStart.y) / canvasTransform.scale;
            
            node.position.x += deltaX;
            node.position.y += deltaY;
            
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
            
            // Update DOM element position
            const nodeEl = document.getElementById(`node-${node.id}`);
            if (nodeEl) {
                nodeEl.style.left = node.position.x + 'px';
                nodeEl.style.top = node.position.y + 'px';
            }
            
            // Update connections
            renderConnections();
        }

        function endNodeDrag() {
            if (dragNode) {
                const nodeEl = document.getElementById(`node-${dragNode.id}`);
                if (nodeEl) {
                    nodeEl.classList.remove('dragging');
                }
            }
        }

        function startCanvasPan(e) {
            isDragging = true;
            dragType = 'canvas';
            
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
        }

        function updateCanvasPan(e) {
            const deltaX = e.clientX - dragStart.x;
            const deltaY = e.clientY - dragStart.y;
            
            canvasTransform.translateX += deltaX;
            canvasTransform.translateY += deltaY;
            
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
            
            updateCanvasTransform();
        }

        function endCanvasPan() {
            // Canvas pan end logic if needed
        }

        function zoomCanvas(scaleFactor, originX, originY) {
            const newScale = Math.max(0.1, Math.min(3, canvasTransform.scale * scaleFactor));
            
            if (newScale !== canvasTransform.scale) {
                // Adjust translation to zoom towards the cursor
                const scaleChange = newScale / canvasTransform.scale;
                canvasTransform.translateX = originX - (originX - canvasTransform.translateX) * scaleChange;
                canvasTransform.translateY = originY - (originY - canvasTransform.translateY) * scaleChange;
                canvasTransform.scale = newScale;
                
                updateCanvasTransform();
            }
        }

        function updateCanvasTransform() {
            const viewport = document.getElementById('canvasViewport');
            const svg = document.getElementById('canvasConnections');
            
            const transform = `translate(${canvasTransform.translateX}px, ${canvasTransform.translateY}px) scale(${canvasTransform.scale})`;
            
            viewport.style.transform = transform;
            svg.style.transform = transform;
        }

        // ==================== CANVAS CONTROLS ====================

        function zoomIn() {
            const canvas = document.getElementById('mainCanvas');
            const rect = canvas.getBoundingClientRect();
            zoomCanvas(1.2, rect.width / 2, rect.height / 2);
        }

        function zoomOut() {
            const canvas = document.getElementById('mainCanvas');
            const rect = canvas.getBoundingClientRect();
            zoomCanvas(0.8, rect.width / 2, rect.height / 2);
        }

        function resetView() {
            canvasTransform = { scale: 1, translateX: 0, translateY: 0 };
            updateCanvasTransform();
            
            if (narrativeState.storyTree) {
                fitNodesToView();
            }
        }

        function autoLayout() {
            if (!narrativeState.storyTree) return;
            
            // Cycle through layout algorithms
            const algorithms = ['hierarchical', 'force', 'radial', 'timeline'];
            const currentIndex = algorithms.indexOf(layoutEngine.currentAlgorithm);
            const nextIndex = (currentIndex + 1) % algorithms.length;
            
            layoutEngine.currentAlgorithm = algorithms[nextIndex];
            updateLayout();
            
            showNotification(`Switched to ${algorithms[nextIndex]} layout`, 'info');
        }

        function fitNodesToView() {
            if (!narrativeState.storyTree) return;
            
            const nodes = layoutEngine.collectAllNodes(narrativeState.storyTree);
            if (nodes.length === 0) return;
            
            const canvas = document.getElementById('mainCanvas');
            const rect = canvas.getBoundingClientRect();
            
            // Calculate bounds
            const minX = Math.min(...nodes.map(n => n.position.x));
            const maxX = Math.max(...nodes.map(n => n.position.x)) + 280; // Node width
            const minY = Math.min(...nodes.map(n => n.position.y));
            const maxY = Math.max(...nodes.map(n => n.position.y)) + 150; // Node height
            
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            
            // Calculate scale to fit
            const scaleX = (rect.width - 100) / contentWidth;
            const scaleY = (rect.height - 100) / contentHeight;
            const scale = Math.min(1, Math.min(scaleX, scaleY));
            
            // Calculate center offset
            const scaledWidth = contentWidth * scale;
            const scaledHeight = contentHeight * scale;
            const offsetX = (rect.width - scaledWidth) / 2 - minX * scale;
            const offsetY = (rect.height - scaledHeight) / 2 - minY * scale;
            
            canvasTransform = {
                scale: scale,
                translateX: offsetX,
                translateY: offsetY
            };
            
            updateCanvasTransform();
        }

        function toggleMinimap() {
            showNotification('Minimap feature coming soon!', 'info');
        }

        function fullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // ==================== SEARCH AND NAVIGATION ====================

        function searchStory() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query || !narrativeState.storyTree) return;
            
            performSearch(query);
        }

        function performSearch(query) {
            const results = [];
            const queryLower = query.toLowerCase();
            
            // Search story nodes
            searchNodesRecursive(narrativeState.storyTree, queryLower, results);
            
            // Search NPCs
            narrativeState.npcs.forEach(npc => {
                if (npc.name.toLowerCase().includes(queryLower) ||
                    npc.coreMotivation.toLowerCase().includes(queryLower) ||
                    npc.secrets.some(secret => secret.content.toLowerCase().includes(queryLower))) {
                    results.push({
                        type: 'npc',
                        item: npc,
                        relevance: calculateRelevance(npc.name + ' ' + npc.coreMotivation, queryLower)
                    });
                }
            });
            
            // Search plot threads
            narrativeState.plotThreads.forEach(thread => {
                if (thread.title.toLowerCase().includes(queryLower) ||
                    thread.description.toLowerCase().includes(queryLower)) {
                    results.push({
                        type: 'thread',
                        item: thread,
                        relevance: calculateRelevance(thread.title + ' ' + thread.description, queryLower)
                    });
                }
            });
            
            displaySearchResults(results, query);
        }

        function searchNodesRecursive(node, query, results) {
            if (node.text.toLowerCase().includes(query) ||
                node.tags.some(tag => tag.toLowerCase().includes(query))) {
                results.push({
                    type: 'node',
                    item: node,
                    relevance: calculateRelevance(node.text, query)
                });
            }
            
            node.children.forEach(child => {
                searchNodesRecursive(child, query, results);
            });
        }

        function calculateRelevance(text, query) {
            const textLower = text.toLowerCase();
            const queryWords = query.split(' ');
            let relevance = 0;
            
            queryWords.forEach(word => {
                if (textLower.includes(word)) {
                    relevance += word.length / text.length;
                }
            });
            
            return relevance;
        }

        function displaySearchResults(results, query) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = `<div style="color: var(--text-muted); padding: 10px;">No results found for "${query}"</div>`;
                return;
            }
            
            // Sort by relevance
            results.sort((a, b) => b.relevance - a.relevance);
            
            container.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 10px;">Search Results (${results.length})</div>
                ${results.map(result => createSearchResultElement(result)).join('')}
            `;
        }

        function createSearchResultElement(result) {
            switch (result.type) {
                case 'node':
                    return `
                        <div class="search-result" onclick="focusNode('${result.item.id}')">
                            <div style="font-weight: 500;">${getTypeIcon(result.item.type)} Story Node</div>
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">${result.item.text.substring(0, 80)}...</div>
                        </div>
                    `;
                case 'npc':
                    return `
                        <div class="search-result">
                            <div style="font-weight: 500;">👤 ${result.item.name}</div>
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">${result.item.archetype} - ${result.item.coreMotivation}</div>
                        </div>
                    `;
                case 'thread':
                    return `
                        <div class="search-result">
                            <div style="font-weight: 500;">📖 ${result.item.title}</div>
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">${result.item.description.substring(0, 60)}...</div>
                        </div>
                    `;
                default:
                    return '';
            }
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            clearSearchResults();
        }

        function clearSearchResults() {
            document.getElementById('searchResults').innerHTML = '';
        }

        function focusNode(nodeId) {
            const node = findNodeById(narrativeState.storyTree, nodeId);
            if (!node) return;
            
            selectNode(node);
            
            // Center on the node
            const canvas = document.getElementById('mainCanvas');
            const rect = canvas.getBoundingClientRect();
            
            const targetX = rect.width / 2 - node.position.x * canvasTransform.scale;
            const targetY = rect.height / 2 - node.position.y * canvasTransform.scale;
            
            canvasTransform.translateX = targetX;
            canvasTransform.translateY = targetY;
            
            updateCanvasTransform();
            
            // Add highlight effect
            const nodeEl = document.getElementById(`node-${nodeId}`);
            if (nodeEl) {
                nodeEl.classList.add('highlighted');
                setTimeout(() => {
                    nodeEl.classList.remove('highlighted');
                }, 2000);
            }
        }

        function focusRandomNode() {
            if (!narrativeState.storyTree) return;
            
            const allNodes = layoutEngine.collectAllNodes(narrativeState.storyTree);
            if (allNodes.length === 0) return;
            
            const randomNode = allNodes[Math.floor(Math.random() * allNodes.length)];
            focusNode(randomNode.id);
        }

        // ==================== UTILITY FUNCTIONS ====================

        function findNodeById(rootNode, nodeId) {
            if (rootNode.id === nodeId) return rootNode;
            
            for (const child of rootNode.children) {
                const found = findNodeById(child, nodeId);
                if (found) return found;
            }
            
            return null;
        }

        function findParentNode(rootNode, childId) {
            for (const child of rootNode.children) {
                if (child.id === childId) return rootNode;
                
                const found = findParentNode(child, childId);
                if (found) return found;
            }
            
            return null;
        }

        function updateUI() {
            updateStats();
            updateNPCList();
            updatePlotThreadsList();
            updateTimeline();
        }

        function updateStats() {
            if (!narrativeState.storyTree) {
                document.getElementById('totalNodes').textContent = '0';
                document.getElementById('storyDepth').textContent = '0';
            } else {
                const allNodes = layoutEngine.collectAllNodes(narrativeState.storyTree);
                const maxDepth = Math.max(...allNodes.map(n => n.depth));
                
                document.getElementById('totalNodes').textContent = allNodes.length;
                document.getElementById('storyDepth').textContent = maxDepth;
            }
            
            document.getElementById('activeThreads').textContent = Array.from(narrativeState.plotThreads.values())
                .filter(t => t.status === 'active').length;
            
            document.getElementById('totalNPCs').textContent = narrativeState.npcs.size;
        }

        function updateTimeline() {
            const timeline = document.getElementById('sessionTimeline');
            const events = narrativeState.storyHistory.slice(-5).reverse(); // Show last 5 events
            
            if (events.length === 0) {
                timeline.innerHTML = '<div style="text-align: center; color: var(--text-muted);">No events yet</div>';
                return;
            }
            
            timeline.innerHTML = events.map(event => `
                <div class="timeline-item">
                    <div class="timeline-marker"></div>
                    <div class="timeline-content">
                        <div class="timeline-title">${new Date(event.timestamp).toLocaleTimeString()}</div>
                        <div class="timeline-description">${event.event.text.substring(0, 100)}...</div>
                    </div>
                </div>
            `).join('');
        }

        function updateNodeInspector(node) {
            const inspector = document.getElementById('nodeInspector');
            const content = document.getElementById('nodeInspectorContent');
            
            inspector.style.display = 'block';
            
            const involvedNPCs = node.involvedNPCs.map(npcId => {
                const npc = narrativeState.npcs.get(npcId);
                return npc ? npc.name : 'Unknown';
            }).join(', ');
            
            const affectedThreads = node.affectedPlotThreads.map(threadId => {
                const thread = narrativeState.plotThreads.get(threadId);
                return thread ? thread.title : 'Unknown';
            }).join(', ');
            
            content.innerHTML = `
                <div class="form-group">
                    <label class="form-label">Node Type</label>
                    <div>${getTypeIcon(node.type)} ${node.type}</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Probability</label>
                    <div>${Math.round(node.probability * 100)}%</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Depth</label>
                    <div>Level ${node.depth}</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Content</label>
                    <textarea class="form-textarea" rows="3" onchange="updateNodeContent('${node.id}', this.value)">${node.text}</textarea>
                </div>
                ${involvedNPCs ? `
                <div class="form-group">
                    <label class="form-label">Involved NPCs</label>
                    <div>${involvedNPCs}</div>
                </div>
                ` : ''}
                ${affectedThreads ? `
                <div class="form-group">
                    <label class="form-label">Affected Plot Threads</label>
                    <div>${affectedThreads}</div>
                </div>
                ` : ''}
                ${node.consequences.length > 0 ? `
                <div class="form-group">
                    <label class="form-label">Predicted Consequences</label>
                    <div>${node.consequences.map(c => c.description || c.type).join(', ')}</div>
                </div>
                ` : ''}
                <div class="btn-group">
                    <button class="btn btn-small btn-secondary" onclick="generateSubBranches('${node.id}')">Generate Branches</button>
                    <button class="btn btn-small btn-info" onclick="showAddEventModal('${node.id}')">Add Event</button>
                </div>
            `;
        }

        function hideNodeInspector() {
            document.getElementById('nodeInspector').style.display = 'none';
        }

        function updateNodeContent(nodeId, newContent) {
            const node = findNodeById(narrativeState.storyTree, nodeId);
            if (node) {
                node.text = newContent;
                renderNodes(); // Re-render to show updated content
                showNotification('Node content updated', 'success');
            }
        }

        // ==================== NARRATIVE TOOLS ====================

        function generatePlotTwist() {
            if (!narrativeState.storyTree) {
                showNotification('Initialize a narrative first!', 'error');
                return;
            }
            
            const twists = [
                'A trusted ally reveals they have been working for the enemy all along',
                'The apparent villain is actually trying to prevent a greater catastrophe',
                'A dead character returns, revealing they faked their death',
                'The party discovers they have been manipulated by a higher power',
                'A seemingly insignificant detail from the past becomes crucial',
                'The real treasure was the friends made along the way... just kidding, it\'s a trap',
                'An enemy becomes an unexpected ally due to changing circumstances',
                'The party realizes they are actually the "villains" in someone else\'s story'
            ];
            
            const twist = twists[Math.floor(Math.random() * twists.length)];
            showNotification(`Plot Twist Idea: ${twist}`, 'info', 8000);
        }

        function rollFateCheck() {
            const roll = Math.floor(Math.random() * 20) + 1;
            const outcomes = {
                1: '💀 Critical Failure - Something goes dramatically wrong',
                2: '❌ Major Failure - Significant setback occurs',
                3: '❌ Major Failure - Complications arise',
                4: '⚠️ Failure - Things don\'t go as planned',
                5: '⚠️ Failure - Minor setback',
                6: '⚠️ Failure - Slight complication',
                7: '⚠️ Failure - Not quite successful',
                8: '➖ Neutral - Mixed results',
                9: '➖ Neutral - Partial success',
                10: '➖ Neutral - Uncertain outcome',
                11: '➖ Neutral - Status quo maintained',
                12: '➕ Success - Things go well',
                13: '➕ Success - Positive outcome',
                14: '✅ Success - Good result',
                15: '✅ Success - Very positive',
                16: '✅ Major Success - Excellent outcome',
                17: '✅ Major Success - Great result',
                18: '✅ Major Success - Outstanding success',
                19: '✅ Major Success - Nearly perfect',
                20: '🌟 Critical Success - Everything goes perfectly, plus bonus'
            };
            
            showNotification(`🎲 Fate Roll: ${roll}/20 - ${outcomes[roll]}`, 'info', 6000);
        }

        function rollFateFromNode(nodeId) {
            const node = findNodeById(narrativeState.storyTree, nodeId);
            if (!node || node.children.length === 0) {
                rollFateCheck();
                return;
            }
            
            // Weighted random selection based on probability
            const totalWeight = node.children.reduce((sum, child) => sum + child.probability, 0);
            let random = Math.random() * totalWeight;
            
            for (const child of node.children) {
                random -= child.probability;
                if (random <= 0) {
                    focusNode(child.id);
                    showNotification(`🎲 Fate selected: "${child.text.substring(0, 50)}..."`, 'success');
                    return;
                }
            }
            
            // Fallback to first child
            focusNode(node.children[0].id);
        }

        function analyzeNarrative() {
            if (!narrativeState.storyTree) {
                showNotification('Initialize a narrative first!', 'error');
                return;
            }
            
            const allNodes = layoutEngine.collectAllNodes(narrativeState.storyTree);
            const typeCount = {};
            allNodes.forEach(node => {
                typeCount[node.type] = (typeCount[node.type] || 0) + 1;
            });
            
            const analysis = `
                📊 Narrative Analysis:
                • Total Scenes: ${allNodes.length}
                • Story Depth: ${Math.max(...allNodes.map(n => n.depth))} levels
                • Combat Scenes: ${typeCount.combat || 0}
                • Social Scenes: ${typeCount.social || 0}
                • Exploration Scenes: ${typeCount.exploration || 0}
                • Mystery Scenes: ${typeCount.mystery || 0}
                • Most Common Type: ${Object.keys(typeCount).reduce((a, b) => typeCount[a] > typeCount[b] ? a : b)}
            `;
            
            showNotification(analysis, 'info', 8000);
        }

        function suggestNextScene() {
            if (!narrativeState.storyTree || !selectedNode) {
                showNotification('Select a story node first!', 'error');
                return;
            }
            
            const context = storyGenerator.buildRichContext(selectedNode);
            const needs = storyGenerator.analyzeNarrativeNeeds(context);
            
            let suggestion = 'Scene Suggestions:\n';
            
            if (needs.pacing.needsCalm) {
                suggestion += '• Add a peaceful moment for character development\n';
            }
            if (needs.pacing.needsAction) {
                suggestion += '• Introduce conflict or time pressure\n';
            }
            if (needs.characterDevelopment.underdevelopedNPCs.length > 0) {
                suggestion += `• Focus on ${needs.characterDevelopment.underdevelopedNPCs[0].name}\n`;
            }
            if (needs.plotProgression.threadsToAdvance.length > 0) {
                suggestion += `• Advance the "${needs.plotProgression.threadsToAdvance[0].title}" plotline\n`;
            }
            
            suggestion += '• Introduce a new complication\n• Reveal hidden information\n• Test party relationships';
            
            showNotification(suggestion, 'info', 8000);
        }

        // ==================== MODAL SYSTEM ====================

        function showModal(title, content, actions = []) {
            const overlay = document.getElementById('modalOverlay');
            const modal = document.getElementById('modalContent');
            
            const actionsHTML = actions.map(action => 
                `<button class="btn ${action.class || ''}" onclick="${action.onclick}">${action.text}</button>`
            ).join('');
            
            modal.innerHTML = `
                <div class="modal-header">
                    <div class="modal-title">${title}</div>
                    <button class="modal-close" onclick="hideModal()">×</button>
                </div>
                <div class="modal-body">
                    ${content}
                </div>
                ${actionsHTML ? `<div class="modal-footer" style="margin-top: 20px; text-align: right;">${actionsHTML}</div>` : ''}
            `;
            
            overlay.style.display = 'flex';
            
            // Focus management
            setTimeout(() => {
                const firstInput = modal.querySelector('input, textarea, select');
                if (firstInput) firstInput.focus();
            }, 100);
        }

        function hideModal() {
            document.getElementById('modalOverlay').style.display = 'none';
        }

        function showAddEventModal(nodeId) {
            const content = `
                <div class="form-group">
                    <label class="form-label">Event Description</label>
                    <textarea id="customEventText" class="form-textarea" rows="4" 
                        placeholder="Describe what happens next in detail... (e.g., 'A hooded messenger arrives with urgent news of an approaching army')"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Event Type</label>
                    <select id="customEventType" class="form-select">
                        <option value="auto">Auto-detect</option>
                        <option value="combat">Combat</option>
                        <option value="social">Social</option>
                        <option value="exploration">Exploration</option>
                        <option value="mystery">Mystery</option>
                    </select>
                </div>
            `;
            
            const actions = [
                { 
                    text: 'Add Event', 
                    class: 'btn-secondary',
                    onclick: `addCustomEventFromModal('${nodeId}')`
                },
                { 
                    text: 'Cancel', 
                    onclick: 'hideModal()'
                }
            ];
            
            showModal('Add Custom Event', content, actions);
        }

        function addCustomEventFromModal(nodeId) {
            const eventText = document.getElementById('customEventText').value.trim();
            const eventType = document.getElementById('customEventType').value;
            
            if (!eventText) {
                showNotification('Please provide an event description.', 'error');
                return;
            }
            
            addCustomEvent(nodeId, eventText);
            hideModal();
        }

        function showCampaignSettings() {
            const content = `
                <div class="form-group">
                    <label class="form-label">Campaign Name</label>
                    <input type="text" id="campaignName" class="form-input" 
                        value="${narrativeState.campaignName || 'Untitled Campaign'}" 
                        placeholder="Enter campaign name">
                </div>
                <div class="form-group">
                    <label class="form-label">Genre</label>
                    <select id="campaignGenre" class="form-select">
                        <option value="fantasy" ${narrativeState.narrativeContext.genre === 'fantasy' ? 'selected' : ''}>Fantasy</option>
                        <option value="sci-fi" ${narrativeState.narrativeContext.genre === 'sci-fi' ? 'selected' : ''}>Science Fiction</option>
                        <option value="modern" ${narrativeState.narrativeContext.genre === 'modern' ? 'selected' : ''}>Modern</option>
                        <option value="horror" ${narrativeState.narrativeContext.genre === 'horror' ? 'selected' : ''}>Horror</option>
                        <option value="steampunk" ${narrativeState.narrativeContext.genre === 'steampunk' ? 'selected' : ''}>Steampunk</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Tone</label>
                    <select id="campaignTone" class="form-select">
                        <option value="heroic" ${narrativeState.narrativeContext.tone === 'heroic' ? 'selected' : ''}>Heroic</option>
                        <option value="gritty" ${narrativeState.narrativeContext.tone === 'gritty' ? 'selected' : ''}>Gritty</option>
                        <option value="comedic" ${narrativeState.narrativeContext.tone === 'comedic' ? 'selected' : ''}>Comedic</option>
                        <option value="dark" ${narrativeState.narrativeContext.tone === 'dark' ? 'selected' : ''}>Dark</option>
                        <option value="mysterious" ${narrativeState.narrativeContext.tone === 'mysterious' ? 'selected' : ''}>Mysterious</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Layout Algorithm</label>
                    <select id="layoutAlgorithm" class="form-select">
                        <option value="hierarchical" ${layoutEngine.currentAlgorithm === 'hierarchical' ? 'selected' : ''}>Hierarchical</option>
                        <option value="force" ${layoutEngine.currentAlgorithm === 'force' ? 'selected' : ''}>Force-Directed</option>
                        <option value="radial" ${layoutEngine.currentAlgorithm === 'radial' ? 'selected' : ''}>Radial</option>
                        <option value="timeline" ${layoutEngine.currentAlgorithm === 'timeline' ? 'selected' : ''}>Timeline</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Auto-save Interval (seconds)</label>
                    <input type="number" id="autoSaveInterval" class="form-input" 
                        value="30" min="10" max="300" placeholder="30">
                </div>
            `;
            
            const actions = [
                { 
                    text: 'Save Settings', 
                    class: 'btn-secondary',
                    onclick: 'saveCampaignSettings()'
                },
                { 
                    text: 'Cancel', 
                    onclick: 'hideModal()'
                }
            ];
            
            showModal('Campaign Settings', content, actions);
        }

        function saveCampaignSettings() {
            const campaignName = document.getElementById('campaignName').value.trim();
            const genre = document.getElementById('campaignGenre').value;
            const tone = document.getElementById('campaignTone').value;
            const layoutAlgorithm = document.getElementById('layoutAlgorithm').value;
            
            narrativeState.campaignName = campaignName;
            narrativeState.narrativeContext.genre = genre;
            narrativeState.narrativeContext.tone = tone;
            layoutEngine.currentAlgorithm = layoutAlgorithm;
            
            if (narrativeState.storyTree) {
                updateLayout();
            }
            
            hideModal();
            showNotification('Campaign settings saved!', 'success');
        }

        function showImportModal() {
            const content = `
                <div class="form-group">
                    <label class="form-label">Import Campaign Data</label>
                    <input type="file" id="importFile" class="form-input" accept=".json" onchange="previewImport(this)">
                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 5px;">
                        Select a JSON file exported from Narrative Nexus
                    </div>
                </div>
                <div id="importPreview" style="margin-top: 15px;"></div>
            `;
            
            const actions = [
                { 
                    text: 'Import', 
                    class: 'btn-secondary',
                    onclick: 'executeImport()'
                },
                { 
                    text: 'Cancel', 
                    onclick: 'hideModal()'
                }
            ];
            
            showModal('Import Campaign', content, actions);
        }

        function previewImport(fileInput) {
            const file = fileInput.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    const preview = document.getElementById('importPreview');
                    
                    preview.innerHTML = `
                        <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px;">
                            <h4 style="color: var(--success); margin-bottom: 10px;">Preview</h4>
                            <div><strong>Campaign:</strong> ${data.campaignName || 'Unnamed'}</div>
                            <div><strong>Total Nodes:</strong> ${countNodes(data.storyTree || {})}</div>
                            <div><strong>NPCs:</strong> ${data.npcs ? Object.keys(data.npcs).length : 0}</div>
                            <div><strong>Plot Threads:</strong> ${data.plotThreads ? Object.keys(data.plotThreads).length : 0}</div>
                            <div><strong>Export Date:</strong> ${new Date(data.exportTimestamp || Date.now()).toLocaleString()}</div>
                        </div>
                    `;
                } catch (error) {
                    document.getElementById('importPreview').innerHTML = `
                        <div style="background: var(--danger); color: white; padding: 15px; border-radius: 8px;">
                            Invalid file format. Please select a valid Narrative Nexus export.
                        </div>
                    `;
                }
            };
            reader.readAsText(file);
        }

        function countNodes(node) {
            if (!node || !node.children) return 1;
            return 1 + node.children.reduce((sum, child) => sum + countNodes(child), 0);
        }

        function executeImport() {
            const fileInput = document.getElementById('importFile');
            const file = fileInput.files[0];
            
            if (!file) {
                showNotification('Please select a file to import.', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    importCampaignData(data);
                    hideModal();
                    showNotification('Campaign imported successfully!', 'success');
                } catch (error) {
                    showNotification('Error importing campaign: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==================== NOTIFICATION SYSTEM ====================

        function showNotification(message, type = 'info', duration = 4000) {
            const notification = document.getElementById('notification');
            
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div style="flex: 1; white-space: pre-line;">${message}</div>
                    <button onclick="hideNotification()" style="background: none; border: none; color: inherit; font-size: 1.2rem; margin-left: 10px; cursor: pointer;">×</button>
                </div>
            `;
            
            notification.classList.add('show');
            
            setTimeout(() => {
                hideNotification();
            }, duration);
        }

        function hideNotification() {
            const notification = document.getElementById('notification');
            notification.classList.remove('show');
        }

        // ==================== SAVE/LOAD SYSTEM ====================

        function quickSave() {
            saveToLocalStorage();
            showNotification('Campaign quick-saved!', 'success');
        }

        function autoSave() {
            if (narrativeState.storyTree) {
                saveToLocalStorage();
                console.log('Auto-saved at', new Date().toLocaleTimeString());
            }
        }

        function saveToLocalStorage() {
            try {
                const saveData = {
                    version: '1.0',
                    campaignName: narrativeState.campaignName || 'Untitled Campaign',
                    exportTimestamp: Date.now(),
                    storyTree: narrativeState.storyTree ? narrativeState.storyTree.serialize() : null,
                    npcs: Array.from(narrativeState.npcs.entries()).map(([id, npc]) => [id, npc.serialize()]),
                    plotThreads: Array.from(narrativeState.plotThreads.entries()),
                    storyHistory: narrativeState.storyHistory,
                    worldState: narrativeState.worldState,
                    narrativeContext: narrativeState.narrativeContext,
                    currentSession: narrativeState.currentSession,
                    layoutAlgorithm: layoutEngine.currentAlgorithm,
                    canvasTransform: canvasTransform
                };
                
                localStorage.setItem('narrativeNexus_campaign', JSON.stringify(saveData));
                return true;
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                showNotification('Error saving campaign: ' + error.message, 'error');
                return false;
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('narrativeNexus_campaign');
                if (!saved) return false;
                
                const data = JSON.parse(saved);
                return importCampaignData(data);
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                return false;
            }
        }

        function importCampaignData(data) {
            try {
                // Import basic info
                narrativeState.campaignName = data.campaignName || 'Imported Campaign';
                
                // Import story tree
                if (data.storyTree) {
                    narrativeState.storyTree = StoryNode.deserialize(data.storyTree);
                }
                
                // Import NPCs - handle both array and Map formats
                narrativeState.npcs.clear();
                if (data.npcs) {
                    if (Array.isArray(data.npcs)) {
                        data.npcs.forEach(([id, npcData]) => {
                            narrativeState.npcs.set(id, AdvancedNPC.deserialize(npcData));
                        });
                    } else if (data.npcs instanceof Map) {
                        data.npcs.forEach((npcData, id) => {
                            narrativeState.npcs.set(id, AdvancedNPC.deserialize(npcData));
                        });
                    } else if (typeof data.npcs === 'object') {
                        Object.entries(data.npcs).forEach(([id, npcData]) => {
                            narrativeState.npcs.set(id, AdvancedNPC.deserialize(npcData));
                        });
                    }
                }
                
                // Import plot threads - handle both array and Map formats
                narrativeState.plotThreads.clear();
                if (data.plotThreads) {
                    if (Array.isArray(data.plotThreads)) {
                        data.plotThreads.forEach(([id, thread]) => {
                            narrativeState.plotThreads.set(id, thread);
                        });
                    } else if (data.plotThreads instanceof Map) {
                        data.plotThreads.forEach((thread, id) => {
                            narrativeState.plotThreads.set(id, thread);
                        });
                    } else if (typeof data.plotThreads === 'object') {
                        Object.entries(data.plotThreads).forEach(([id, thread]) => {
                            narrativeState.plotThreads.set(id, thread);
                        });
                    }
                }
                
                // Import other state with safe defaults
                if (data.storyHistory && Array.isArray(data.storyHistory)) {
                    narrativeState.storyHistory = data.storyHistory;
                }
                
                if (data.worldState) {
                    narrativeState.worldState = { 
                        ...narrativeState.worldState, 
                        ...data.worldState,
                        // Ensure Maps are properly initialized
                        locations: new Map(),
                        factions: new Map(), 
                        resources: new Map()
                    };
                    
                    // Convert worldState Maps if they're stored as objects
                    if (data.worldState.locations) {
                        if (Array.isArray(data.worldState.locations)) {
                            narrativeState.worldState.locations = new Map(data.worldState.locations);
                        } else if (typeof data.worldState.locations === 'object') {
                            narrativeState.worldState.locations = new Map(Object.entries(data.worldState.locations));
                        }
                    }
                    
                    if (data.worldState.factions) {
                        if (Array.isArray(data.worldState.factions)) {
                            narrativeState.worldState.factions = new Map(data.worldState.factions);
                        } else if (typeof data.worldState.factions === 'object') {
                            narrativeState.worldState.factions = new Map(Object.entries(data.worldState.factions));
                        }
                    }
                    
                    if (data.worldState.resources) {
                        if (Array.isArray(data.worldState.resources)) {
                            narrativeState.worldState.resources = new Map(data.worldState.resources);
                        } else if (typeof data.worldState.resources === 'object') {
                            narrativeState.worldState.resources = new Map(Object.entries(data.worldState.resources));
                        }
                    }
                }
                
                if (data.narrativeContext) {
                    narrativeState.narrativeContext = { ...narrativeState.narrativeContext, ...data.narrativeContext };
                }
                
                if (data.currentSession) {
                    narrativeState.currentSession = { ...narrativeState.currentSession, ...data.currentSession };
                }
                
                if (data.layoutAlgorithm) {
                    layoutEngine.currentAlgorithm = data.layoutAlgorithm;
                }
                
                if (data.canvasTransform) {
                    canvasTransform = { ...canvasTransform, ...data.canvasTransform };
                }
                
                // Ensure data integrity after import
                ensureDataIntegrity();
                
                // Update UI
                updateLayout();
                updateUI();
                
                return true;
            } catch (error) {
                console.error('Error importing campaign data:', error);
                showNotification('Error importing campaign: ' + error.message, 'error');
                return false;
            }
        }

        function exportCampaign() {
            try {
                const exportData = {
                    version: '1.0',
                    campaignName: narrativeState.campaignName || 'Exported Campaign',
                    exportTimestamp: Date.now(),
                    storyTree: narrativeState.storyTree ? narrativeState.storyTree.serialize() : null,
                    npcs: Array.from(narrativeState.npcs.entries()).map(([id, npc]) => [id, npc.serialize()]),
                    plotThreads: Array.from(narrativeState.plotThreads.entries()),
                    storyHistory: narrativeState.storyHistory,
                    worldState: narrativeState.worldState,
                    narrativeContext: narrativeState.narrativeContext,
                    currentSession: narrativeState.currentSession,
                    layoutAlgorithm: layoutEngine.currentAlgorithm
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `${(narrativeState.campaignName || 'campaign').replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                showNotification('Campaign exported successfully!', 'success');
            } catch (error) {
                console.error('Error exporting campaign:', error);
                showNotification('Error exporting campaign: ' + error.message, 'error');
            }
        }

        // ==================== ADVANCED FEATURES ====================

        function editNodeContent(node) {
            const nodeEl = document.getElementById(`node-${node.id}`);
            const contentEl = nodeEl.querySelector('.node-content');
            
            contentEl.classList.add('editing');
            contentEl.focus();
            
            // Select all text
            const range = document.createRange();
            range.selectNodeContents(contentEl);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            const finishEditing = () => {
                contentEl.classList.remove('editing');
                updateNodeContent(node.id, contentEl.textContent);
                contentEl.removeEventListener('blur', finishEditing);
                contentEl.removeEventListener('keydown', handleEditingKeydown);
            };
            
            const handleEditingKeydown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Escape') {
                    contentEl.textContent = node.text; // Restore original
                    finishEditing();
                }
            };
            
            contentEl.addEventListener('blur', finishEditing);
            contentEl.addEventListener('keydown', handleEditingKeydown);
        }

        function createNodeConnection(fromNodeId, toNodeId) {
            const fromNode = findNodeById(narrativeState.storyTree, fromNodeId);
            const toNode = findNodeById(narrativeState.storyTree, toNodeId);
            
            if (!fromNode || !toNode) return;
            
            // Check if connection already exists
            if (fromNode.children.includes(toNode)) return;
            
            // Add connection
            fromNode.addChild(toNode);
            
            // Update layout and render
            updateLayout();
            showNotification('Node connection created!', 'success');
        }

        function duplicateNode(nodeId) {
            const node = findNodeById(narrativeState.storyTree, nodeId);
            const parent = findParentNode(narrativeState.storyTree, nodeId);
            
            if (!node || !parent) return;
            
            // Create duplicate
            const duplicate = new StoryNode({
                text: node.text + ' (Copy)',
                type: node.type,
                probability: node.probability,
                consequences: [...node.consequences],
                requirements: [...node.requirements],
                tags: [...node.tags],
                involvedNPCs: [...node.involvedNPCs],
                affectedPlotThreads: [...node.affectedPlotThreads],
                metadata: { ...node.metadata }
            });
            
            parent.addChild(duplicate);
            
            updateLayout();
            showNotification('Node duplicated!', 'success');
        }

        function mergeNodes(nodeId1, nodeId2) {
            const node1 = findNodeById(narrativeState.storyTree, nodeId1);
            const node2 = findNodeById(narrativeState.storyTree, nodeId2);
            
            if (!node1 || !node2 || node1 === node2) return;
            
            // Merge content
            const mergedText = `${node1.text} ${node2.text}`;
            const mergedTags = [...new Set([...node1.tags, ...node2.tags])];
            const mergedNPCs = [...new Set([...node1.involvedNPCs, ...node2.involvedNPCs])];
            
            // Update first node
            node1.text = mergedText;
            node1.tags = mergedTags;
            node1.involvedNPCs = mergedNPCs;
            node1.probability = (node1.probability + node2.probability) / 2;
            
            // Move children from second node to first
            node2.children.forEach(child => {
                child.parent = node1;
                node1.children.push(child);
            });
            
            // Remove second node
            deleteNode(nodeId2);
            
            showNotification('Nodes merged successfully!', 'success');
        }

        // ==================== ADVANCED ANALYSIS ====================

        function analyzeStoryStructure() {
            if (!narrativeState.storyTree) {
                showNotification('No story to analyze!', 'error');
                return;
            }
            
            const allNodes = layoutEngine.collectAllNodes(narrativeState.storyTree);
            const analysis = {
                totalNodes: allNodes.length,
                maxDepth: Math.max(...allNodes.map(n => n.depth)),
                branchingFactor: allNodes.length > 1 ? (allNodes.length - 1) / allNodes.filter(n => n.children.length > 0).length : 0,
                typeDistribution: {},
                probabilityAnalysis: {
                    highProbability: allNodes.filter(n => n.probability > 0.7).length,
                    mediumProbability: allNodes.filter(n => n.probability >= 0.3 && n.probability <= 0.7).length,
                    lowProbability: allNodes.filter(n => n.probability < 0.3).length
                },
                npcInvolvement: {},
                plotThreadCoverage: {}
            };
            
            // Calculate type distribution
            allNodes.forEach(node => {
                analysis.typeDistribution[node.type] = (analysis.typeDistribution[node.type] || 0) + 1;
            });
            
            // Calculate NPC involvement
            narrativeState.npcs.forEach((npc, id) => {
                const involvement = allNodes.filter(node => node.involvedNPCs.includes(id)).length;
                analysis.npcInvolvement[npc.name] = involvement;
            });
            
            // Calculate plot thread coverage
            narrativeState.plotThreads.forEach((thread, id) => {
                const coverage = allNodes.filter(node => node.affectedPlotThreads.includes(id)).length;
                analysis.plotThreadCoverage[thread.title] = coverage;
            });
            
            displayAnalysisResults(analysis);
        }

        function displayAnalysisResults(analysis) {
            const content = `
                <div style="max-height: 400px; overflow-y: auto;">
                    <h4 style="color: var(--highlight); margin-bottom: 15px;">Story Structure Analysis</h4>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: var(--success);">Overview</h5>
                        <div>Total Scenes: ${analysis.totalNodes}</div>
                        <div>Maximum Depth: ${analysis.maxDepth} levels</div>
                        <div>Average Branching: ${analysis.branchingFactor.toFixed(2)} branches per node</div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: var(--success);">Scene Types</h5>
                        ${Object.entries(analysis.typeDistribution).map(([type, count]) => 
                            `<div>${getTypeIcon(type)} ${type}: ${count} (${(count/analysis.totalNodes*100).toFixed(1)}%)</div>`
                        ).join('')}
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: var(--success);">Probability Distribution</h5>
                        <div>High (>70%): ${analysis.probabilityAnalysis.highProbability} scenes</div>
                        <div>Medium (30-70%): ${analysis.probabilityAnalysis.mediumProbability} scenes</div>
                        <div>Low (<30%): ${analysis.probabilityAnalysis.lowProbability} scenes</div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: var(--success);">Character Involvement</h5>
                        ${Object.entries(analysis.npcInvolvement).map(([name, count]) => 
                            `<div>${name}: ${count} scenes</div>`
                        ).join('') || '<div>No characters tracked</div>'}
                    </div>
                    
                    <div>
                        <h5 style="color: var(--success);">Plot Thread Coverage</h5>
                        ${Object.entries(analysis.plotThreadCoverage).map(([title, count]) => 
                            `<div>${title}: ${count} scenes</div>`
                        ).join('') || '<div>No plot threads tracked</div>'}
                    </div>
                </div>
            `;
            
            showModal('Story Analysis', content, [{ text: 'Close', onclick: 'hideModal()' }]);
        }

        function generateStoryReport() {
            if (!narrativeState.storyTree) {
                showNotification('No story to report on!', 'error');
                return;
            }
            
            const report = createDetailedReport();
            const blob = new Blob([report], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${(narrativeState.campaignName || 'campaign')}_report_${new Date().toISOString().split('T')[0]}.md`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            showNotification('Story report generated and downloaded!', 'success');
        }

        function createDetailedReport() {
            const allNodes = layoutEngine.collectAllNodes(narrativeState.storyTree);
            const npcs = Array.from(narrativeState.npcs.values());
            const threads = Array.from(narrativeState.plotThreads.values());
            
            let report = `# ${narrativeState.campaignName || 'Campaign'} - Story Report\n\n`;
            report += `Generated on: ${new Date().toLocaleDateString()}\n\n`;
            
            // Executive Summary
            report += `## Executive Summary\n\n`;
            report += `- **Total Scenes**: ${allNodes.length}\n`;
            report += `- **Story Depth**: ${Math.max(...allNodes.map(n => n.depth))} levels\n`;
            report += `- **Characters**: ${npcs.length}\n`;
            report += `- **Plot Threads**: ${threads.length}\n`;
            report += `- **Session Duration**: ${Math.round((Date.now() - narrativeState.currentSession.startTime) / 60000)} minutes\n\n`;
            
            // Story Structure
            report += `## Story Structure\n\n`;
            const typeCount = {};
            allNodes.forEach(node => {
                typeCount[node.type] = (typeCount[node.type] || 0) + 1;
            });
            
            Object.entries(typeCount).forEach(([type, count]) => {
                report += `- **${type.charAt(0).toUpperCase() + type.slice(1)}**: ${count} scenes\n`;
            });
            report += `\n`;
            
            // Character Profiles
            if (npcs.length > 0) {
                report += `## Character Profiles\n\n`;
                npcs.forEach(npc => {
                    report += `### ${npc.name}\n`;
                    report += `- **Role**: ${npc.archetype}\n`;
                    report += `- **Motivation**: ${npc.coreMotivation || 'Unknown'}\n`;
                    report += `- **Emotional State**: ${npc.emotionalState}\n`;
                    report += `- **Active Goals**: ${npc.currentGoals.filter(g => g.status === 'active').length}\n`;
                    if (npc.secrets.length > 0) {
                        report += `- **Secrets**: ${npc.secrets.length} known\n`;
                    }
                    report += `\n`;
                });
            }
            
            // Plot Threads
            if (threads.length > 0) {
                report += `## Plot Threads\n\n`;
                threads.forEach(thread => {
                    report += `### ${thread.title}\n`;
                    report += `- **Status**: ${thread.status}\n`;
                    report += `- **Progress**: ${thread.progress}%\n`;
                    report += `- **Description**: ${thread.description}\n`;
                    report += `\n`;
                });
            }
            
            // Story Timeline
            report += `## Session Timeline\n\n`;
            narrativeState.storyHistory.slice(-10).forEach(event => {
                const time = new Date(event.timestamp).toLocaleTimeString();
                report += `- **${time}**: ${event.event.text}\n`;
            });
            
            return report;
        }

        // ==================== COLLABORATION FEATURES ====================

        function shareStoryLink() {
            // Generate a shareable link (simplified for this demo)
            const shareData = {
                campaignName: narrativeState.campaignName,
                storyTree: narrativeState.storyTree ? narrativeState.storyTree.serialize() : null,
                npcs: Array.from(narrativeState.npcs.entries()).map(([id, npc]) => [id, npc.serialize()]),
                plotThreads: Array.from(narrativeState.plotThreads.entries())
            };
            
            const encoded = btoa(JSON.stringify(shareData));
            const shareUrl = `${window.location.origin}${window.location.pathname}?import=${encoded}`;
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                showNotification('Share link copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Share link: ' + shareUrl, 'info', 10000);
            });
        }

        function checkForSharedData() {
            const urlParams = new URLSearchParams(window.location.search);
            const importData = urlParams.get('import');
            
            if (importData) {
                try {
                    const decoded = JSON.parse(atob(importData));
                    importCampaignData(decoded);
                    showNotification('Shared campaign loaded!', 'success');
                    
                    // Clean up URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                } catch (error) {
                    console.error('Error loading shared data:', error);
                    showNotification('Error loading shared campaign', 'error');
                }
            }
        }

        // ==================== KEYBOARD SHORTCUTS HELP ====================

        function showKeyboardShortcuts() {
            const content = `
                <div style="max-height: 400px; overflow-y: auto;">
                    <h4 style="color: var(--highlight); margin-bottom: 15px;">Keyboard Shortcuts</h4>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: var(--success);">General</h5>
                        <div><kbd>Ctrl+S</kbd> - Quick Save</div>
                        <div><kbd>Ctrl+Z</kbd> - Undo</div>
                        <div><kbd>Ctrl+Shift+Z</kbd> - Redo</div>
                        <div><kbd>Ctrl+F</kbd> - Focus Search</div>
                        <div><kbd>F11</kbd> - Toggle Fullscreen</div>
                        <div><kbd>Esc</kbd> - Deselect / Close dialogs</div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: var(--success);">Story Nodes</h5>
                        <div><kbd>Ctrl+N</kbd> - Generate branches from selected node</div>
                        <div><kbd>Delete</kbd> - Delete selected node</div>
                        <div><kbd>Double-click</kbd> - Edit node content</div>
                        <div><kbd>Click + Drag</kbd> - Move node</div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: var(--success);">Canvas Navigation</h5>
                        <div><kbd>Mouse Wheel</kbd> - Zoom in/out</div>
                        <div><kbd>Click + Drag</kbd> - Pan canvas</div>
                        <div><kbd>+/-</kbd> - Zoom controls</div>
                    </div>
                </div>
            `;
            
            showModal('Keyboard Shortcuts', content, [{ text: 'Close', onclick: 'hideModal()' }]);
        }

        // ==================== ERROR HANDLING ====================

        function handleError(error, context = 'Unknown') {
            console.error(`Error in ${context}:`, error);
            
            const errorMessage = error.message || 'An unknown error occurred';
            showNotification(`Error: ${errorMessage}`, 'error', 6000);
            
            // Log error for debugging
            if (window.console && window.console.error) {
                console.error('Detailed error:', {
                    context: context,
                    error: error,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    narrativeState: narrativeState
                });
            }
        }

        // ==================== INITIALIZATION ====================

        document.addEventListener('DOMContentLoaded', function() {
            try {
                initializeApplication();
                checkForSharedData();
                
                // Set up error handlers
                window.addEventListener('error', function(e) {
                    handleError(e.error, 'Global error handler');
                });
                
                window.addEventListener('unhandledrejection', function(e) {
                    handleError(e.reason, 'Unhandled promise rejection');
                });
                
            } catch (error) {
                handleError(error, 'Application initialization');
            }
        });

        // ==================== UTILITY FUNCTIONS ====================

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        function generateUniqueId(prefix = '') {
            return prefix + Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function formatTimestamp(timestamp) {
            return new Date(timestamp).toLocaleString();
        }

        function calculateDistance(pos1, pos2) {
            const dx = pos2.x - pos1.x;
            const dy = pos2.y - pos1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        // Export functions for debugging (optional)
        if (window.console && window.console.log) {
            window.narrativeDebug = {
                narrativeState,
                storyGenerator,
                layoutEngine,
                showModal,
                updateLayout,
                updateUI
            };
        }

        // Performance monitoring
        let performanceMonitor = {
            startTime: Date.now(),
            lastFrameTime: Date.now(),
            frameCount: 0,
            
            update() {
                this.frameCount++;
                this.lastFrameTime = Date.now();
                
                if (this.frameCount % 60 === 0) {
                    const avgFrameTime = (this.lastFrameTime - this.startTime) / this.frameCount;
                    if (avgFrameTime > 50) { // If average frame time > 50ms
                        console.warn('Performance warning: Average frame time is', avgFrameTime.toFixed(2), 'ms');
                    }
                }
            }
        };

        // Call performance monitor on layout updates
        const originalUpdateLayout = updateLayout;
        updateLayout = function() {
            const start = performance.now();
            originalUpdateLayout.apply(this, arguments);
            const end = performance.now();
            
            if (end - start > 100) {
                console.warn('Layout update took', (end - start).toFixed(2), 'ms');
            }
            
            performanceMonitor.update();
        };

    </script>
</body>
</html>