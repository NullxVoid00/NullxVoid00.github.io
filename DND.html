<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DND 5e Complete System - Professional Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Tab System */
        .tab-container {
            display: flex;
            background: linear-gradient(180deg, #1a1a2e 0%, #16161f 100%);
            border-bottom: 2px solid #2a2a3e;
            padding: 0 20px;
            height: 50px;
        }
        
        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #9ca3af;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }
        
        .tab:hover {
            color: #e0e0e0;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .tab.active {
            color: #fbbf24;
            border-bottom-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }
        
        .tab-content {
            display: none;
            height: calc(100vh - 50px);
            overflow: hidden;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Combat Board Layout */
        .combat-container {
            display: flex;
            height: 100%;
        }
        
        /* Sidebar */
        .sidebar {
            width: 320px;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2a2a3e;
        }
        
        .sidebar h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 20px;
            color: #fbbf24;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #6b7280;
            margin-bottom: 12px;
            font-weight: 700;
        }
        
        /* Buttons */
        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        /* Quick Add Grid */
        .quick-add-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }
        
        .quick-add-btn {
            padding: 8px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: #93bbfc;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .quick-add-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: scale(1.05);
        }
        
        /* Dice Roll Grid */
        .dice-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }
        
        .dice-btn {
            padding: 8px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 6px;
            color: #fbbf24;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .dice-btn:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: scale(1.05);
        }
        
        /* Turn Order */
        .turn-order {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .turn-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            font-size: 13px;
            background: rgba(55, 65, 81, 0.3);
            justify-content: space-between;
        }
        
        .turn-item.active {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .turn-actions {
            font-size: 10px;
            opacity: 0.8;
        }
        
        /* Settings */
        .toggle-btn {
            background: #374151;
            position: relative;
            padding-left: 50px;
        }
        
        .toggle-btn.active {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }
        
        .toggle-switch {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 35px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }
        
        .toggle-btn.active .toggle-switch::after {
            left: 17px;
        }
        
        .input-field {
            width: 100%;
            padding: 8px 12px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 13px;
            margin-bottom: 8px;
        }
        
        /* Sound Settings */
        .sound-input {
            width: 100%;
            padding: 6px 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        /* Combat Log */
        .combat-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .log-entry {
            padding: 6px 10px;
            margin-bottom: 4px;
            background: rgba(55, 65, 81, 0.3);
            border-radius: 4px;
            font-size: 12px;
            border-left: 3px solid #4b5563;
        }
        
        .log-entry.damage { border-left-color: #ef4444; }
        .log-entry.heal { border-left-color: #10b981; }
        .log-entry.info { border-left-color: #3b82f6; }
        .log-entry.death { border-left-color: #dc2626; }
        .log-entry.save { border-left-color: #fbbf24; }
        
        /* Game Board */
        .game-board {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .board-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .board-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        /* Drawing Canvas */
        .drawing-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .drawing-canvas.drawing-mode {
            pointer-events: auto;
        }
        
        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
        }
        
        /* Drag Arrow */
        .drag-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            transform-origin: left center;
        }
        
        .persistent-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            animation: fadeOut 1s ease-out 0.5s forwards;
        }
        
        @keyframes fadeOut {
            to { opacity: 0; }
        }
        
        /* Entity Styles */
        .entity {
            position: absolute;
            width: 70px;
            height: 70px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            user-select: none;
        }
        
        .entity:hover {
            transform: scale(1.1);
            z-index: 20;
        }
        
        .entity.selected {
            z-index: 30;
        }
        
        .entity.dead {
            opacity: 0.4;
            filter: grayscale(100%);
        }
        
        .entity.unconscious {
            opacity: 0.6;
            filter: grayscale(50%);
        }
        
        .entity.valid-target {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.5));
            }
            50% { 
                transform: scale(1.08);
                filter: drop-shadow(0 0 20px rgba(251, 191, 36, 0.8));
            }
        }
        
        .entity-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border: 3px solid;
        }
        
        .entity.selected .entity-circle {
            box-shadow: 0 0 0 4px rgba(251, 191, 36, 0.4);
        }
        
        .entity-image {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .entity-content {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        /* HP Bar */
        .hp-bar {
            position: absolute;
            bottom: -4px;
            left: 10%;
            width: 80%;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .hp-fill {
            height: 100%;
            transition: all 0.5s;
            border-radius: 3px;
        }
        
        .hp-fill.high { background: linear-gradient(to right, #10b981, #34d399); }
        .hp-fill.medium { background: linear-gradient(to right, #f59e0b, #fbbf24); }
        .hp-fill.low { background: linear-gradient(to right, #dc2626, #ef4444); }
        
        /* Entity Name Label */
        .entity-name {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: 600;
        }
        
        /* Conditions Badge */
        .conditions-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(139, 92, 246, 0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
        }
        
        /* Death Saves Indicator */
        .death-saves-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            display: flex;
            gap: 2px;
        }
        
        .death-save-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        .death-save-dot.success {
            background: #10b981;
        }
        
        .death-save-dot.failure {
            background: #ef4444;
        }
        
        /* Action Menu */
        .action-menu {
            position: absolute;
            top: 80px;
            left: 0;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 14px;
            min-width: 280px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1000;
        }
        
        .action-section {
            margin-bottom: 12px;
        }
        
        .action-section-title {
            font-size: 10px;
            text-transform: uppercase;
            color: #6b7280;
            margin-bottom: 6px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .action-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            text-align: left;
            padding: 7px 10px;
            background: rgba(55, 65, 81, 0.3);
            border: 1px solid transparent;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
        }
        
        .action-btn:hover {
            background: rgba(55, 65, 81, 0.5);
            border-color: rgba(139, 92, 246, 0.3);
        }
        
        .action-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .spell-slot-info {
            font-size: 10px;
            color: #9ca3af;
            margin-left: auto;
        }
        
        /* Details Panel */
        .details-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 18px;
            min-width: 320px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 500;
        }
        
        .stat-input {
            background: #374151;
            border: 1px solid #4b5563;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-size: 13px;
            width: 60px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(55, 65, 81, 0.5);
        }
        
        .stat-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-box {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #9ca3af;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #fbbf24;
        }
        
        .stat-mod {
            font-size: 12px;
            color: #6b7280;
        }
        
        /* Close Button */
        .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: transparent;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 4px;
            font-size: 18px;
        }
        
        .close-btn:hover {
            color: #ef4444;
        }
        
        /* Targeting Indicator */
        .targeting-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
            z-index: 1000;
        }
        
        .targeting-text {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            color: white;
        }
        
        .cancel-btn {
            display: block;
            margin: 0 auto;
            font-size: 12px;
            color: #fca5a5;
            text-decoration: underline;
            cursor: pointer;
            background: none;
            border: none;
        }
        
        /* Manager Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .modal {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 30px;
            min-width: 500px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
        }
        
        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .item-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .item-card:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: #8b5cf6;
        }
        
        .item-card.selected {
            background: rgba(139, 92, 246, 0.2);
            border-color: #8b5cf6;
        }
        
        /* Character Sheet */
        .character-sheet {
            padding: 20px;
            height: 100%;
            overflow-y: auto;
            background: #0f0f1e;
        }
        
        .character-list {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .character-card {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
        }
        
        .character-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            border-color: #8b5cf6;
        }
        
        .sheet-content {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 30px;
        }
        
        .ability-scores {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .ability-score {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
        }
        
        .skill-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .skill-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        /* Backgrounds Tab */
        .backgrounds-container {
            padding: 20px;
            height: 100%;
            overflow-y: auto;
            background: #0f0f1e;
        }
        
        .background-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .background-card {
            width: 200px;
            height: 150px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            border: 2px solid #374151;
        }
        
        .background-card:hover {
            border-color: #8b5cf6;
        }
        
        .background-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            text-align: center;
        }
        
        /* Import/Export */
        .textarea-large {
            width: 100%;
            height: 200px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* Movement Range Indicator */
        .movement-range {
            position: absolute;
            border: 2px dashed rgba(59, 130, 246, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
        
        /* Animations */
        .floating-text {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            animation: floatUp 1.5s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 1;
            }
            100% {
                transform: translateY(-60px) scale(1.2);
                opacity: 0;
            }
        }
        
        .arrow-animation {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }
        
        .arrow-line {
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            animation: shootArrow 0.5s ease-out;
            position: relative;
        }
        
        @keyframes shootArrow {
            0% { width: 0; opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0.2; }
        }
        
        /* Targeting Arrow */
        .targeting-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }
        
        .targeting-line {
            height: 3px;
            background: linear-gradient(to right, transparent, #dc2626, transparent);
            position: relative;
        }
        
        /* Spell Effect Animation */
        .spell-effect {
            position: absolute;
            pointer-events: none;
            z-index: 600;
        }
        
        @keyframes magicPulse {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
        
        .magic-circle {
            width: 100px;
            height: 100px;
            border: 3px solid;
            border-radius: 50%;
            animation: magicPulse 1s ease-out;
        }
        
        /* Roll Result Display */
        .roll-result {
            position: fixed;
            top: 60px;
            right: 20px;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1500;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .roll-result h3 {
            color: #fbbf24;
            margin-bottom: 10px;
        }
        
        .roll-breakdown {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 5px;
        }
        
        /* Expandable Library Sidebar */
        .library-sidebar-toggle {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            border: none;
            padding: 12px 8px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            cursor: pointer;
            border-radius: 8px 0 0 8px;
            font-size: 12px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
        }
        
        .library-sidebar-toggle:hover {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            transform: translateY(-50%) translateX(-5px);
        }
        
        .expandable-library-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
            border-left: 2px solid #2a2a3e;
            transition: right 0.3s ease-out;
            z-index: 999;
            display: flex;
            flex-direction: column;
        }
        
        .expandable-library-sidebar.open {
            right: 0;
        }
        
        .expandable-library-header {
            padding: 20px;
            border-bottom: 1px solid #2a2a3e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .expandable-library-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .expandable-library-content .search-bar {
            margin-bottom: 15px;
        }
        
        .expandable-library-content .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        
        .expandable-library-content .content-card {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .expandable-library-content .content-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            border-color: #8b5cf6;
        }
        
        .expandable-library-filters {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .expandable-library-filters .btn-small {
            padding: 4px 8px;
            font-size: 10px;
            margin: 0;
        }
        
        /* Search Bar */
        .search-bar {
            width: 100%;
            padding: 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            margin-bottom: 15px;
        }
        
        /* Status Icons */
        .status-icons {
            position: absolute;
            top: -15px;
            right: -15px;
            display: flex;
            flex-wrap: wrap;
            max-width: 40px;
            gap: 2px;
        }
        
        .status-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #666;
        }
        
        .status-icon.poisoned { background: #4ade80; }
        .status-icon.stunned { background: #fbbf24; }
        .status-icon.paralyzed { background: #ef4444; }
        .status-icon.charmed { background: #ec4899; }
        .status-icon.frightened { background: #8b5cf6; }
        .status-icon.prone { background: #94a3b8; }
        .status-icon.grappled { background: #f97316; }
        .status-icon.restrained { background: #dc2626; }
        .status-icon.blinded { background: #374151; }
        .status-icon.deafened { background: #6b7280; }
        .status-icon.invisible { background: transparent; border: 1px dashed #e5e7eb; }
        .status-icon.unconscious { background: #1f2937; }
        .status-icon.incapacitated { background: #7c2d12; }
        .status-icon.petrified { background: #57534e; }
        .status-icon.exhaustion { background: #991b1b; }

        /* Entity CSS Updates for containers */
        .entity.chest {
            border: 3px solid #8b5a2b;
            background: linear-gradient(45deg, #d4a574, #a67c52);
        }
        
        .entity.npc {
            border: 3px solid #10b981;
            background: linear-gradient(45deg, #34d399, #10b981);
        }

        /* Status Icon Button Styles */
        .status-buttons {
            position: absolute;
            top: -20px;
            left: 0;
            display: none;
            flex-wrap: wrap;
            max-width: 100px;
            gap: 2px;
            background: rgba(0, 0, 0, 0.9);
            padding: 5px;
            border-radius: 5px;
        }
        
        .entity:hover .status-buttons {
            display: flex;
        }
        
        .status-button {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            color: white;
        }
</head>
<body>
    <!-- Tab Navigation -->
    <div class="tab-container">
        <button class="tab active" onclick="switchTab(event, 'combat')">‚öîÔ∏è Combat Board</button>
        <button class="tab" onclick="switchTab(event, 'characters')">üë§ Character Sheets</button>
        <button class="tab" onclick="switchTab(event, 'backgrounds')">üñºÔ∏è Backgrounds</button>
        <button class="tab" onclick="switchTab(event, 'import-export')">üìÅ Import/Export</button>
    </div>
    
    <!-- Combat Board Tab -->
    <div id="combat-tab" class="tab-content active">
        <div class="combat-container">
            <!-- Sidebar -->
            <div class="sidebar">
                <h2>‚öîÔ∏è Combat Control</h2>
                
                <!-- Quick Add Section -->
                <div class="section">
                    <div class="section-title">Quick Add</div>
                    <button class="btn btn-primary" onclick="game.addPlayerCharacter()">
                        üõ°Ô∏è Add Player Character
                    </button>
                    <button class="btn btn-primary" onclick="game.addMonster()">
                        üëπ Add Monster
                    </button>
                    <button class="btn btn-primary" onclick="game.addItem()">
                        üì¶ Add Item
                    </button>
                    <button class="btn btn-primary" onclick="game.addChest()">
                        üéÅ Add Chest
                    </button>
                    <button class="btn btn-primary" onclick="game.addNPC()">
                        üé≠ Add NPC
                    </button>
                    <div class="quick-add-grid" id="quickAddGrid"></div>
                </div>
                
                <!-- Dice Rolls Section -->
                <div class="section">
                    <div class="section-title">Dice Rolls</div>
                    <div class="dice-grid">
                        <button class="dice-btn" onclick="game.rollDice('1d20')">d20</button>
                        <button class="dice-btn" onclick="game.rollDice('1d4')">1d4</button>
                        <button class="dice-btn" onclick="game.rollDice('1d6')">1d6</button>
                        <button class="dice-btn" onclick="game.rollDice('1d8')">1d8</button>
                        <button class="dice-btn" onclick="game.rollDice('1d10')">1d10</button>
                        <button class="dice-btn" onclick="game.rollDice('1d12')">1d12</button>
                        <button class="dice-btn" onclick="game.rollDice('2d6')">2d6</button>
                        <button class="dice-btn" onclick="game.rollDice('1d20+5')">d20+5</button>
                        <button class="dice-btn" onclick="game.rollDice('1d20-1')">d20-1</button>
                    </div>
                </div>
                
                <!-- Turn Order Section -->
                <div class="section">
                    <div class="section-title">Turn Order</div>
                    <div class="turn-order" id="turnOrder"></div>
                    <button class="btn btn-success" onclick="game.nextTurn()">‚ñ∂Ô∏è Next Turn</button>
                    <button class="btn btn-warning" onclick="game.endTurn()">‚è∏Ô∏è End Current Turn</button>
                    <button class="btn btn-danger" onclick="game.rollInitiative()">üé≤ Roll Initiative</button>
                </div>
                
                <!-- Settings Section -->
                <div class="section">
                    <div class="section-title">Settings</div>
                    <button class="btn toggle-btn active" id="gridToggle" onclick="game.toggleGrid()">
                        <div class="toggle-switch"></div>
                        Show Grid
                    </button>
                    <button class="btn toggle-btn" id="turnToggle" onclick="game.toggleTurnEnforcement()">
                        <div class="toggle-switch"></div>
                        Enforce Turns
                    </button>
                    <button class="btn toggle-btn" id="movementToggle" onclick="game.toggleMovementRange()">
                        <div class="toggle-switch"></div>
                        Show Movement Range
                    </button>
                    <button class="btn toggle-btn" id="editToggle" onclick="game.toggleEditMode()">
                        <div class="toggle-switch"></div>
                        Edit Mode
                    </button>
                    <button class="btn toggle-btn" id="drawToggle" onclick="game.toggleDrawMode()">
                        <div class="toggle-switch"></div>
                        Draw Mode
                    </button>
                    <input type="text" class="input-field" id="bgUrl" placeholder="Background Image URL" onchange="game.changeBackground()">
                    
                    <div class="section-title">Drawing Tools</div>
                    <button class="btn btn-danger" id="eraseToggle" onclick="game.toggleEraseMode()">
                        üßΩ Erase Mode
                    </button>
                    <button class="btn btn-warning" onclick="game.clearDrawing()">
                        üóëÔ∏è Clear Drawing
                    </button>
                    
                    <div class="section-title">Sound Effects</div>
                    <input type="text" class="sound-input" id="soundHeal" placeholder="Healing Sound URL" onchange="game.setSound('heal', this.value)">
                    <input type="text" class="sound-input" id="soundAttack" placeholder="Attack Sound URL" onchange="game.setSound('attack', this.value)">
                    <input type="text" class="sound-input" id="soundSpell" placeholder="Spell Sound URL" onchange="game.setSound('spell', this.value)">
                    <input type="text" class="sound-input" id="soundOpen" placeholder="Open Sound URL" onchange="game.setSound('open', this.value)">
                </div>
                
                <!-- Combat Log Section -->
                <div class="section">
                    <div class="section-title">Combat Log</div>
                    <div class="combat-log" id="combatLog">
                        <div class="log-entry info">Ready for combat...</div>
                    </div>
                </div>
                
                <!-- Game Controls -->
                <div class="section">
                    <div class="section-title">Game Controls</div>
                    <button class="btn btn-primary" onclick="game.saveGameState()">üíæ Save Game</button>
                    <button class="btn btn-primary" onclick="game.loadGameState()">üìÇ Load Game</button>
                    <button class="btn btn-danger" onclick="game.clearBoard()">üóëÔ∏è Clear Board</button>
                </div>
            </div>
            
            <!-- Game Board -->
            <div class="game-board" id="gameBoard">
                <div class="board-container" id="boardContainer">
                    <svg class="grid-overlay" id="gridOverlay">
                        <defs>
                            <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                                <path d="M 50 0 L 0 0 0 50" fill="none" stroke="white" stroke-width="1"/>
                            </pattern>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#grid)"/>
                    </svg>
                    <canvas class="drawing-canvas" id="drawingCanvas"></canvas>
                    <div class="board-canvas" id="boardCanvas"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Expandable Library Sidebar -->
    <button class="library-sidebar-toggle" id="libraryToggle" onclick="game.toggleLibrarySidebar()">
        üìö Library
    </button>
    
    <div class="expandable-library-sidebar" id="expandableLibrarySidebar">
        <div class="expandable-library-header">
            <h3 style="color: #fbbf24; margin: 0;">üìö Content Library</h3>
            <button class="close-btn" onclick="game.toggleLibrarySidebar()" style="position: static;">‚úï</button>
        </div>
        <div class="expandable-library-content">
            <input type="text" class="search-bar" id="sidebarLibrarySearch" placeholder="Search library..." onkeyup="game.searchSidebarLibrary(this.value)">
            
            <div class="expandable-library-filters">
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('all')">All</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('player')">Players</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('monster')">Monsters</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('spell')">Spells</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('item')">Items</button>
            </div>
            
            <button class="btn btn-primary" style="margin-bottom: 15px;" onclick="game.saveCurrentEntity()">
                üíæ Save Selected Entity
            </button>
            
            <div class="content-grid" id="sidebarLibraryGrid"></div>
        </div>
    </div>
    
    <!-- Character Sheets Tab -->
    <div id="characters-tab" class="tab-content">
        <div class="character-sheet">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">üë§ Character Sheets</h2>
            <div class="character-list" id="characterList"></div>
            <div class="sheet-content" id="sheetContent" style="display: none;"></div>
        </div>
    </div>
    
    <!-- Backgrounds Tab -->
    <div id="backgrounds-tab" class="tab-content">
        <div class="backgrounds-container">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">üñºÔ∏è Saved Backgrounds</h2>
            <input type="text" class="input-field" id="newBgUrl" placeholder="New Background URL">
            <button class="btn btn-primary" onclick="game.saveBackground()">Save Background</button>
            <div class="background-list" id="backgroundList"></div>
        </div>
    </div>
    
    <!-- Import/Export Tab -->
    <div id="import-export-tab" class="tab-content">
        <div style="padding: 40px;">
            <h2 style="color: #fbbf24; margin-bottom: 30px;">üìÅ Import/Export Content</h2>
            
            <div style="margin-bottom: 30px;">
                <h3 style="margin-bottom: 15px;">Export Library</h3>
                <button class="btn btn-primary" onclick="game.exportLibrary()">Export to JSON</button>
                <textarea class="textarea-large" id="exportData" readonly placeholder="Exported data will appear here..."></textarea>
            </div>
            
            <div>
                <h3 style="margin-bottom: 15px;">Import Library</h3>
                <textarea class="textarea-large" id="importData" placeholder="Paste JSON data here..."></textarea>
                <button class="btn btn-success" onclick="game.importLibrary()">Import from JSON</button>
            </div>
        </div>
    </div>
    
    <script>
        // Complete DND 5e Game System - Professional Edition
        const game = {
            // Core Game State
            entities: [],
            selectedEntity: null,
            currentTurn: 0,
            turnOrder: [],
            showGrid: true,
            showMovementRange: false,
            enforceTurns: false,
            editMode: false,
            drawMode: false,
            eraseMode: false,
            targetingMode: null,
            draggingEntity: null,
            dragStartPos: null,
            nextId: 1,
            gameNotes: '',
            diceRollHistory: [],
            roundNumber: 1,
            dragArrow: null,
            persistentArrow: null,
            backgroundUrl: '',
            savedBackgrounds: [],
            sounds: {
                heal: '',
                attack: '',
                spell: '',
                open: ''
            },
            

            
            // Drawing
            isDrawing: false,
            lastDrawX: 0,
            lastDrawY: 0,
            drawingCanvas: null,
            drawingCtx: null,
            
            // Library Sidebar
            librarySidebarOpen: false,
            
            // Action Economy State
            currentTurnActions: {
                movement: 0,
                action: false,
                bonusAction: false,
                reaction: true
            },
            
            // Comprehensive Content Library
            library: {
                monsters: [
                    {
                        name: 'Crossbow, Light',
                        type: 'weapon',
                        weaponType: 'simple',
                        damage: '1d8',
                        damageType: 'piercing',
                        properties: ['ammunition (80/320)', 'loading', 'two-handed'],
                        value: 25,
                        weight: 5,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        ranged: true,
                        range: 80,
                        description: 'Simple ranged weapon with loading property.',
                        image: ''
                    },
                    {
                        name: 'Scroll of Fireball',
                        type: 'scroll',
                        rarity: 'uncommon',
                        spell: 'Fireball',
                        value: 200,
                        weight: 0.1,
                        description: 'Casts Fireball spell once.',
                        consumable: true,
                        image: ''
                    },
                    {
                        name: 'Rope (50 ft)',
                        type: 'gear',
                        value: 1,
                        weight: 10,
                        description: 'Hempen rope, 50 feet.',
                        image: ''
                    },
                    {
                        name: 'Torch',
                        type: 'gear',
                        value: 0.01,
                        weight: 1,
                        description: 'Provides bright light in 20-foot radius.',
                        image: ''
                    },
                    {
                        name: 'Rations (1 day)',
                        type: 'gear',
                        value: 0.5,
                        weight: 2,
                        description: 'Food for one day.',
                        consumable: true,
                        image: ''
                    }
                ],
                equipment: [
                    {
                        name: 'Leather Armor',
                        type: 'armor',
                        armorType: 'light',
                        ac: 11,
                        maxDexBonus: null,
                        stealthDisadvantage: false,
                        weight: 10,
                        value: 10,
                        equipSlot: 'armor',
                        description: 'Light armor. AC = 11 + Dex modifier.',
                        image: ''
                    },
                    {
                        name: 'Studded Leather',
                        type: 'armor',
                        armorType: 'light',
                        ac: 12,
                        maxDexBonus: null,
                        stealthDisadvantage: false,
                        weight: 13,
                        value: 45,
                        equipSlot: 'armor',
                        description: 'Light armor. AC = 12 + Dex modifier.',
                        image: ''
                    },
                    {
                        name: 'Chain Shirt',
                        type: 'armor',
                        armorType: 'medium',
                        ac: 13,
                        maxDexBonus: 2,
                        stealthDisadvantage: false,
                        weight: 20,
                        value: 50,
                        equipSlot: 'armor',
                        description: 'Medium armor. AC = 13 + Dex modifier (max 2).',
                        image: ''
                    },
                    {
                        name: 'Scale Mail',
                        type: 'armor',
                        armorType: 'medium',
                        ac: 14,
                        maxDexBonus: 2,
                        stealthDisadvantage: true,
                        weight: 45,
                        value: 50,
                        equipSlot: 'armor',
                        description: 'Medium armor. AC = 14 + Dex modifier (max 2). Disadvantage on Stealth.',
                        image: ''
                    },
                    {
                        name: 'Chain Mail',
                        type: 'armor',
                        armorType: 'heavy',
                        ac: 16,
                        maxDexBonus: 0,
                        stealthDisadvantage: true,
                        strengthRequired: 13,
                        weight: 55,
                        value: 75,
                        equipSlot: 'armor',
                        description: 'Heavy armor. AC = 16. Requires Str 13. Disadvantage on Stealth.',
                        image: ''
                    },
                    {
                        name: 'Plate Armor',
                        type: 'armor',
                        armorType: 'heavy',
                        ac: 18,
                        maxDexBonus: 0,
                        stealthDisadvantage: true,
                        strengthRequired: 15,
                        weight: 65,
                        value: 1500,
                        equipSlot: 'armor',
                        description: 'Heavy armor. AC = 18. Requires Str 15. Disadvantage on Stealth.',
                        image: ''
                    },
                    {
                        name: 'Shield',
                        type: 'shield',
                        ac: 2,
                        weight: 6,
                        value: 10,
                        equipSlot: 'offHand',
                        description: 'Provides +2 AC when equipped.',
                        image: ''
                    },
                    {
                        name: 'Ring of Protection',
                        type: 'ring',
                        rarity: 'rare',
                        ac: 1,
                        savingThrowBonus: 1,
                        value: 3500,
                        weight: 0,
                        equipSlot: 'ring1',
                        description: '+1 to AC and saving throws.',
                        image: ''
                    },
                    {
                        name: 'Cloak of Elvenkind',
                        type: 'cloak',
                        rarity: 'uncommon',
                        value: 500,
                        weight: 1,
                        equipSlot: 'cloak',
                        effect: {type: 'advantage', skill: 'stealth'},
                        description: 'Advantage on Stealth checks.',
                        image: ''
                    },
                    {
                        name: 'Boots of Speed',
                        type: 'boots',
                        rarity: 'rare',
                        value: 4000,
                        weight: 1,
                        equipSlot: 'boots',
                        effect: {type: 'speed', bonus: 10},
                        description: 'Double speed for 10 minutes per day.',
                        image: ''
                    },
                    {
                        name: 'Amulet of Health',
                        type: 'amulet',
                        rarity: 'rare',
                        value: 8000,
                        weight: 1,
                        equipSlot: 'amulet',
                        effect: {type: 'ability_score', ability: 'con', value: 19},
                        description: 'Constitution score is 19 while worn.',
                        image: ''
                    },
                    {
                        name: 'Gauntlets of Ogre Power',
                        type: 'gloves',
                        rarity: 'uncommon',
                        value: 8000,
                        weight: 4,
                        equipSlot: 'gloves',
                        effect: {type: 'ability_score', ability: 'str', value: 19},
                        description: 'Strength score is 19 while worn.',
                        image: ''
                    }
                ],
                players: []
            },
            
            // Skills list for D&D 5e
            skillsList: {
                acrobatics: 'dex',
                animalHandling: 'wis',
                arcana: 'int',
                athletics: 'str',
                deception: 'cha',
                history: 'int',
                insight: 'wis',
                intimidation: 'cha',
                investigation: 'int',
                medicine: 'wis',
                nature: 'int',
                perception: 'wis',
                performance: 'cha',
                persuasion: 'cha',
                religion: 'int',
                sleightOfHand: 'dex',
                stealth: 'dex',
                survival: 'wis'
            },
            
            // D&D 5e Classes and Races
            classList: [
                'Artificer', 'Barbarian', 'Bard', 'Cleric', 'Druid', 'Fighter', 
                'Monk', 'Paladin', 'Ranger', 'Rogue', 'Sorcerer', 'Warlock', 'Wizard', 'Custom'
            ],
            
            raceList: [
                'Dragonborn', 'Dwarf', 'Elf', 'Gnome', 'Half-Elf', 'Half-Orc', 
                'Halfling', 'Human', 'Tiefling', 'Aarakocra', 'Aasimar', 'Bugbear',
                'Firbolg', 'Genasi', 'Githyanki', 'Githzerai', 'Goblin', 'Goliath',
                'Hobgoblin', 'Kenku', 'Kobold', 'Lizardfolk', 'Orc', 'Tabaxi',
                'Tortle', 'Triton', 'Yuan-ti Pureblood', 'Custom'
            ],
            
            // All D&D 5e Conditions
            conditions: {
                blinded: {
                    description: 'Cannot see. Auto-fail sight checks. Disadvantage on attacks. Advantage on attacks against.',
                    effects: {attackDisadvantage: true, defenseAdvantage: true}
                },
                charmed: {
                    description: 'Cannot attack charmer. Charmer has advantage on social checks.',
                    effects: {}
                },
                deafened: {
                    description: 'Cannot hear. Auto-fail hearing checks.',
                    effects: {}
                },
                exhaustion: {
                    description: 'Multiple levels with cumulative effects.',
                    levels: [
                        'Disadvantage on ability checks',
                        'Speed halved',
                        'Disadvantage on attacks and saves',
                        'HP maximum halved',
                        'Speed reduced to 0',
                        'Death'
                    ]
                },
                frightened: {
                    description: 'Disadvantage on ability checks and attacks while source in sight. Cannot willingly move closer.',
                    effects: {attackDisadvantage: true}
                },
                grappled: {
                    description: 'Speed becomes 0. Ends if grappler incapacitated.',
                    effects: {speed: 0}
                },
                incapacitated: {
                    description: 'Cannot take actions or reactions.',
                    effects: {noActions: true, noReactions: true}
                },
                invisible: {
                    description: 'Cannot be seen. Advantage on attacks. Disadvantage on attacks against.',
                    effects: {attackAdvantage: true, defenseDisadvantage: true}
                },
                paralyzed: {
                    description: 'Incapacitated, cannot move or speak. Auto-fail Str and Dex saves. Attacks have advantage. Hits within 5ft are crits.',
                    effects: {noActions: true, noReactions: true, speed: 0, attackDisadvantage: true, defenseAdvantage: true, autoFailSaves: ['str', 'dex']}
                },
                petrified: {
                    description: 'Transformed to stone. Incapacitated. Resistance to all damage. Immune to poison and disease.',
                    effects: {noActions: true, noReactions: true, speed: 0, damageResistance: 'all', immunities: ['poison', 'disease']}
                },
                poisoned: {
                    description: 'Disadvantage on attack rolls and ability checks.',
                    effects: {attackDisadvantage: true, checkDisadvantage: true}
                },
                prone: {
                    description: 'Disadvantage on attacks. Attacks within 5ft have advantage, beyond have disadvantage. Half movement to stand.',
                    effects: {attackDisadvantage: true, meleeDefenseAdvantage: true, rangedDefenseDisadvantage: true}
                },
                restrained: {
                    description: 'Speed 0. Disadvantage on attacks and Dex saves. Advantage on attacks against.',
                    effects: {speed: 0, attackDisadvantage: true, defenseAdvantage: true, saveDisadvantage: ['dex']}
                },
                stunned: {
                    description: 'Incapacitated, cannot move, speak falteringly. Auto-fail Str and Dex saves. Attacks have advantage.',
                    effects: {noActions: true, noReactions: true, speed: 0, defenseAdvantage: true, autoFailSaves: ['str', 'dex']}
                },
                unconscious: {
                    description: 'Incapacitated, cannot move or speak, unaware. Drop items, fall prone. Auto-fail Str and Dex saves. Attacks have advantage. Hits within 5ft are crits.',
                    effects: {noActions: true, noReactions: true, speed: 0, prone: true, defenseAdvantage: true, autoFailSaves: ['str', 'dex'], meleeCritical: true}
                }
            },
            
            // Initialize the game
            init() {
                this.loadGameState();
                this.loadLibrary();
                this.loadSounds();
                this.loadSavedBackgrounds();
                this.setupDrawingCanvas();
                this.setupEventListeners();
                this.setupQuickAdd();
                this.populateLibrarySidebar(); // Initialize sidebar content
                this.render();
                this.updateTurnOrder();
                
                // Add starting entities if none exist
                if (this.entities.length === 0) {
                    this.entities.push(this.createEntity('player', 'Fighter', 200, 300));
                    this.entities.push(this.createEntity('monster', 'Goblin', 500, 300));
                    this.render();
                }
            },
            
            // Library Sidebar Functions
            toggleLibrarySidebar() {
                this.librarySidebarOpen = !this.librarySidebarOpen;
                const sidebar = document.getElementById('expandableLibrarySidebar');
                const toggle = document.getElementById('libraryToggle');
                
                if (this.librarySidebarOpen) {
                    sidebar.classList.add('open');
                    toggle.style.right = '400px';
                    this.populateLibrarySidebar();
                } else {
                    sidebar.classList.remove('open');
                    toggle.style.right = '0px';
                }
            },
            
            populateLibrarySidebar() {
                const grid = document.getElementById('sidebarLibraryGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                // Ensure all library arrays exist before mapping
                const monsters = this.library.monsters || [];
                const players = this.library.players || [];
                const spells = this.library.spells || [];
                const items = this.library.items || [];
                const equipment = this.library.equipment || [];
                
                const all = [
                    ...monsters.map(m => ({...m, category: 'monster'})),
                    ...players.map(p => ({...p, category: 'player'})),
                    ...spells.map(s => ({...s, category: 'spell'})),
                    ...items.map(i => ({...i, category: 'item'})),
                    ...equipment.map(e => ({...e, category: 'equipment'}))
                ];
                
                all.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'content-card';
                    card.dataset.type = item.category;
                    card.dataset.name = item.name.toLowerCase();
                    
                    let html = `<h4 style="color: #fbbf24; font-size: 14px; margin-bottom: 8px;">${item.name}</h4>`;
                    
                    if (item.category === 'monster' || item.category === 'player') {
                        html += `<p style="font-size: 11px; color: #9ca3af;">HP: ${item.hp}/${item.maxHp} | AC: ${item.ac}</p>`;
                        if (item.cr) html += `<p style="font-size: 10px; color: #6b7280;">CR: ${item.cr}</p>`;
                    } else if (item.category === 'spell') {
                        html += `<p style="font-size: 11px; color: #9ca3af;">Level ${item.level} ${item.school}</p>`;
                        if (item.damage) html += `<p style="font-size: 10px; color: #6b7280;">Damage: ${item.damage}</p>`;
                        if (item.healing) html += `<p style="font-size: 10px; color: #6b7280;">Healing: ${item.healing}</p>`;
                    } else if (item.category === 'item' || item.category === 'equipment') {
                        if (item.damage) html += `<p style="font-size: 10px; color: #6b7280;">Damage: ${item.damage}</p>`;
                        if (item.ac) html += `<p style="font-size: 10px; color: #6b7280;">AC: ${item.ac}</p>`;
                        if (item.healing) html += `<p style="font-size: 10px; color: #6b7280;">Healing: ${item.healing}</p>`;
                    }
                    
                    html += `<button class="btn btn-small btn-primary" style="width: 100%; margin-top: 8px; padding: 4px 8px; font-size: 10px;" onclick="game.addFromLibrarySidebar('${item.name}', '${item.category}')">Add to Board</button>`;
                    
                    card.innerHTML = html;
                    grid.appendChild(card);
                });
            },
            
            addFromLibrarySidebar(name, category) {
                this.addFromLibrary(name, category);
                // Keep sidebar open but switch to combat tab
                switchTab({target: document.querySelector('.tab[onclick*="combat"]')}, 'combat');
            },
            
            filterSidebarLibrary(filterType) {
                const cards = document.querySelectorAll('#sidebarLibraryGrid .content-card');
                cards.forEach(card => {
                    if (filterType === 'all' || card.dataset.type === filterType) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
            
            searchSidebarLibrary(searchTerm) {
                const cards = document.querySelectorAll('#sidebarLibraryGrid .content-card');
                const term = searchTerm.toLowerCase();
                
                cards.forEach(card => {
                    if (card.dataset.name.includes(term)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
            
            // Setup Drawing Canvas
            setupDrawingCanvas() {
                this.drawingCanvas = document.getElementById('drawingCanvas');
                this.drawingCtx = this.drawingCanvas.getContext('2d');
                
                const resizeCanvas = () => {
                    const board = document.getElementById('gameBoard');
                    this.drawingCanvas.width = board.offsetWidth;
                    this.drawingCanvas.height = board.offsetHeight;
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // Drawing event listeners
                this.drawingCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.drawingCanvas.addEventListener('mousemove', (e) => this.draw(e));
                this.drawingCanvas.addEventListener('mouseup', () => this.stopDrawing());
                this.drawingCanvas.addEventListener('mouseout', () => this.stopDrawing());
            },
            
            // Drawing Functions
            startDrawing(e) {
                if (!this.drawMode) return;
                
                const rect = this.drawingCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.isDrawing = true;
                this.lastDrawX = x;
                this.lastDrawY = y;
                
                if (this.eraseMode) {
                    this.drawingCtx.globalCompositeOperation = 'destination-out';
                    this.drawingCtx.lineWidth = 20;
                } else {
                    this.drawingCtx.globalCompositeOperation = 'source-over';
                    this.drawingCtx.strokeStyle = '#fbbf24';
                    this.drawingCtx.lineWidth = 3;
                }
                
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(x, y);
            },
            
            draw(e) {
                if (!this.isDrawing || !this.drawMode) return;
                
                const rect = this.drawingCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.eraseMode) {
                    this.drawingCtx.globalCompositeOperation = 'destination-out';
                    this.drawingCtx.lineWidth = 20;
                } else {
                    this.drawingCtx.globalCompositeOperation = 'source-over';
                    this.drawingCtx.strokeStyle = '#fbbf24';
                    this.drawingCtx.lineWidth = 3;
                }
                
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(this.lastDrawX, this.lastDrawY);
                this.drawingCtx.lineTo(x, y);
                this.drawingCtx.stroke();
                
                this.lastDrawX = x;
                this.lastDrawY = y;
            },
            
            stopDrawing() {
                this.isDrawing = false;
            },
            
            toggleDrawMode() {
                this.drawMode = !this.drawMode;
                const btn = document.getElementById('drawToggle');
                const canvas = document.getElementById('drawingCanvas');
                
                btn.classList.toggle('active', this.drawMode);
                canvas.classList.toggle('drawing-mode', this.drawMode);
                
                if (this.drawMode) {
                    this.eraseMode = false;
                    document.getElementById('eraseToggle').classList.remove('active');
                }
                
                this.addLog(`Draw mode ${this.drawMode ? 'enabled' : 'disabled'}`, 'info');
            },
            
            toggleEraseMode() {
                this.eraseMode = !this.eraseMode;
                const btn = document.getElementById('eraseToggle');
                btn.classList.toggle('active', this.eraseMode);
                
                if (this.eraseMode && !this.drawMode) {
                    this.toggleDrawMode();
                }
                
                this.addLog(`Erase mode ${this.eraseMode ? 'enabled' : 'disabled'}`, 'info');
            },
            
            clearDrawing() {
                console.log('clearDrawing function called');
                if (confirm('Clear all drawings?')) {
                    const canvas = document.getElementById('drawingCanvas');
                    console.log('Canvas found:', canvas);
                    if (canvas) {
                        console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                        const ctx = canvas.getContext('2d');
                        console.log('Context:', ctx);
                        
                        // Try multiple clearing methods
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'rgba(0,0,0,0)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Reset canvas completely
                        const parent = canvas.parentNode;
                        const newCanvas = document.createElement('canvas');
                        newCanvas.id = 'drawingCanvas';
                        newCanvas.className = canvas.className;
                        newCanvas.width = canvas.width;
                        newCanvas.height = canvas.height;
                        
                        parent.replaceChild(newCanvas, canvas);
                        
                        // Reinitialize drawing on new canvas
                        this.drawingCanvas = newCanvas;
                        this.drawingCtx = newCanvas.getContext('2d');
                        
                        // Re-add event listeners
                        this.drawingCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                        this.drawingCanvas.addEventListener('mousemove', (e) => this.draw(e));
                        this.drawingCanvas.addEventListener('mouseup', () => this.stopDrawing());
                        this.drawingCanvas.addEventListener('mouseout', () => this.stopDrawing());
                        
                        this.addLog('Drawing cleared', 'info');
                        console.log('Drawing cleared successfully');
                    } else {
                        this.addLog('Drawing canvas not found', 'info');
                        console.log('Canvas not found!');
                    }
                }
            },
            

            
            // Create Entity with full D&D 5e stats
            createEntity(type, name, x, y) {
                const entity = {
                    id: this.nextId++,
                    type: type,
                    name: name,
                    x: x,
                    y: y,
                    hp: 10,
                    maxHp: 10,
                    tempHp: 0,
                    ac: 10,
                    speed: 30,
                    initiative: 0,
                    str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10,
                    proficiencyBonus: 2,
                    color: type === 'player' ? '#3b82f6' : (type === 'monster' ? '#ef4444' : '#fbbf24'),
                    image: '',
                    attacks: [],
                    spells: [],
                    spellSlots: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0},
                    spellSlotsUsed: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0},
                    inventory: [],
                    equipment: {
                        armor: null,
                        mainHand: null,
                        offHand: null,
                        helmet: null,
                        boots: null,
                        gloves: null,
                        amulet: null,
                        cloak: null,
                        ring1: null,
                        ring2: null
                    },
                    conditions: [],
                    savingThrows: {str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0},
                    skills: {},
                    damageResistances: [],
                    damageImmunities: [],
                    damageVulnerabilities: [],
                    conditionImmunities: [],
                    deathSaves: {successes: 0, failures: 0},
                    concentrating: null,
                    movement: 30,
                    actionUsed: false,
                    bonusActionUsed: false,
                    reactionUsed: false,
                    class: 'Fighter',
                    race: 'Human',
                    level: 1,
                    hitDice: '1d10',
                    hitDiceRemaining: 1
                };
                
                if (type === 'player') {
                    entity.level = 1;
                    entity.class = 'Fighter';
                    entity.race = 'Human';
                    entity.hitDice = '1d10';
                    entity.hitDiceRemaining = 1;
                    // Set spell slots based on class
                    entity.spellSlots = {1: 2, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0};
                }
                
                // Apply template if exists
                if (type === 'monster') {
                    const template = this.library.monsters.find(m => m.name === name);
                    if (template) {
                        Object.assign(entity, JSON.parse(JSON.stringify(template)));
                        entity.id = this.nextId - 1;
                        entity.x = x;
                        entity.y = y;
                    }
                } else if (type === 'npc') {
                    // NPCs are like monsters but non-hostile by default
                    entity.color = '#10b981';
                    entity.isHostile = false;
                    entity.hp = 5;
                    entity.maxHp = 5;
                    entity.ac = 12;
                } else if (type === 'item' || type === 'container') {
                    let template = this.library.items.find(i => i.name === name);
                    if (!template) {
                        template = this.library.equipment.find(e => e.name === name);
                    }
                    if (template) {
                        Object.assign(entity, JSON.parse(JSON.stringify(template)));
                        entity.id = this.nextId - 1;
                        entity.x = x;
                        entity.y = y;
                    }
                    if (type === 'container') {
                        entity.inventory = entity.inventory || [];
                        entity.color = '#8b5a2b';
                    }
                }
                
                return entity;
            },
            
            // Get Ability Modifier
            getAbilityModifier(score) {
                return Math.floor((score - 10) / 2);
            },
            
            // Calculate Total AC
            calculateAC(entity) {
                let baseAC = 10;
                let dexMod = this.getAbilityModifier(entity.dex);
                
                if (entity.equipment.armor) {
                    const armor = entity.equipment.armor;
                    baseAC = armor.ac;
                    
                    if (armor.maxDexBonus !== null && armor.maxDexBonus !== undefined) {
                        dexMod = Math.min(dexMod, armor.maxDexBonus);
                    } else if (armor.maxDexBonus === 0) {
                        dexMod = 0;
                    }
                } else {
                    // Unarmored defense
                    baseAC = 10 + dexMod;
                }
                
                // Add shield
                if (entity.equipment.offHand && entity.equipment.offHand.type === 'shield') {
                    baseAC += entity.equipment.offHand.ac;
                }
                
                // Add other bonuses
                Object.values(entity.equipment).forEach(item => {
                    if (item && item.ac && item.type !== 'armor' && item.type !== 'shield') {
                        baseAC += item.ac;
                    }
                });
                
                return baseAC;
            },
            
            // Roll Initiative
            rollInitiative() {
                this.entities.forEach(entity => {
                    if (entity.type !== 'item' && entity.type !== 'container') {
                        const dexMod = this.getAbilityModifier(entity.dex);
                        const roll = this.rollDice('1d20');
                        entity.initiative = roll + dexMod;
                        
                        // Tiebreaker is dexterity score
                        entity.initiativeTiebreaker = entity.dex;
                    }
                });
                
                this.updateTurnOrder();
                this.currentTurn = 0;
                this.roundNumber = 1;
                this.resetTurnActions();
                this.addLog('üé≤ Initiative rolled! Round 1 begins!', 'info');
            },
            
            // Update Turn Order with proper tiebreaking
            updateTurnOrder() {
                this.turnOrder = this.entities
                    .filter(e => (e.type === 'player' || e.type === 'monster' || e.type === 'npc') && e.hp > 0)
                    .sort((a, b) => {
                        if (b.initiative !== a.initiative) {
                            return b.initiative - a.initiative;
                        }
                        return b.initiativeTiebreaker - a.initiativeTiebreaker;
                    });
                
                const div = document.getElementById('turnOrder');
                if (!div) return;
                
                div.innerHTML = '';
                this.turnOrder.forEach((entity, i) => {
                    const item = document.createElement('div');
                    item.className = `turn-item ${i === this.currentTurn ? 'active' : ''}`;
                    item.innerHTML = `
                        <span style="color: ${entity.color};">${entity.name}</span>
                        <div>
                            <span>Init: ${entity.initiative}</span>
                            <div class="turn-actions">
                                ${i === this.currentTurn ? this.getTurnActionsDisplay(entity) : ''}
                            </div>
                        </div>
                    `;
                    div.appendChild(item);
                });
            },
            
            // Get Turn Actions Display
            getTurnActionsDisplay(entity) {
                if (entity.type !== 'player' && entity.type !== 'monster' && entity.type !== 'npc') return '';
                
                return `
                    ${!entity.actionUsed ? '‚öîÔ∏è' : ''}
                    ${!entity.bonusActionUsed ? '‚ö°' : ''}
                    ${!entity.reactionUsed ? 'üõ°Ô∏è' : ''}
                    ${entity.movement > 0 ? `üë£${entity.movement}ft` : ''}
                `;
            },
            
            // Reset Turn Actions
            resetTurnActions() {
                if (this.turnOrder.length === 0) return;
                
                const current = this.turnOrder[this.currentTurn];
                if (current) {
                    current.actionUsed = false;
                    current.bonusActionUsed = false;
                    current.movement = current.speed;
                }
            },
            
            // Next Turn
            nextTurn() {
                if (this.turnOrder.length === 0) return;
                
                // Handle end of turn effects
                const current = this.turnOrder[this.currentTurn];
                if (current) {
                    this.handleEndOfTurn(current);
                }
                
                // Move to next
                this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
                
                // Check for new round
                if (this.currentTurn === 0) {
                    this.roundNumber++;
                    this.addLog(`üìú Round ${this.roundNumber} begins!`, 'info');
                    
                    // Reset reactions for all
                    this.entities.forEach(e => {
                        if (e.type === 'player' || e.type === 'monster' || e.type === 'npc') {
                            e.reactionUsed = false;
                        }
                    });
                }
                
                // Skip dead/unconscious
                while (this.turnOrder[this.currentTurn] && 
                       (this.turnOrder[this.currentTurn].hp <= 0 || 
                        this.turnOrder[this.currentTurn].conditions.includes('unconscious'))) {
                    if (this.turnOrder.every(e => e.hp <= 0 || e.conditions.includes('unconscious'))) {
                        this.addLog('Combat ended - no active combatants!', 'info');
                        return;
                    }
                    this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
                }
                
                const newCurrent = this.turnOrder[this.currentTurn];
                if (newCurrent) {
                    this.resetTurnActions();
                    this.handleStartOfTurn(newCurrent);
                    this.addLog(`‚û°Ô∏è ${newCurrent.name}'s turn begins!`, 'info');
                }
                
                this.updateTurnOrder();
                this.render();
            },
            
            // End Current Turn
            endTurn() {
                this.nextTurn();
            },
            
            // Handle Start of Turn
            handleStartOfTurn(entity) {
                // Regeneration
                if (entity.abilities) {
                    const regen = entity.abilities.find(a => a.name === 'Regeneration');
                    if (regen && entity.hp > 0 && entity.hp < entity.maxHp) {
                        const healing = 10; // Standard troll regen
                        entity.hp = Math.min(entity.maxHp, entity.hp + healing);
                        this.addLog(`${entity.name} regenerates ${healing} HP!`, 'heal');
                        this.createFloatingText(`+${healing}`, entity.x, entity.y - 30, '#00ff00');
                        this.playSound('heal');
                    }
                }
                
                // Death saves
                if (entity.hp === 0 && !entity.conditions.includes('stable')) {
                    this.rollDeathSave(entity);
                }
            },
            
            // Handle End of Turn
            handleEndOfTurn(entity) {
                // Nothing specific yet, but ready for concentration checks, etc.
            },
            
            // Roll Death Save
            rollDeathSave(entity) {
                const roll = this.rollDice('1d20');
                
                if (roll === 1) {
                    entity.deathSaves.failures += 2;
                    this.addLog(`${entity.name} critically fails death save! (${roll})`, 'death');
                } else if (roll === 20) {
                    entity.hp = 1;
                    entity.deathSaves.successes = 0;
                    entity.deathSaves.failures = 0;
                    this.addLog(`${entity.name} critically succeeds death save and regains consciousness with 1 HP!`, 'heal');
                } else if (roll >= 10) {
                    entity.deathSaves.successes++;
                    this.addLog(`${entity.name} succeeds death save (${roll}). Successes: ${entity.deathSaves.successes}/3`, 'save');
                } else {
                    entity.deathSaves.failures++;
                    this.addLog(`${entity.name} fails death save (${roll}). Failures: ${entity.deathSaves.failures}/3`, 'death');
                }
                
                if (entity.deathSaves.successes >= 3) {
                    entity.conditions.push('stable');
                    entity.deathSaves.successes = 0;
                    entity.deathSaves.failures = 0;
                    this.addLog(`${entity.name} is stabilized!`, 'heal');
                } else if (entity.deathSaves.failures >= 3) {
                    entity.conditions.push('dead');
                    this.addLog(`${entity.name} has died!`, 'death');
                }
                
                this.render();
            },
            
            // Perform Attack
            performAttack(attacker, target, attack) {
                if (attacker.id === target.id) {
                    this.addLog('Cannot target self!', 'info');
                    return;
                }
                
                // Check if attacker can act
                if (this.enforceTurns && !this.editMode && this.turnOrder[this.currentTurn]?.id !== attacker.id) {
                    this.addLog('Not your turn!', 'info');
                    return;
                }
                
                if (attacker.actionUsed && !attack.bonusAction) {
                    this.addLog(`${attacker.name} has already used their action!`, 'info');
                    return;
                }
                
                // Roll to hit
                const d20 = this.rollDice('1d20', true);
                const profBonus = attacker.proficiencyBonus || 2;
                const abilityMod = attack.finesse ? 
                    Math.max(this.getAbilityModifier(attacker.str), this.getAbilityModifier(attacker.dex)) :
                    this.getAbilityModifier(attack.ranged ? attacker.dex : attacker.str);
                
                let toHitBonus = (attack.toHit !== undefined) ? attack.toHit : abilityMod + profBonus;
                
                // Add equipment bonuses
                if (attacker.equipment.mainHand && attacker.equipment.mainHand.attackBonus) {
                    toHitBonus += attacker.equipment.mainHand.attackBonus;
                }
                
                // Check for advantage/disadvantage
                let hasAdvantage = false;
                let hasDisadvantage = false;
                
                if (attacker.conditions.includes('invisible')) hasAdvantage = true;
                if (attacker.conditions.includes('poisoned')) hasDisadvantage = true;
                if (attacker.conditions.includes('frightened')) hasDisadvantage = true;
                if (target.conditions.includes('paralyzed')) hasAdvantage = true;
                if (target.conditions.includes('stunned')) hasAdvantage = true;
                if (target.conditions.includes('unconscious')) hasAdvantage = true;
                
                let roll = d20;
                if (hasAdvantage && !hasDisadvantage) {
                    const second = this.rollDice('1d20', true);
                    roll = Math.max(d20, second);
                    this.showRollResult(`Attack Roll (Advantage)`, `${roll} (${d20}, ${second}) + ${toHitBonus} = ${roll + toHitBonus}`);
                } else if (hasDisadvantage && !hasAdvantage) {
                    const second = this.rollDice('1d20', true);
                    roll = Math.min(d20, second);
                    this.showRollResult(`Attack Roll (Disadvantage)`, `${roll} (${d20}, ${second}) + ${toHitBonus} = ${roll + toHitBonus}`);
                } else {
                    this.showRollResult(`Attack Roll`, `${roll} + ${toHitBonus} = ${roll + toHitBonus}`);
                }
                
                const totalHit = roll + toHitBonus;
                const targetAC = this.calculateAC(target);
                
                if (roll === 1) {
                    this.addLog(`${attacker.name} critically misses ${target.name}!`, 'info');
                    this.createFloatingText('CRITICAL MISS!', target.x, target.y - 30, '#808080');
                } else if (roll === 20 || totalHit >= targetAC) {
                    // Calculate damage
                    let damage = this.rollDice(attack.damage);
                    
                    if (roll === 20) {
                        damage *= 2;
                        this.addLog(`üí• ${attacker.name} CRITICALLY HITS ${target.name} for ${damage} ${attack.damageType} damage!`, 'damage');
                    } else {
                        this.addLog(`‚öîÔ∏è ${attacker.name} hits ${target.name} for ${damage} ${attack.damageType} damage!`, 'damage');
                    }
                    
                    // Apply damage
                    this.dealDamage(target, damage, attack.damageType);
                    this.createFloatingText(`-${damage}`, target.x, target.y - 30, '#ff0000');
                    
                    // Special effects
                    if (attack.special) {
                        this.applySpecialAttackEffect(target, attack.special);
                    }
                    this.playSound('attack');
                } else {
                    this.addLog(`${attacker.name} misses ${target.name}! (${totalHit} vs AC ${targetAC})`, 'info');
                    this.createFloatingText('MISS', target.x, target.y - 30, '#808080');
                }
                
                // Mark action used
                if (!attack.bonusAction) {
                    attacker.actionUsed = true;
                } else {
                    attacker.bonusActionUsed = true;
                }
                
                // Animation
                this.createPersistentArrow(attacker.x + 35, attacker.y + 35, target.x + 35, target.y + 35);
                setTimeout(() => this.createArrowAnimation(attacker.x + 35, attacker.y + 35, target.x + 35, target.y + 35), 100);
                
                this.updateTurnOrder();
                this.render();
            },
            
            // Apply Special Attack Effect
            applySpecialAttackEffect(target, special) {
                // Parse special effects like "DC 13 Str save or knocked prone"
                if (special.includes('save')) {
                    const dcMatch = special.match(/DC (\d+)/);
                    const saveMatch = special.match(/(Str|Dex|Con|Int|Wis|Cha)/i);
                    
                    if (dcMatch && saveMatch) {
                        const dc = parseInt(dcMatch[1]);
                        const ability = saveMatch[1].toLowerCase();
                        const mod = this.getAbilityModifier(target[ability]);
                        const roll = this.rollDice('1d20');
                        const total = roll + mod;
                        
                        if (total < dc) {
                            if (special.includes('prone')) {
                                this.addCondition(target, 'prone');
                                this.addLog(`${target.name} is knocked prone! (Save: ${total} vs DC ${dc})`, 'info');
                            } else if (special.includes('poison')) {
                                const poisonDamage = this.rollDice('2d8');
                                this.dealDamage(target, poisonDamage, 'poison');
                                this.addLog(`${target.name} takes ${poisonDamage} poison damage! (Save: ${total} vs DC ${dc})`, 'damage');
                            }
                        } else {
                            this.addLog(`${target.name} resists the effect! (Save: ${total} vs DC ${dc})`, 'info');
                        }
                    }
                }
            },
            
            // Deal Damage (with resistances/immunities/vulnerabilities)
            dealDamage(target, amount, damageType) {
                let finalDamage = amount;
                
                // Check immunities
                if (target.damageImmunities && target.damageImmunities.includes(damageType)) {
                    this.addLog(`${target.name} is immune to ${damageType} damage!`, 'info');
                    return;
                }
                
                // Check resistances
                if (target.damageResistances && target.damageResistances.includes(damageType)) {
                    finalDamage = Math.floor(finalDamage / 2);
                    this.addLog(`${target.name} resists ${damageType} damage!`, 'info');
                }
                
                // Check vulnerabilities
                if (target.damageVulnerabilities && target.damageVulnerabilities.includes(damageType)) {
                    finalDamage = finalDamage * 2;
                    this.addLog(`${target.name} is vulnerable to ${damageType} damage!`, 'info');
                }
                
                // Apply to temp HP first
                if (target.tempHp > 0) {
                    const tempDamage = Math.min(target.tempHp, finalDamage);
                    target.tempHp -= tempDamage;
                    finalDamage -= tempDamage;
                }
                
                // Then regular HP
                target.hp = Math.max(0, target.hp - finalDamage);
                
                // Check for death/unconscious
                if (target.hp === 0) {
                    if (target.type === 'player') {
                        if (!target.conditions.includes('unconscious')) {
                            this.addCondition(target, 'unconscious');
                            this.addLog(`${target.name} falls unconscious!`, 'death');
                        }
                    } else {
                        this.addCondition(target, 'dead');
                        this.addLog(`${target.name} is defeated!`, 'death');
                    }
                }
            },
            
            // Cast Spell
            castSpell(caster, target, spell, spellLevel = null) {
                if (caster.id === target.id && spell.name !== 'Shield' && spell.name !== 'Misty Step') {
                    this.addLog('Cannot target self with this spell!', 'info');
                    return;
                }
                
                // Check spell slots
                const actualLevel = spellLevel || spell.level;
                if (spell.level > 0) {
                    if (!caster.spellSlots || caster.spellSlots[actualLevel] <= caster.spellSlotsUsed[actualLevel]) {
                        this.addLog(`${caster.name} has no level ${actualLevel} spell slots remaining!`, 'info');
                        return;
                    }
                }
                
                // Check action economy
                if (spell.castingTime === 'action' && caster.actionUsed) {
                    this.addLog(`${caster.name} has already used their action!`, 'info');
                    return;
                } else if (spell.castingTime === 'bonus action' && caster.bonusActionUsed) {
                    this.addLog(`${caster.name} has already used their bonus action!`, 'info');
                    return;
                } else if (spell.castingTime === 'reaction' && caster.reactionUsed) {
                    this.addLog(`${caster.name} has already used their reaction!`, 'info');
                    return;
                }
                
                // Cast the spell
                this.addLog(`‚ú® ${caster.name} casts ${spell.name}${actualLevel > spell.level ? ` at level ${actualLevel}` : ''}!`, 'info');
                this.playSound('spell');
                
                // Use spell slot
                if (spell.level > 0) {
                    caster.spellSlotsUsed[actualLevel]++;
                }
                
                // Handle concentration
                if (spell.concentration) {
                    if (caster.concentrating) {
                        this.addLog(`${caster.name} loses concentration on ${caster.concentrating}`, 'info');
                    }
                    caster.concentrating = spell.name;
                }
                
                // Apply spell effects
                if (spell.damage) {
                    let damage = this.rollDice(spell.damage);
                    
                    // Higher level casting
                    if (actualLevel > spell.level && spell.higherLevel) {
                        const extraLevels = actualLevel - spell.level;
                        const extraDamage = this.rollDice(`${extraLevels}d6`);
                        damage += extraDamage;
                    }
                    
                    if (spell.savingThrow) {
                        const saveMod = this.getAbilityModifier(target[spell.savingThrow.substr(0, 3)]);
                        const saveRoll = this.rollDice('1d20');
                        const saveTotal = saveRoll + saveMod;
                        
                        if (saveTotal >= spell.saveDC) {
                            damage = Math.floor(damage / 2);
                            this.addLog(`${target.name} saves! (${saveTotal} vs DC ${spell.saveDC}) Half damage.`, 'save');
                        } else {
                            this.addLog(`${target.name} fails save! (${saveTotal} vs DC ${spell.saveDC})`, 'save');
                        }
                    }
                    
                    this.dealDamage(target, damage, spell.damageType);
                    this.createFloatingText(`-${damage}`, target.x, target.y - 30, '#ff00ff');
                } else if (spell.healing) {
                    let healing = this.rollDice(spell.healing.replace('mod', '3'));
                    
                    // Higher level casting
                    if (actualLevel > spell.level && spell.higherLevel) {
                        const extraLevels = actualLevel - spell.level;
                        const extraHealing = this.rollDice(`${extraLevels}d8`);
                        healing += extraHealing;
                    }
                    
                    target.hp = Math.min(target.maxHp, target.hp + healing);
                    this.addLog(`${target.name} heals ${healing} HP!`, 'heal');
                    this.createFloatingText(`+${healing}`, target.x, target.y - 30, '#00ff00');
                    this.playSound('heal');
                } else if (spell.effect) {
                    this.applySpellEffect(caster, target, spell.effect, spell);
                }
                
                // Mark action used
                if (spell.castingTime === 'action') caster.actionUsed = true;
                else if (spell.castingTime === 'bonus action') caster.bonusActionUsed = true;
                else if (spell.castingTime === 'reaction') caster.reactionUsed = true;
                
                // Animation
                this.createPersistentArrow(caster.x + 35, caster.y + 35, target.x + 35, target.y + 35);
                setTimeout(() => this.createSpellAnimation(caster.x + 35, caster.y + 35, target.x + 35, target.y + 35, spell.school), 100);
                
                this.updateTurnOrder();
                this.render();
            },
            
            // Apply Spell Effect
            applySpellEffect(caster, target, effect, spell) {
                switch (effect.type) {
                    case 'condition':
                        if (spell.savingThrow) {
                            const saveMod = this.getAbilityModifier(target[spell.savingThrow.substr(0, 3)]);
                            const saveRoll = this.rollDice('1d20');
                            const saveTotal = saveRoll + saveMod;
                            
                            if (saveTotal >= spell.saveDC) {
                                this.addLog(`${target.name} resists! (${saveTotal} vs DC ${spell.saveDC})`, 'save');
                                return;
                            }
                        }
                        this.addCondition(target, effect.condition);
                        break;
                        
                    case 'ac_bonus':
                        target.ac += effect.value;
                        this.addLog(`${target.name} gains +${effect.value} AC!`, 'info');
                        break;
                        
                    case 'ac_set':
                        const dexMod = this.getAbilityModifier(target.dex);
                        target.ac = effect.value + dexMod;
                        this.addLog(`${target.name}'s AC is now ${target.ac}!`, 'info');
                        break;
                        
                    case 'buff':
                        this.addLog(`${target.name} is buffed: ${effect.effects.join(', ')}`, 'info');
                        // Store buff for later reference
                        if (!target.buffs) target.buffs = [];
                        target.buffs.push({name: spell.name, effects: effect.effects});
                        break;
                        
                    case 'debuff':
                        this.addLog(`${target.name} is debuffed: ${effect.effects.join(', ')}`, 'info');
                        if (!target.debuffs) target.debuffs = [];
                        target.debuffs.push({name: spell.name, effects: effect.effects});
                        break;
                        
                    case 'teleport':
                        // Move caster
                        const angle = Math.random() * Math.PI * 2;
                        caster.x += Math.cos(angle) * effect.distance * 5; // 5 pixels per foot
                        caster.y += Math.sin(angle) * effect.distance * 5;
                        this.addLog(`${caster.name} teleports!`, 'info');
                        break;
                        
                    case 'sleep':
                        const hpPool = this.rollDice(effect.hitpoints);
                        this.addLog(`Sleep affects ${hpPool} HP worth of creatures`, 'info');
                        // Would need to implement area selection for full effect
                        break;
                }
            },
            
            // Add Condition
            addCondition(entity, condition) {
                if (!entity.conditions.includes(condition)) {
                    // Remove conflicting conditions
                    if (condition === 'unconscious') {
                        entity.hp = 0;
                    }
                    
                    entity.conditions.push(condition);
                    this.addLog(`${entity.name} is now ${condition}!`, 'info');
                    
                    // Apply condition effects
                    const conditionData = this.conditions[condition];
                    if (conditionData && conditionData.effects) {
                        if (conditionData.effects.speed === 0) {
                            entity.movement = 0;
                        }
                    }
                }
                this.render();
            },
            
            // Remove Condition
            removeCondition(entity, condition) {
                const idx = entity.conditions.indexOf(condition);
                if (idx > -1) {
                    entity.conditions.splice(idx, 1);
                    this.addLog(`${entity.name} is no longer ${condition}!`, 'info');
                    
                    // Restore normal state
                    if (condition === 'unconscious' && entity.hp === 0) {
                        entity.hp = 1;
                    }
                }
                this.render();
            },
            
            // Roll Dice with display
            rollDice(formula, silent = false) {
                if (!formula) return 0;
                
                // Handle pure numbers
                if (!isNaN(formula)) return parseInt(formula);
                
                const match = formula.match(/(\d+)d(\d+)([+-]\d+)?/);
                if (!match) return parseInt(formula) || 0;
                
                const [, num, sides, mod] = match;
                const rolls = [];
                let total = 0;
                
                for (let i = 0; i < parseInt(num); i++) {
                    const roll = Math.floor(Math.random() * parseInt(sides)) + 1;
                    rolls.push(roll);
                    total += roll;
                }
                
                if (mod) total += parseInt(mod);
                total = Math.max(0, total);
                
                // Log the roll
                if (!silent) {
                    this.diceRollHistory.push({
                        formula,
                        rolls,
                        modifier: mod ? parseInt(mod) : 0,
                        total
                    });
                    
                    if (this.diceRollHistory.length > 20) {
                        this.diceRollHistory.shift();
                    }
                    this.showRollResult(`Roll: ${formula}`, `Total: ${total} (${rolls.join(', ')}${mod ? ` ${mod}` : ''})`);
                }
                
                return total;
            },
            
            // Show Roll Result
            showRollResult(title, breakdown) {
                const existing = document.querySelector('.roll-result');
                if (existing) existing.remove();
                
                const result = document.createElement('div');
                result.className = 'roll-result';
                result.innerHTML = `
                    <h3>${title}</h3>
                    <div class="roll-breakdown">${breakdown}</div>
                `;
                document.body.appendChild(result);
                
                setTimeout(() => result.remove(), 3000);
            },
            
            // Play Sound
            playSound(type) {
                const url = this.sounds[type];
                if (url) {
                    const audio = new Audio(url);
                    audio.play().catch(e => console.log('Sound play failed:', e));
                }
            },
            
            // Set Sound
            setSound(type, url) {
                this.sounds[type] = url;
                localStorage.setItem('dndSounds', JSON.stringify(this.sounds));
            },
            
            // Load Sounds
            loadSounds() {
                const saved = localStorage.getItem('dndSounds');
                if (saved) {
                    this.sounds = JSON.parse(saved);
                    Object.keys(this.sounds).forEach(type => {
                        document.getElementById(`sound${type.charAt(0).toUpperCase() + type.slice(1)}`).value = this.sounds[type];
                    });
                }
            },
            
            // Equipment Management
            equipItem(entity, item) {
                if (!item || !item.equipSlot) return;
                
                const slot = item.equipSlot;
                const currentItem = entity.equipment[slot];
                
                // Unequip current item
                if (currentItem) {
                    this.unequipItem(entity, currentItem);
                }
                
                // Equip new item
                entity.equipment[slot] = item;
                
                // Apply effects
                if (item.attackBonus) {
                    entity.attacks.forEach(attack => {
                        attack.toHit = (attack.toHit || 0) + item.attackBonus;
                    });
                }
                
                if (item.damageBonus) {
                    entity.attacks.forEach(attack => {
                        const current = parseInt(attack.damage.match(/[+-]\d+$/)?.[0] || '0');
                        attack.damage = attack.damage.replace(/[+-]\d+$/, '') + 
                                      (current + item.damageBonus >= 0 ? '+' : '') + 
                                      (current + item.damageBonus);
                    });
                }
                
                if (item.effect) {
                    this.applyEquipmentEffect(entity, item.effect, true);
                }
                
                // Remove from inventory
                const idx = entity.inventory.findIndex(i => i === item);
                if (idx > -1) entity.inventory.splice(idx, 1);
                
                // Recalculate AC
                entity.ac = this.calculateAC(entity);
                
                this.addLog(`${entity.name} equips ${item.name}`, 'info');
                this.render();
            },
            
            unequipItem(entity, item) {
                if (!item || !item.equipSlot) return;
                
                const slot = item.equipSlot;
                entity.equipment[slot] = null;
                
                // Reverse effects
                if (item.attackBonus) {
                    entity.attacks.forEach(attack => {
                        attack.toHit = (attack.toHit || 0) - item.attackBonus;
                    });
                }
                
                if (item.damageBonus) {
                    entity.attacks.forEach(attack => {
                        const current = parseInt(attack.damage.match(/[+-]\d+$/)?.[0] || '0');
                        const newBonus = current - item.damageBonus;
                        attack.damage = attack.damage.replace(/[+-]\d+$/, '') + 
                                      (newBonus !== 0 ? (newBonus >= 0 ? '+' : '') + newBonus : '');
                    });
                }
                
                if (item.effect) {
                    this.applyEquipmentEffect(entity, item.effect, false);
                }
                
                // Add to inventory
                entity.inventory.push(item);
                
                // Recalculate AC
                entity.ac = this.calculateAC(entity);
                
                this.addLog(`${entity.name} unequips ${item.name}`, 'info');
                this.render();
            },
            
            // Apply Equipment Effect
            applyEquipmentEffect(entity, effect, apply) {
                const multiplier = apply ? 1 : -1;
                
                switch (effect.type) {
                    case 'ability_score':
                        if (apply) {
                            entity[`original_${effect.ability}`] = entity[effect.ability];
                            entity[effect.ability] = effect.value;
                        } else {
                            entity[effect.ability] = entity[`original_${effect.ability}`] || entity[effect.ability];
                        }
                        break;
                        
                    case 'speed':
                        entity.speed += effect.bonus * multiplier;
                        entity.movement = entity.speed;
                        break;
                        
                    case 'advantage':
                        // Track for later use in rolls
                        if (!entity.advantages) entity.advantages = {};
                        entity.advantages[effect.skill] = apply;
                        break;
                }
            },
            
            // Use Item
            useItem(user, item, target = null) {
                if (user.id === target.id && !item.healing) {
                    this.addLog('Cannot target self with this item!', 'info');
                    return;
                }
                
                target = target || user;
                
                if (item.healing) {
                    const healing = this.rollDice(item.healing);
                    target.hp = Math.min(target.maxHp, target.hp + healing);
                    this.addLog(`${user.name} uses ${item.name} on ${target.name}, healing ${healing} HP!`, 'heal');
                    this.createFloatingText(`+${healing}`, target.x, target.y - 30, '#00ff00');
                    this.playSound('heal');
                } else if (item.effect) {
                    this.applyItemEffect(target, item.effect);
                    this.addLog(`${user.name} uses ${item.name} on ${target.name}!`, 'info');
                } else if (item.spell) {
                    // Scroll
                    const spell = this.library.spells.find(s => s.name === item.spell);
                    if (spell) {
                        this.castSpell(user, target, spell);
                    }
                }
                
                // Remove if consumable
                if (item.consumable) {
                    const idx = user.inventory.findIndex(i => i === item);
                    if (idx > -1) user.inventory.splice(idx, 1);
                }
                
                this.render();
            },
            
            // Apply Item Effect
            applyItemEffect(target, effect) {
                switch (effect.type) {
                    case 'condition':
                        this.addCondition(target, effect.condition);
                        if (effect.duration) {
                            // Track for later removal
                            setTimeout(() => this.removeCondition(target, effect.condition), effect.duration * 60000);
                        }
                        break;
                        
                    case 'buff':
                        if (!target.buffs) target.buffs = [];
                        target.buffs.push({effects: effect.effects, duration: effect.duration});
                        break;
                        
                    case 'advantage':
                        if (!target.advantages) target.advantages = {};
                        effect.saves.forEach(save => {
                            target.advantages[save] = true;
                        });
                        if (effect.duration) {
                            setTimeout(() => {
                                effect.saves.forEach(save => {
                                    target.advantages[save] = false;
                                });
                            }, effect.duration * 60000);
                        }
                        break;
                }
            },
            
            // Render entities and board
            render() {
                const canvas = document.getElementById('boardCanvas');
                if (!canvas) return;
                
                canvas.innerHTML = '';
                
                // Draw movement range for current turn
                if (this.showMovementRange && this.turnOrder.length > 0 && !this.editMode) {
                    const current = this.turnOrder[this.currentTurn];
                    if (current && current.movement > 0) {
                        const range = document.createElement('div');
                        range.className = 'movement-range';
                        const radius = current.movement * 5; // 5 pixels per foot
                        range.style.width = radius * 2 + 'px';
                        range.style.height = radius * 2 + 'px';
                        range.style.left = (current.x - radius) + 'px';
                        range.style.top = (current.y - radius) + 'px';
                        canvas.appendChild(range);
                    }
                }
                
                // Render entities
                this.entities.forEach(entity => {
                    const elem = document.createElement('div');
                    elem.className = 'entity';
                    elem.dataset.id = entity.id;
                    
                    // Add condition classes
                    if (entity.conditions.includes('dead')) {
                        elem.classList.add('dead');
                    } else if (entity.conditions.includes('unconscious')) {
                        elem.classList.add('unconscious');
                    }
                    
                    if (this.selectedEntity && this.selectedEntity.id === entity.id) {
                        elem.classList.add('selected');
                    }
                    
                    if (this.targetingMode && entity.id !== this.targetingMode.source.id) {
                        elem.classList.add('valid-target');
                    }
                    
                    elem.style.left = (entity.x - 35) + 'px';
                    elem.style.top = (entity.y - 35) + 'px';
                    
                    const borderColor = entity.type === 'player' ? '#60a5fa' : 
                                      entity.type === 'monster' ? '#ef4444' : 
                                      entity.type === 'npc' ? '#10b981' :
                                      entity.type === 'container' ? '#8b5a2b' : '#fbbf24';
                    
                    // Add specific class for entity type
                    if (entity.type === 'container') {
                        elem.classList.add('chest');
                    } else if (entity.type === 'npc') {
                        elem.classList.add('npc');
                    }
                    
                    let content = '';
                    if (entity.image) {
                        content = `<img src="${entity.image}" class="entity-image" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                         <span class="entity-content" style="display:none;">${entity.name[0]}</span>`;
                    } else {
                        content = `<span class="entity-content">${entity.name[0]}</span>`;
                    }
                    
                    let hpBar = '';
                    if (entity.type !== 'item' && entity.type !== 'container') {
                        const hpPercent = entity.hp / entity.maxHp * 100;
                        const hpClass = hpPercent > 75 ? 'high' : hpPercent > 25 ? 'medium' : 'low';
                        hpBar = `
                            <div class="hp-bar">
                                <div class="hp-fill ${hpClass}" style="width: ${hpPercent}%"></div>
                            </div>
                        `;
                    }
                    
                    let deathSaves = '';
                    if (entity.hp === 0 && entity.type === 'player' && !entity.conditions.includes('dead')) {
                        deathSaves = '<div class="death-saves-indicator">';
                        for (let i = 0; i < 3; i++) {
                            deathSaves += `<div class="death-save-dot ${i < entity.deathSaves.successes ? 'success' : ''}"></div>`;
                        }
                        for (let i = 0; i < 3; i++) {
                            deathSaves += `<div class="death-save-dot ${i < entity.deathSaves.failures ? 'failure' : ''}"></div>`;
                        }
                        deathSaves += '</div>';
                    }
                    
                    let conditionsBadge = '';
                    let statusIcons = '';
                    if (entity.conditions.length > 0 && !entity.conditions.includes('dead')) {
                        conditionsBadge = `<div class="conditions-badge">${entity.conditions.length}</div>`;
                        
                        // Create status icons
                        statusIcons = '<div class="status-icons">';
                        entity.conditions.forEach(condition => {
                            const icon = this.getConditionIcon(condition);
                            statusIcons += `<div class="status-icon ${condition}" title="${condition.charAt(0).toUpperCase() + condition.slice(1)}">${icon}</div>`;
                        });
                        statusIcons += '</div>';
                    }
                    
                    // Add status control buttons for players/monsters/npcs when hovered
                    let statusButtons = '';
                    if (entity.type === 'player' || entity.type === 'monster' || entity.type === 'npc') {
                        statusButtons = '<div class="status-buttons">';
                        Object.keys(this.conditions).slice(0, 8).forEach(condition => {
                            const icon = this.getConditionIcon(condition);
                            const isActive = entity.conditions.includes(condition);
                            statusButtons += `<button class="status-button" style="background: ${isActive ? '#ef4444' : '#374151'}" onclick="game.toggleCondition(${entity.id}, '${condition}')" title="Toggle ${condition}">${icon}</button>`;
                        });
                        statusButtons += '</div>';
                    }
                    
                    let nameDisplay = entity.name;
                    if (entity.type !== 'item' && entity.type !== 'container') {
                        nameDisplay += ` (${entity.hp}/${entity.maxHp})`;
                    }
                    
                    elem.innerHTML = `
                        <div class="entity-circle" style="background: ${entity.color}; border-color: ${borderColor};">
                            ${content}
                            ${hpBar}
                            <div class="entity-name">${nameDisplay}</div>
                            ${deathSaves}
                            ${conditionsBadge}
                            ${statusIcons}
                            ${statusButtons}
                        </div>
                    `;
                    
                    elem.addEventListener('click', () => this.selectEntity(entity));
                    elem.draggable = true;
                    elem.addEventListener('dragstart', (e) => this.handleDragStart(e, entity));
                    elem.addEventListener('dragend', (e) => this.handleDragEnd(e, entity));
                    
                    canvas.appendChild(elem);
                });
            },
            
            // Get condition icon for display
            getConditionIcon(condition) {
                const icons = {
                    poisoned: '‚ò†Ô∏è',
                    stunned: 'üòµ',
                    paralyzed: 'üßä',
                    charmed: 'üíï',
                    frightened: 'üò±',
                    prone: '‚¨áÔ∏è',
                    grappled: 'ü§ù',
                    restrained: '‚õìÔ∏è',
                    blinded: 'üëÅÔ∏è',
                    deafened: 'üîá',
                    invisible: 'üëª',
                    unconscious: 'üò¥',
                    incapacitated: 'üö´',
                    petrified: 'üóø',
                    exhaustion: 'üò™'
                };
                return icons[condition] || '‚ùì';
            },
            
            // Toggle condition on entity
            toggleCondition(entityId, condition) {
                const entity = this.entities.find(e => e.id === entityId);
                if (!entity) return;
                
                const index = entity.conditions.indexOf(condition);
                if (index > -1) {
                    entity.conditions.splice(index, 1);
                    this.addLog(`${entity.name} no longer has ${condition}`, 'info');
                } else {
                    entity.conditions.push(condition);
                    this.addLog(`${entity.name} is now ${condition}`, 'info');
                    this.applyConditionEffects(entity, condition);
                }
                
                this.render();
            },
            
            // Apply automatic condition effects
            applyConditionEffects(entity, condition) {
                const effects = this.conditions[condition]?.effects;
                if (!effects) return;
                
                // Apply movement effects
                if (effects.speed !== undefined) {
                    entity.movement = Math.min(entity.movement, effects.speed);
                }
                
                // Note: Other effects are handled during combat calculations
                // This is just for immediate visual/mechanical effects
            },
            
            // Auto-apply condition when hit by specific effects
            applyConditionFromSpell(target, spellName) {
                const conditionMappings = {
                    'Poison Spray': 'poisoned',
                    'Hold Person': 'paralyzed',
                    'Sleep': 'unconscious',
                    'Charm Person': 'charmed',
                    'Fear': 'frightened',
                    'Blindness/Deafness': 'blinded',
                    'Entangle': 'restrained',
                    'Web': 'restrained',
                    'Slow': 'stunned'
                };
                
                const condition = conditionMappings[spellName];
                if (condition && !target.conditions.includes(condition)) {
                    target.conditions.push(condition);
                    this.addLog(`${target.name} is ${condition} by ${spellName}!`, 'spell');
                    this.applyConditionEffects(target, condition);
                }
            },
            
            // Enhanced spell casting to auto-apply conditions
            castSpell(caster, spell, target = null) {
                // ... existing spell logic ...
                
                // Auto-apply conditions for certain spells
                if (target) {
                    this.applyConditionFromSpell(target, spell.name);
                }
                
                // Trigger existing castSpell logic if it exists
                if (this.originalCastSpell) {
                    return this.originalCastSpell.call(this, caster, spell, target);
                }
            },
            
            // Toggle Edit Mode
            toggleEditMode() {
                this.editMode = !this.editMode;
                const btn = document.getElementById('editToggle');
                btn.classList.toggle('active', this.editMode);
                this.addLog(`Edit mode ${this.editMode ? 'enabled' : 'disabled'}`, 'info');
                this.render();
            },
            
            // Drag Arrow Functions
            createDragArrow(startX, startY, endX, endY) {
                if (this.dragArrow) {
                    this.dragArrow.remove();
                }
                
                const angle = Math.atan2(endY - startY, endX - startX);
                const distance = Math.hypot(endX - startX, endY - startY);
                
                this.dragArrow = document.createElement('div');
                this.dragArrow.className = 'drag-arrow';
                this.dragArrow.style.left = `${startX}px`;
                this.dragArrow.style.top = `${startY}px`;
                this.dragArrow.style.width = `${distance}px`;
                this.dragArrow.style.transform = `rotate(${angle}rad)`;
                
                document.getElementById('boardCanvas').appendChild(this.dragArrow);
            },
            
            removeDragArrow() {
                if (this.dragArrow) {
                    this.dragArrow.remove();
                    this.dragArrow = null;
                }
            },
            
            createPersistentArrow(startX, startY, endX, endY) {
                if (this.persistentArrow) {
                    this.persistentArrow.remove();
                }
                
                const angle = Math.atan2(endY - startY, endX - startX);
                const distance = Math.hypot(endX - startX, endY - startY);
                
                this.persistentArrow = document.createElement('div');
                this.persistentArrow.className = 'persistent-arrow';
                this.persistentArrow.style.left = `${startX}px`;
                this.persistentArrow.style.top = `${startY}px`;
                this.persistentArrow.style.width = `${distance}px`;
                this.persistentArrow.style.transform = `rotate(${angle}rad)`;
                
                document.getElementById('boardCanvas').appendChild(this.persistentArrow);
            },
            
            removePersistentArrow() {
                if (this.persistentArrow) {
                    this.persistentArrow.remove();
                    this.persistentArrow = null;
                }
            },
            
            // Drag handling
            handleDragStart(e, entity) {
                this.draggingEntity = entity;
                this.dragStartPos = {x: entity.x, y: entity.y};
                e.dataTransfer.effectAllowed = 'move';
                
                // Start tracking mouse for drag arrow
                document.addEventListener('mousemove', this.updateDragArrow.bind(this));
            },
            
            updateDragArrow(e) {
                if (!this.draggingEntity || !this.dragStartPos) return;
                
                const rect = document.getElementById('gameBoard').getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                this.createDragArrow(this.dragStartPos.x, this.dragStartPos.y, mouseX, mouseY);
            },
            
            handleDragEnd(e, entity) {
                this.removeDragArrow();
                document.removeEventListener('mousemove', this.updateDragArrow.bind(this));
                
                this.draggingEntity = null;
                this.dragStartPos = null;
            },
            
            // Setup event listeners
            setupEventListeners() {
                const canvas = document.getElementById('boardCanvas');
                const gameBoard = document.getElementById('gameBoard');
                
                canvas.addEventListener('dragover', e => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                
                canvas.addEventListener('drop', e => {
                    e.preventDefault();
                    if (!this.draggingEntity) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Create persistent arrow from start to drop pos
                    this.createPersistentArrow(this.dragStartPos.x, this.dragStartPos.y, x, y);
                    
                    // Check for target entity
                    const target = this.entities.find(ent => 
                        ent.id !== this.draggingEntity.id && 
                        Math.abs(ent.x - x) < 40 && 
                        Math.abs(ent.y - y) < 40
                    );
                    
                    let actionPerformed = false;
                    
                    if (this.targetingMode && this.draggingEntity.id === this.targetingMode.source.id && target) {
                        // Execute targeted action
                        this.executeTargetedAction(target);
                        actionPerformed = true;
                    } else if (target && this.draggingEntity.type === 'player' && target.type === 'monster') {
                        // Quick attack
                        if (this.draggingEntity.attacks.length > 0) {
                            this.performAttack(this.draggingEntity, target, this.draggingEntity.attacks[0]);
                            actionPerformed = true;
                        }
                    } else if (target && this.draggingEntity.type === 'player' && target.type === 'item') {
                        // Pick up item automatically
                        this.draggingEntity.inventory.push({...target});
                        this.removeEntity(target.id);
                        this.addLog(`${this.draggingEntity.name} picks up ${target.name}!`, 'info');
                        actionPerformed = true;
                    } else if (target && this.draggingEntity.type === 'item' && target.type === 'container') {
                        // Put item into chest
                        if (!target.inventory) target.inventory = [];
                        target.inventory.push({...this.draggingEntity});
                        this.removeEntity(this.draggingEntity.id);
                        this.addLog(`${this.draggingEntity.name} placed into ${target.name}!`, 'info');
                        actionPerformed = true;
                    } else if (target && this.draggingEntity.type === 'player' && target.type === 'container') {
                        // Open chest and spill contents
                        if (target.isMimic) {
                            // Reveal mimic and attack
                            target.name = 'Mimic';
                            target.type = 'monster';
                            this.performAttack(this.draggingEntity, target, target.attacks[0] || {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing'});
                            this.playSound('open');
                        } else {
                            // Spill chest contents around the chest
                            if (target.inventory && target.inventory.length > 0) {
                                target.inventory.forEach((item, index) => {
                                    const angle = (index / target.inventory.length) * Math.PI * 2;
                                    const distance = 80 + (index * 20); // Spread items in a circle
                                    const newX = target.x + Math.cos(angle) * distance;
                                    const newY = target.y + Math.sin(angle) * distance;
                                    
                                    const newItem = this.createEntity('item', item.name, newX, newY);
                                    Object.assign(newItem, item);
                                    newItem.id = this.nextId++;
                                    newItem.x = newX;
                                    newItem.y = newY;
                                    this.entities.push(newItem);
                                });
                                this.addLog(`${this.draggingEntity.name} opens the chest! ${target.inventory.length} items spill out.`, 'info');
                                target.inventory = []; // Empty the chest
                                this.playSound('open');
                            } else {
                                this.addLog(`${this.draggingEntity.name} opens the chest but finds it empty.`, 'info');
                            }
                        }
                        actionPerformed = true;
                                target.inventory = []; // Empty the chest
                            } else {
                                this.addLog(`${this.draggingEntity.name} opens the chest. It's empty.`, 'info');
                            }
                            this.playSound('open');
                        }
                        actionPerformed = true;
                    } else if (target && target.type === 'container' && this.draggingEntity.type === 'item') {
                        // Add item to chest
                        if (!target.isMimic) {
                            if (!target.inventory) target.inventory = [];
                            target.inventory.push({...this.draggingEntity});
                            this.removeEntity(this.draggingEntity.id);
                            this.addLog(`${this.draggingEntity.name} added to chest.`, 'info');
                            actionPerformed = true;
                        }
                    } else {
                        // Normal movement
                        if (this.editMode) {
                            // Free movement in edit mode - no restrictions
                            this.draggingEntity.x = x;
                            this.draggingEntity.y = y;
                            this.addLog(`${this.draggingEntity.name} moved freely in edit mode.`, 'info');
                            actionPerformed = true;
                        } else {
                            const distance = Math.hypot(x - this.dragStartPos.x, y - this.dragStartPos.y);
                            const movementCost = Math.floor(distance / 5);
                            
                            if (this.enforceTurns && this.turnOrder[this.currentTurn]?.id !== this.draggingEntity.id) {
                                this.addLog('Not your turn!', 'info');
                                return;
                            }
                            
                            if (movementCost <= this.draggingEntity.movement) {
                                this.draggingEntity.x = x;
                                this.draggingEntity.y = y;
                                this.draggingEntity.movement -= movementCost;
                                this.updateTurnOrder();
                                this.addLog(`${this.draggingEntity.name} moves ${movementCost}ft.`, 'info');
                                actionPerformed = true;
                            } else {
                                this.addLog(`Not enough movement! (${movementCost}ft needed, ${this.draggingEntity.movement}ft remaining)`, 'info');
                            }
                        }
                    }
                    
                    // Remove persistent arrow after action
                    setTimeout(() => {
                        this.removePersistentArrow();
                    }, actionPerformed ? 1500 : 500);
                    
                    this.render();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', e => {
                    if (e.key === 'Enter') this.nextTurn();
                    if (e.key === 'Delete' && this.selectedEntity) this.removeEntity(this.selectedEntity.id);
                });
            },
            
            // Targeting system
            startTargeting(source, action) {
                this.targetingMode = {source, action};
                
                document.querySelectorAll('.action-menu, .details-panel').forEach(el => el.remove());
                
                const indicator = document.createElement('div');
                indicator.className = 'targeting-indicator';
                indicator.id = 'targetingIndicator';
                indicator.innerHTML = `
                    <div class="targeting-text">Select target for ${action.name}</div>
                    <button class="cancel-btn" onclick="game.cancelTargeting()">Cancel</button>
                `;
                document.getElementById('gameBoard').appendChild(indicator);
                
                this.render();
            },
            
            executeTargetedAction(target) {
                if (!this.targetingMode) return;
                
                if (this.targetingMode.source.id === target.id) {
                    this.addLog('Cannot target self!', 'info');
                    return;
                }
                
                const {source, action} = this.targetingMode;
                
                if (action.level !== undefined) {
                    // It's a spell
                    this.castSpell(source, target, action);
                } else if (action.toHit !== undefined) {
                    // It's an attack
                    this.performAttack(source, target, action);
                } else if (action.healing || action.effect) {
                    // It's an item
                    this.useItem(source, action, target);
                }
                
                this.cancelTargeting();
            },
            
            cancelTargeting() {
                this.targetingMode = null;
                document.getElementById('targetingIndicator')?.remove();
                this.render();
            },
            
            // UI Functions
            selectEntity(entity) {
                if (this.targetingMode) {
                    this.executeTargetedAction(entity);
                    return;
                }
                
                // If player selected and item/chest touched, pick up/add
                if (this.selectedEntity && this.selectedEntity.type === 'player' && (entity.type === 'item' || entity.type === 'container')) {
                    if (entity.type === 'container') {
                        if (entity.isMimic) {
                            entity.name = 'Mimic';
                            entity.type = 'monster';
                            this.performAttack(this.selectedEntity, entity, entity.attacks[0] || {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing'});
                            this.playSound('open');
                        } else {
                            this.playSound('open');
                            this.addLog(`${this.selectedEntity.name} opens the chest.`, 'info');
                        }
                    } else {
                        this.selectedEntity.inventory.push({...entity});
                        this.removeEntity(entity.id);
                        this.addLog(`${this.selectedEntity.name} picks up ${entity.name}!`, 'info');
                    }
                    this.render();
                    return;
                }
                
                this.selectedEntity = entity;
                this.render();
                this.showDetailsPanel(entity);
                
                if ((entity.type === 'player' || entity.type === 'monster') && entity.hp > 0) {
                    this.showActionMenu(entity);
                }
            },
            
            showDetailsPanel(entity) {
                document.querySelectorAll('.details-panel').forEach(el => el.remove());
                
                const panel = document.createElement('div');
                panel.className = 'details-panel';
                
                let html = `
                    <button class="close-btn" onclick="this.parentElement.remove()">‚úï</button>
                    <h3 style="color: #fbbf24; margin-bottom: 15px;">${entity.name}</h3>
                    <div class="stat-row">
                        <span>Name:</span>
                        <input type="text" value="${entity.name}" onchange="game.updateEntity(${entity.id}, 'name', this.value)" class="stat-input" style="width: 120px;">
                    </div>
                `;
                
                if (entity.type === 'player') {
                    html += `
                        <div class="stat-row">
                            <span>Class:</span>
                            <input type="text" value="${entity.class}" onchange="game.updateEntity(${entity.id}, 'class', this.value)" class="stat-input" style="width: 80px;">
                            <span>Race:</span>
                            <input type="text" value="${entity.race}" onchange="game.updateEntity(${entity.id}, 'race', this.value)" class="stat-input" style="width: 80px;">
                        </div>
                        <div class="stat-row">
                            <span>Level:</span>
                            <input type="number" value="${entity.level}" onchange="game.updateEntity(${entity.id}, 'level', this.value)" class="stat-input">
                        </div>
                    `;
                }
                
                if (entity.type !== 'item' && entity.type !== 'container') {
                    const strMod = this.getAbilityModifier(entity.str);
                    const dexMod = this.getAbilityModifier(entity.dex);
                    const conMod = this.getAbilityModifier(entity.con);
                    const intMod = this.getAbilityModifier(entity.int);
                    const wisMod = this.getAbilityModifier(entity.wis);
                    const chaMod = this.getAbilityModifier(entity.cha);
                    
                    html += `
                        <div class="stat-row">
                            <span>HP:</span>
                            <div>
                                <input type="number" value="${entity.hp}" onchange="game.updateEntity(${entity.id}, 'hp', this.value)" class="stat-input">
                                / <input type="number" value="${entity.maxHp}" onchange="game.updateEntity(${entity.id}, 'maxHp', this.value)" class="stat-input">
                                ${entity.tempHp > 0 ? `(+${entity.tempHp} temp)` : ''}
                            </div>
                        </div>
                        <div class="stat-row">
                            <span>AC:</span>
                            <span>${this.calculateAC(entity)}</span>
                        </div>
                        <div class="stat-row">
                            <span>Speed:</span>
                            <input type="number" value="${entity.speed}" onchange="game.updateEntity(${entity.id}, 'speed', this.value)" class="stat-input">ft
                        </div>
                        
                        <h4 style="margin-top: 15px;">Ability Scores</h4>
                        <div class="stat-group">
                            <div class="stat-box">
                                <div class="stat-label">STR</div>
                                <input type="number" value="${entity.str}" onchange="game.updateEntity(${entity.id}, 'str', this.value)" class="stat-input">
                                <div class="stat-mod">${strMod >= 0 ? '+' : ''}${strMod}</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">DEX</div>
                                <input type="number" value="${entity.dex}" onchange="game.updateEntity(${entity.id}, 'dex', this.value)" class="stat-input">
                                <div class="stat-mod">${dexMod >= 0 ? '+' : ''}${dexMod}</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">CON</div>
                                <input type="number" value="${entity.con}" onchange="game.updateEntity(${entity.id}, 'con', this.value)" class="stat-input">
                                <div class="stat-mod">${conMod >= 0 ? '+' : ''}${conMod}</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">INT</div>
                                <input type="number" value="${entity.int}" onchange="game.updateEntity(${entity.id}, 'int', this.value)" class="stat-input">
                                <div class="stat-mod">${intMod >= 0 ? '+' : ''}${intMod}</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">WIS</div>
                                <input type="number" value="${entity.wis}" onchange="game.updateEntity(${entity.id}, 'wis', this.value)" class="stat-input">
                                <div class="stat-mod">${wisMod >= 0 ? '+' : ''}${wisMod}</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-label">CHA</div>
                                <input type="number" value="${entity.cha}" onchange="game.updateEntity(${entity.id}, 'cha', this.value)" class="stat-input">
                                <div class="stat-mod">${chaMod >= 0 ? '+' : ''}${chaMod}</div>
                            </div>
                        </div>
                        
                        <h4 style="margin-top: 15px;">Conditions</h4>
                        <div style="margin-bottom: 10px;">
                            ${entity.conditions.length > 0 ? 
                                entity.conditions.map(cond => `
                                    <span style="display: inline-block; background: rgba(139, 92, 246, 0.2); padding: 2px 8px; border-radius: 4px; margin: 2px;">
                                        ${cond}
                                        <button onclick="game.removeCondition(game.getEntity(${entity.id}), '${cond}')" style="background: none; border: none; color: #ef4444; cursor: pointer;">‚úï</button>
                                    </span>
                                `).join('') : 
                                'None'
                            }
                        </div>
                        
                        ${entity.type === 'player' ? `
                            <h4>Spell Slots</h4>
                            <div class="stat-group">
                                ${[1,2,3].map(level => `
                                    <div class="stat-box">
                                        <div class="stat-label">Lvl ${level}</div>
                                        <div>${entity.spellSlotsUsed[level] || 0}/${entity.spellSlots[level] || 0}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        <div class="stat-row">
                            <span>Image URL:</span>
                            <input type="text" value="${entity.image}" onchange="game.updateEntity(${entity.id}, 'image', this.value)" class="stat-input" style="width: 200px;">
                        </div>
                        
                        <button class="btn btn-primary btn-small" onclick="game.openSpellManager(${entity.id})">Manage Spells</button>
                        <button class="btn btn-primary btn-small" onclick="game.openInventoryManager(${entity.id})">Manage Inventory</button>
                    `;
                }
                
                html += `
                    <button class="btn btn-danger btn-small" onclick="game.removeEntity(${entity.id})">Remove</button>
                    <button class="btn btn-success btn-small" onclick="game.saveToLibrary(${entity.id})">Save to Library</button>
                `;
                
                panel.innerHTML = html;
                document.getElementById('gameBoard').appendChild(panel);
            },
            
            showActionMenu(entity) {
                document.querySelectorAll('.action-menu').forEach(el => el.remove());
                
                const elem = document.querySelector(`[data-id="${entity.id}"]`);
                if (!elem) return;
                
                const menu = document.createElement('div');
                menu.className = 'action-menu';
                
                let html = `<h4 style="color: #fbbf24;">‚≠ê Actions for ${entity.name}</h4>
                           <p style="font-size: 11px; color: #9ca3af; margin: 5px 0;">Click an action, then click target</p>`;
                
                // Attacks
                if (entity.attacks && entity.attacks.length > 0) {
                    html += '<div class="action-section"><div class="action-section-title">Attacks</div>';
                    entity.attacks.forEach((attack, index) => {
                        const disabled = entity.actionUsed && !attack.bonusAction ? 'disabled' : '';
                        const range = attack.range || 5;
                        html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).attacks[${index}])">
                            ‚öîÔ∏è ${attack.name} (+${attack.toHit}, ${attack.damage}) [${range}ft]
                        </button>`;
                    });
                    html += '</div>';
                }
                
                // Spells
                if (entity.spells && entity.spells.length > 0) {
                    html += '<div class="action-section"><div class="action-section-title">Spells</div>';
                    entity.spells.forEach((spell, index) => {
                        const canCast = spell.level === 0 || 
                                       (entity.spellSlots && entity.spellSlots[spell.level] > entity.spellSlotsUsed[spell.level]);
                        const disabled = !canCast || 
                                       (spell.castingTime === 'action' && entity.actionUsed) ||
                                       (spell.castingTime === 'bonus action' && entity.bonusActionUsed) ? 'disabled' : '';
                        
                        const slotInfo = spell.level > 0 ? 
                            `<span class="spell-slot-info">${entity.spellSlotsUsed[spell.level]}/${entity.spellSlots[spell.level]}</span>` : '';
                        
                        html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).spells[${index}])">
                            ‚ú® ${spell.name} (Lvl ${spell.level}) ${slotInfo}
                        </button>`;
                    });
                    html += '</div>';
                }
                
                // Items
                if (entity.inventory && entity.inventory.length > 0) {
                    const usableItems = entity.inventory.filter(item => item.healing || item.effect || item.spell);
                    if (usableItems.length > 0) {
                        html += '<div class="action-section"><div class="action-section-title">Items</div>';
                        usableItems.forEach((item, index) => {
                            const actualIndex = entity.inventory.indexOf(item);
                            html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).inventory[${actualIndex}])">
                                üß™ ${item.name}
                            </button>`;
                        });
                        html += '</div>';
                    }
                }
                
                // Abilities (non-targeting ones)
                if (entity.abilities && entity.abilities.length > 0) {
                    const activeAbilities = entity.abilities.filter(a => a.actionType !== 'passive');
                    if (activeAbilities.length > 0) {
                        html += '<div class="action-section"><div class="action-section-title">Special Abilities</div>';
                        activeAbilities.forEach(ability => {
                            const disabled = (ability.actionType === 'action' && entity.actionUsed) ||
                                           (ability.actionType === 'bonus' && entity.bonusActionUsed) ||
                                           (ability.actionType === 'reaction' && entity.reactionUsed) ? 'disabled' : '';
                            html += `<button class="action-btn ${disabled}" title="${ability.description}">
                                üí´ ${ability.name}
                            </button>`;
                        });
                        html += '</div>';
                    }
                }
                
                menu.innerHTML = html;
                
                // Add close button after menu is created
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-btn';
                closeBtn.innerHTML = '‚úï';
                closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    menu.remove();
                };
                menu.appendChild(closeBtn);
                
                elem.appendChild(menu);
            },
            
            // Managers
            openSpellManager(entityId) {
                const entity = this.getEntity(entityId);
                if (!entity) return;
                
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                let html = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                        <h2>‚ú® Manage Spells for ${entity.name}</h2>
                        
                        <h3>Current Spells</h3>
                        <div class="item-list">
                            ${entity.spells.map((s, i) => `
                                <div class="item-card">
                                    <strong>${s.name}</strong> (Level ${s.level})<br>
                                    <small>${s.description}</small><br>
                                    <button class="btn btn-small btn-danger" onclick="game.removeSpell(${entityId}, ${i}); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openSpellManager(${entityId});">Remove</button>
                                </div>
                            `).join('')}
                        </div>
                        
                        <h3>Available Spells</h3>
                        <div class="item-list">
                            ${this.library.spells.filter(s => !entity.spells.some(es => es.name === s.name)).map(s => `
                                <div class="item-card" onclick="game.addSpell(${entityId}, '${s.name}'); this.parentElement.parentElement.parentElement.remove(); game.openSpellManager(${entityId});">
                                    <strong>${s.name}</strong> (Level ${s.level})<br>
                                    <small>${s.description}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                modal.innerHTML = html;
                document.body.appendChild(modal);
            },
            
            openInventoryManager(entityId) {
                const entity = this.getEntity(entityId);
                if (!entity) return;
                
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                let html = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                        <h2>üéí Manage Inventory for ${entity.name}</h2>
                        
                        <h3>Equipment</h3>
                        <div class="item-list">
                            ${Object.entries(entity.equipment).map(([slot, item]) => `
                                <div class="item-card">
                                    <strong>${slot}:</strong> ${item ? item.name : 'Empty'}
                                    ${item ? `<button class="btn btn-small btn-danger" onclick="game.unequipItem(game.getEntity(${entityId}), game.getEntity(${entityId}).equipment['${slot}']); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Unequip</button>` : ''}
                                </div>
                            `).join('')}
                        </div>
                        
                        <h3>Inventory</h3>
                        <div class="item-list">
                            ${entity.inventory.map((item, i) => `
                                <div class="item-card">
                                    <strong>${item.name}</strong><br>
                                    <small>${item.description || ''}</small><br>
                                    <button class="btn btn-small btn-danger" onclick="game.removeInventoryItem(${entityId}, ${i}); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Remove</button>
                                    ${item.equipSlot ? `<button class="btn btn-small btn-primary" onclick="game.equipItem(game.getEntity(${entityId}), game.getEntity(${entityId}).inventory[${i}]); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Equip</button>` : ''}
                                </div>
                            `).join('')}
                        </div>
                        
                        <h3>Add Items</h3>
                        <div class="item-list">
                            ${[...this.library.items, ...this.library.equipment].map(item => `
                                <div class="item-card" onclick="game.addInventoryItem(${entityId}, '${item.name}'); this.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">
                                    <strong>${item.name}</strong><br>
                                    <small>${item.description || ''}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                modal.innerHTML = html;
                document.body.appendChild(modal);
            },
            
            // Helper functions for managers
            addSpell(entityId, spellName) {
                const entity = this.getEntity(entityId);
                const spell = this.library.spells.find(s => s.name === spellName);
                if (entity && spell) {
                    entity.spells.push(JSON.parse(JSON.stringify(spell)));
                    this.addLog(`${entity.name} learns ${spell.name}`, 'info');
                }
            },
            
            removeSpell(entityId, index) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index]) {
                    const spellName = entity.spells[index].name;
                    entity.spells.splice(index, 1);
                    this.addLog(`${entity.name} forgets ${spellName}`, 'info');
                }
            },
            
            addInventoryItem(entityId, itemName) {
                const entity = this.getEntity(entityId);
                const item = [...this.library.items, ...this.library.equipment].find(i => i.name === itemName);
                if (entity && item) {
                    entity.inventory.push(JSON.parse(JSON.stringify(item)));
                    this.addLog(`${entity.name} receives ${item.name}`, 'info');
                }
            },
            
            removeInventoryItem(entityId, index) {
                const entity = this.getEntity(entityId);
                if (entity && entity.inventory[index]) {
                    const itemName = entity.inventory[index].name;
                    entity.inventory.splice(index, 1);
                    this.addLog(`${entity.name} discards ${itemName}`, 'info');
                }
            },
            
            // Entity management
            getEntity(id) {
                return this.entities.find(e => e.id === id);
            },
            
            updateEntity(id, prop, value) {
                const entity = this.getEntity(id);
                if (!entity) return;
                
                const numericProps = ['hp', 'maxHp', 'ac', 'speed', 'str', 'dex', 'con', 'int', 'wis', 'cha', 'tempHp', 'level'];
                entity[prop] = numericProps.includes(prop) ? parseInt(value) || 0 : value;
                
                // Recalculate AC if ability scores change
                if (['str', 'dex'].includes(prop)) {
                    entity.ac = this.calculateAC(entity);
                }
                
                // Update image if changed
                if (prop === 'image' && entity.image) {
                    // Trigger re-render
                }
                
                this.render();
            },
            
            removeEntity(id) {
                this.entities = this.entities.filter(e => e.id !== id);
                if (this.selectedEntity && this.selectedEntity.id === id) {
                    this.selectedEntity = null;
                }
                this.updateTurnOrder();
                this.render();
                document.querySelectorAll('.details-panel, .action-menu').forEach(el => el.remove());
            },
            
            // Add entities
            addPlayerCharacter() {
                const name = prompt('Enter character name:');
                if (!name) return;
                
                // Create modal for class and race selection
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>Create Player Character</h2>
                        <div style="margin: 20px 0;">
                            <label style="display: block; margin-bottom: 5px; color: #e0e0e0;">Class:</label>
                            <select id="classSelect" style="width: 100%; padding: 8px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white; margin-bottom: 15px;">
                                ${this.classList.map(cls => `<option value="${cls}">${cls}</option>`).join('')}
                            </select>
                            <input type="text" id="customClass" placeholder="Enter custom class name" style="width: 100%; padding: 8px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white; margin-bottom: 15px; display: none;">
                            
                            <label style="display: block; margin-bottom: 5px; color: #e0e0e0;">Race:</label>
                            <select id="raceSelect" style="width: 100%; padding: 8px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white; margin-bottom: 15px;">
                                ${this.raceList.map(race => `<option value="${race}">${race}</option>`).join('')}
                            </select>
                            <input type="text" id="customRace" placeholder="Enter custom race name" style="width: 100%; padding: 8px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white; margin-bottom: 15px; display: none;">
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn btn-danger" onclick="this.parentElement.parentElement.parentElement.remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createPlayerFromModal('${name}')">Create Character</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for custom option toggles
                modal.querySelector('#classSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#customClass');
                    customInput.style.display = e.target.value === 'Custom' ? 'block' : 'none';
                });
                
                modal.querySelector('#raceSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#customRace');
                    customInput.style.display = e.target.value === 'Custom' ? 'block' : 'none';
                });
                
                document.body.appendChild(modal);
            },
            
            createPlayerFromModal(name) {
                const modal = document.querySelector('.modal-overlay');
                const classSelect = modal.querySelector('#classSelect');
                const customClass = modal.querySelector('#customClass');
                const raceSelect = modal.querySelector('#raceSelect');
                const customRace = modal.querySelector('#customRace');
                
                const selectedClass = classSelect.value === 'Custom' ? customClass.value || 'Fighter' : classSelect.value;
                const selectedRace = raceSelect.value === 'Custom' ? customRace.value || 'Human' : raceSelect.value;
                
                const entity = this.createEntity('player', name, 200 + Math.random() * 100, 200 + Math.random() * 200);
                entity.class = selectedClass;
                entity.race = selectedRace;
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
                
                modal.remove();
            },
            
            addMonster() {
                const name = prompt('Enter monster name:', 'Goblin');
                if (!name) return;
                
                const entity = this.createEntity('monster', name, 400 + Math.random() * 200, 200 + Math.random() * 200);
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
            },
            
            addItem() {
                const name = prompt('Enter item name:', 'Healing Potion');
                if (!name) return;
                
                const entity = this.createEntity('item', name, 350 + Math.random() * 100, 350 + Math.random() * 100);
                this.entities.push(entity);
                this.render();
            },
            
            addChest() {
                // Create modal for chest configuration
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>Create Chest</h2>
                        <div style="margin: 20px 0;">
                            <label style="display: block; margin-bottom: 5px; color: #e0e0e0;">Chest Name:</label>
                            <input type="text" id="chestName" value="Chest" style="width: 100%; padding: 8px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white; margin-bottom: 15px;">
                            
                            <label style="display: block; margin-bottom: 5px; color: #e0e0e0;">
                                <input type="checkbox" id="isMimic" style="margin-right: 8px;"> 
                                Is Mimic (30% chance by default)
                            </label>
                            
                            <div style="margin: 15px 0;">
                                <h3 style="color: #fbbf24; margin-bottom: 10px;">Initial Contents:</h3>
                                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <input type="text" id="itemName" placeholder="Item name" style="flex: 1; padding: 6px; background: #1f2937; border: 1px solid #374151; border-radius: 4px; color: white;">
                                    <button class="btn btn-small btn-primary" onclick="game.addItemToChestModal()">Add Item</button>
                                </div>
                                <div id="chestItems" style="max-height: 150px; overflow-y: auto; background: #0f0f1e; padding: 10px; border-radius: 4px; border: 1px solid #374151;">
                                    <em style="color: #6b7280;">No items added</em>
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn btn-danger" onclick="this.parentElement.parentElement.parentElement.remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createChestFromModal()">Create Chest</button>
                        </div>
                    </div>
                `;
                
                // Set random mimic chance
                modal.querySelector('#isMimic').checked = Math.random() < 0.3;
                
                document.body.appendChild(modal);
            },
            
            addItemToChestModal() {
                const itemName = document.getElementById('itemName').value.trim();
                if (!itemName) return;
                
                const chestItemsDiv = document.getElementById('chestItems');
                if (!window.chestInventory) window.chestInventory = [];
                
                window.chestInventory.push({name: itemName, description: 'Added manually'});
                
                // Update display
                if (window.chestInventory.length === 1) {
                    chestItemsDiv.innerHTML = '';
                }
                
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0; background: #1f2937; border-radius: 3px;';
                itemDiv.innerHTML = `
                    <span style="color: #e0e0e0;">${itemName}</span>
                    <button onclick="game.removeItemFromChestModal(${window.chestInventory.length - 1})" style="background: #ef4444; color: white; border: none; padding: 2px 6px; border-radius: 2px; cursor: pointer;">√ó</button>
                `;
                chestItemsDiv.appendChild(itemDiv);
                
                document.getElementById('itemName').value = '';
            },
            
            removeItemFromChestModal(index) {
                if (!window.chestInventory) return;
                window.chestInventory.splice(index, 1);
                
                const chestItemsDiv = document.getElementById('chestItems');
                if (window.chestInventory.length === 0) {
                    chestItemsDiv.innerHTML = '<em style="color: #6b7280;">No items added</em>';
                } else {
                    // Rebuild the display
                    chestItemsDiv.innerHTML = '';
                    window.chestInventory.forEach((item, i) => {
                        const itemDiv = document.createElement('div');
                        itemDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0; background: #1f2937; border-radius: 3px;';
                        itemDiv.innerHTML = `
                            <span style="color: #e0e0e0;">${item.name}</span>
                            <button onclick="game.removeItemFromChestModal(${i})" style="background: #ef4444; color: white; border: none; padding: 2px 6px; border-radius: 2px; cursor: pointer;">√ó</button>
                        `;
                        chestItemsDiv.appendChild(itemDiv);
                    });
                }
            },
            
            createChestFromModal() {
                const modal = document.querySelector('.modal-overlay');
                const chestName = document.getElementById('chestName').value || 'Chest';
                const isMimic = document.getElementById('isMimic').checked;
                
                const entity = this.createEntity('container', chestName, 350 + Math.random() * 100, 350 + Math.random() * 100);
                entity.isMimic = isMimic;
                entity.inventory = window.chestInventory ? [...window.chestInventory] : [];
                
                this.entities.push(entity);
                this.render();
                
                // Reset the global inventory
                window.chestInventory = [];
                modal.remove();
            },
            
            addNPC() {
                const name = prompt('Enter NPC name:', 'Merchant');
                if (!name) return;
                
                const entity = this.createEntity('npc', name, 300 + Math.random() * 200, 300 + Math.random() * 200);
                entity.isHostile = false; // NPCs are neutral by default
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
            },
            
            // Library functions
            saveToLibrary(id) {
                const entity = this.getEntity(id);
                if (!entity) return;
                
                const copy = JSON.parse(JSON.stringify(entity));
                delete copy.id;
                delete copy.x;
                delete copy.y;
                delete copy.movement;
                delete copy.actionUsed;
                delete copy.bonusActionUsed;
                delete copy.reactionUsed;
                copy.image = entity.image || '';
                
                if (entity.type === 'player') {
                    if (!this.library.players.some(p => p.name === copy.name)) {
                        this.library.players.push(copy);
                    }
                } else if (entity.type === 'monster') {
                    if (!this.library.monsters.some(m => m.name === copy.name)) {
                        this.library.monsters.push(copy);
                    }
                }
                
                this.saveLibrary();
                this.addLog(`${entity.name} saved to library`, 'info');
                this.populateLibrary();
            },
            
            saveCurrentEntity() {
                if (!this.selectedEntity) {
                    alert('Select an entity first!');
                    return;
                }
                this.saveToLibrary(this.selectedEntity.id);
            },
            
            populateLibrary() {
                const grid = document.getElementById('libraryGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                const all = [
                    ...this.library.monsters.map(m => ({...m, category: 'monster'})),
                    ...this.library.players.map(p => ({...p, category: 'player'})),
                    ...this.library.spells.map(s => ({...s, category: 'spell'})),
                    ...this.library.items.map(i => ({...i, category: 'item'})),
                    ...this.library.equipment.map(e => ({...e, category: 'equipment'}))
                ];
                
                all.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'content-card';
                    card.dataset.type = item.category;
                    card.dataset.name = item.name.toLowerCase();
                    
                    let html = `<h4 style="color: #fbbf24;">${item.name}</h4>`;
                    
                    if (item.category === 'monster' || item.category === 'player') {
                        html += `<p>HP: ${item.hp}/${item.maxHp} | AC: ${item.ac}</p>`;
                        if (item.cr) html += `<p>CR: ${item.cr}</p>`;
                    } else if (item.category === 'spell') {
                        html += `<p>Level ${item.level} ${item.school}</p>`;
                        if (item.damage) html += `<p>Damage: ${item.damage}</p>`;
                        if (item.healing) html += `<p>Healing: ${item.healing}</p>`;
                    } else if (item.category === 'item' || item.category === 'equipment') {
                        if (item.damage) html += `<p>Damage: ${item.damage}</p>`;
                        if (item.ac) html += `<p>AC: ${item.ac}</p>`;
                        if (item.healing) html += `<p>Healing: ${item.healing}</p>`;
                    }
                    
                    if (item.description) {
                        html += `<p style="font-size: 11px; color: #9ca3af;">${item.description.substring(0, 100)}...</p>`;
                    }
                    
                    html += `<button class="btn btn-small btn-primary" onclick="game.addFromLibrary('${item.name}', '${item.category}')">Add to Board</button>`;
                    
                    card.innerHTML = html;
                    grid.appendChild(card);
                });
            },
            
            addFromLibrary(name, category) {
                const x = 300 + Math.random() * 200;
                const y = 200 + Math.random() * 200;
                
                let entity;
                if (category === 'monster' || category === 'player') {
                    entity = this.createEntity(category, name, x, y);
                } else if (category === 'item' || category === 'equipment') {
                    entity = this.createEntity('item', name, x, y);
                }
                
                if (entity) {
                    // Set image from library
                    const libItem = [...this.library.monsters, ...this.library.items, ...this.library.equipment, ...this.library.players, ...this.library.spells].find(i => i.name === name);
                    if (libItem && libItem.image) {
                        entity.image = libItem.image;
                    }
                    this.entities.push(entity);
                    this.updateTurnOrder();
                    this.render();
                    switchTab({target: document.querySelector('.tab.active')}, 'combat');
                }
            },
            
            filterLibrary(filterType) {
                const cards = document.querySelectorAll('.content-card');
                cards.forEach(card => {
                    if (filterType === 'all' || card.dataset.type === filterType) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
            
            searchLibrary(searchTerm) {
                const cards = document.querySelectorAll('.content-card');
                const term = searchTerm.toLowerCase();
                
                cards.forEach(card => {
                    if (card.dataset.name.includes(term)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
            
            // Background functions
            saveBackground() {
                const url = document.getElementById('newBgUrl').value;
                if (url && !this.savedBackgrounds.includes(url)) {
                    this.savedBackgrounds.push(url);
                    localStorage.setItem('dndBackgrounds', JSON.stringify(this.savedBackgrounds));
                    this.updateBackgroundList();
                    document.getElementById('newBgUrl').value = '';
                }
            },
            
            loadBackground(url) {
                document.getElementById('bgUrl').value = url;
                this.changeBackground();
            },
            
            updateBackgroundList() {
                const list = document.getElementById('backgroundList');
                if (!list) return;
                list.innerHTML = '';
                this.savedBackgrounds.forEach(url => {
                    const card = document.createElement('div');
                    card.className = 'background-card';
                    card.style.backgroundImage = `url(${url})`;
                    card.onclick = () => this.loadBackground(url);
                    card.innerHTML = `<div class="background-overlay">Use this</div>`;
                    list.appendChild(card);
                });
            },
            
            loadSavedBackgrounds() {
                const saved = localStorage.getItem('dndBackgrounds');
                if (saved) {
                    this.savedBackgrounds = JSON.parse(saved);
                    this.updateBackgroundList();
                }
            },
            
            // Settings
            toggleGrid() {
                this.showGrid = !this.showGrid;
                const btn = document.getElementById('gridToggle');
                const grid = document.getElementById('gridOverlay');
                
                btn.classList.toggle('active', this.showGrid);
                grid.style.display = this.showGrid ? 'block' : 'none';
            },
            
            toggleTurnEnforcement() {
                this.enforceTurns = !this.enforceTurns;
                const btn = document.getElementById('turnToggle');
                btn.classList.toggle('active', this.enforceTurns);
                this.addLog(`Turn enforcement ${this.enforceTurns ? 'enabled' : 'disabled'}`, 'info');
            },
            
            toggleMovementRange() {
                this.showMovementRange = !this.showMovementRange;
                const btn = document.getElementById('movementToggle');
                btn.classList.toggle('active', this.showMovementRange);
                this.render();
            },
            
            changeBackground() {
                const url = document.getElementById('bgUrl').value;
                this.backgroundUrl = url;
                const board = document.getElementById('gameBoard');
                if (url) {
                    board.style.backgroundImage = `url(${url})`;
                }
            },
            
            // Combat log
            addLog(message, type = 'info') {
                const log = document.getElementById('combatLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = message;
                
                log.insertBefore(entry, log.firstChild);
                if (log.children.length > 15) {
                    log.removeChild(log.lastChild);
                }
            },
            
            // Animations
            createFloatingText(text, x, y, color) {
                const elem = document.createElement('div');
                elem.className = 'floating-text';
                elem.style.left = `${x}px`;
                elem.style.top = `${y}px`;
                elem.style.color = color;
                elem.textContent = text;
                
                document.getElementById('boardCanvas').appendChild(elem);
                setTimeout(() => elem.remove(), 1500);
            },
            
            createArrowAnimation(x1, y1, x2, y2) {
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const distance = Math.hypot(x2 - x1, y2 - y1);
                
                const arrow = document.createElement('div');
                arrow.className = 'arrow-animation';
                arrow.style.left = `${x1}px`;
                arrow.style.top = `${y1}px`;
                arrow.style.transform = `rotate(${angle}rad)`;
                arrow.innerHTML = `<div class="arrow-line" style="width: ${distance}px"></div>`;
                
                document.getElementById('boardCanvas').appendChild(arrow);
                setTimeout(() => arrow.remove(), 500);
            },
            
            createSpellAnimation(x1, y1, x2, y2, school) {
                const colors = {
                    evocation: '#ff4444',
                    abjuration: '#4444ff',
                    conjuration: '#44ff44',
                    divination: '#ffffff',
                    enchantment: '#ff44ff',
                    illusion: '#ff44ff',
                    necromancy: '#444444',
                    transmutation: '#ffff44'
                };
                
                const effect = document.createElement('div');
                effect.className = 'spell-effect';
                effect.style.left = `${x2 - 50}px`;
                effect.style.top = `${y2 - 50}px`;
                effect.innerHTML = `<div class="magic-circle" style="border-color: ${colors[school] || '#8b5cf6'}"></div>`;
                
                document.getElementById('boardCanvas').appendChild(effect);
                setTimeout(() => effect.remove(), 1000);
            },
            
            // Save/Load
            saveGameState() {
                const state = {
                    entities: this.entities.map(e => ({...e, image: e.image || ''})),
                    currentTurn: this.currentTurn,
                    turnOrder: this.turnOrder,
                    roundNumber: this.roundNumber,
                    nextId: this.nextId,
                    editMode: this.editMode,
                    backgroundUrl: this.backgroundUrl
                };
                
                localStorage.setItem('dndGameState', JSON.stringify(state));
                this.addLog('Game saved!', 'info');
            },
            
            loadGameState() {
                const saved = localStorage.getItem('dndGameState');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        this.entities = state.entities || [];
                        this.currentTurn = state.currentTurn || 0;
                        this.turnOrder = state.turnOrder || [];
                        this.roundNumber = state.roundNumber || 1;
                        this.nextId = state.nextId || 1;
                        this.editMode = state.editMode || false;
                        this.backgroundUrl = state.backgroundUrl || '';
                        document.getElementById('bgUrl').value = this.backgroundUrl;
                        this.changeBackground();
                        this.entities.forEach(e => {
                            if (state.entities.find(se => se.id === e.id)) {
                                e.image = state.entities.find(se => se.id === e.id).image || '';
                            }
                        });
                        this.render();
                        this.updateTurnOrder();
                        document.getElementById('editToggle').classList.toggle('active', this.editMode);
                        this.addLog('Game loaded!', 'info');
                    } catch (e) {
                        console.error('Failed to load game state:', e);
                    }
                }
            },
            
            clearBoard() {
                if (confirm('Clear all entities from the board?')) {
                    this.entities = [];
                    this.selectedEntity = null;
                    this.currentTurn = 0;
                    this.turnOrder = [];
                    this.roundNumber = 1;
                    this.render();
                    this.updateTurnOrder();
                    this.addLog('Board cleared', 'info');
                }
            },
            
            // Import/Export
            exportLibrary() {
                const data = JSON.stringify(this.library, null, 2);
                document.getElementById('exportData').value = data;
            },
            
            importLibrary() {
                try {
                    const data = JSON.parse(document.getElementById('importData').value);
                    
                    // Merge libraries
                    ['monsters', 'spells', 'items', 'equipment', 'players'].forEach(key => {
                        if (data[key] && Array.isArray(data[key])) {
                            data[key].forEach(newItem => {
                                if (!this.library[key].some(item => item.name === newItem.name)) {
                                    this.library[key].push(newItem);
                                }
                            });
                        }
                    });
                    
                    this.saveLibrary();
                    this.populateLibrary();
                    alert('Library imported successfully!');
                } catch (e) {
                    alert('Invalid JSON data!');
                }
            },
            
            saveLibrary() {
                localStorage.setItem('dndLibrary', JSON.stringify(this.library));
            },
            
            loadLibrary() {
                const saved = localStorage.getItem('dndLibrary');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        // Merge with existing library
                        Object.keys(data).forEach(key => {
                            if (Array.isArray(data[key])) {
                                data[key].forEach(item => {
                                    if (!this.library[key].some(existing => existing.name === item.name)) {
                                        this.library[key].push(item);
                                    }
                                });
                            }
                        });
                    } catch (e) {
                        console.error('Failed to load library:', e);
                    }
                }
            },
            
            // Setup quick add buttons
            setupQuickAdd() {
                const grid = document.getElementById('quickAddGrid');
                if (!grid) return;
                
                const quickItems = [
                    ...this.library.monsters.slice(0, 4),
                    ...this.library.players.slice(0, 4)
                ];
                
                quickItems.forEach(item => {
                    const btn = document.createElement('button');
                    btn.className = 'quick-add-btn';
                    btn.textContent = item.name;
                    btn.onclick = () => {
                        const type = item.type || (item.class ? 'player' : 'monster');
                        const entity = this.createEntity(type, item.name, 300 + Math.random() * 200, 200 + Math.random() * 200);
                        if (item.image) entity.image = item.image;
                        this.entities.push(entity);
                        this.updateTurnOrder();
                        this.render();
                    };
                    grid.appendChild(btn);
                });
            },
            
            // Character sheet functions
            updateCharacterList() {
                const list = document.getElementById('characterList');
                if (!list) return;
                
                list.innerHTML = '';
                
                this.entities.filter(e => e.type === 'player').forEach(player => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    card.innerHTML = `
                        <h4 style="color: #fbbf24;">${player.name}</h4>
                        <p>${player.race} ${player.class} - Level ${player.level}</p>
                        <p>HP: ${player.hp}/${player.maxHp} | AC: ${this.calculateAC(player)}</p>
                    `;
                    card.onclick = () => this.showCharacterSheet(player);
                    list.appendChild(card);
                });
            },
            
            showCharacterSheet(player) {
                const content = document.getElementById('sheetContent');
                if (!content) return;
                
                content.style.display = 'block';
                
                const strMod = this.getAbilityModifier(player.str);
                const dexMod = this.getAbilityModifier(player.dex);
                const conMod = this.getAbilityModifier(player.con);
                const intMod = this.getAbilityModifier(player.int);
                const wisMod = this.getAbilityModifier(player.wis);
                const chaMod = this.getAbilityModifier(player.cha);
                
                let html = `
                    <h2 style="color: #fbbf24;">${player.name}'s Character Sheet</h2>
                    <p>${player.race} ${player.class} - Level ${player.level}</p>
                    
                    <h3>Ability Scores</h3>
                    <div class="ability-scores">
                        <div class="ability-score">
                            <div>STR</div>
                            <div style="font-size: 24px;">${player.str}</div>
                            <div>${strMod >= 0 ? '+' : ''}${strMod}</div>
                        </div>
                        <div class="ability-score">
                            <div>DEX</div>
                            <div style="font-size: 24px;">${player.dex}</div>
                            <div>${dexMod >= 0 ? '+' : ''}${dexMod}</div>
                        </div>
                        <div class="ability-score">
                            <div>CON</div>
                            <div style="font-size: 24px;">${player.con}</div>
                            <div>${conMod >= 0 ? '+' : ''}${conMod}</div>
                        </div>
                        <div class="ability-score">
                            <div>INT</div>
                            <div style="font-size: 24px;">${player.int}</div>
                            <div>${intMod >= 0 ? '+' : ''}${intMod}</div>
                        </div>
                        <div class="ability-score">
                            <div>WIS</div>
                            <div style="font-size: 24px;">${player.wis}</div>
                            <div>${wisMod >= 0 ? '+' : ''}${wisMod}</div>
                        </div>
                        <div class="ability-score">
                            <div>CHA</div>
                            <div style="font-size: 24px;">${player.cha}</div>
                            <div>${chaMod >= 0 ? '+' : ''}${chaMod}</div>
                        </div>
                    </div>
                    
                    <h3>Combat Stats</h3>
                    <div class="stat-group">
                        <div class="stat-box">
                            <div class="stat-label">HP</div>
                            <div class="stat-value">${player.hp}/${player.maxHp}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">AC</div>
                            <div class="stat-value">${this.calculateAC(player)}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Speed</div>
                            <div class="stat-value">${player.speed}ft</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Initiative</div>
                            <div class="stat-value">${dexMod >= 0 ? '+' : ''}${dexMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Prof Bonus</div>
                            <div class="stat-value">+${player.proficiencyBonus}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Hit Dice</div>
                            <div class="stat-value">${player.hitDiceRemaining}${player.hitDice}</div>
                        </div>
                    </div>
                    
                    <h3>Saving Throws</h3>
                    <div class="skill-list">
                        <div class="skill-item">
                            <span>Strength</span>
                            <span>${strMod >= 0 ? '+' : ''}${strMod + (player.savingThrows.str || 0)}</span>
                        </div>
                        <div class="skill-item">
                            <span>Dexterity</span>
                            <span>${dexMod >= 0 ? '+' : ''}${dexMod + (player.savingThrows.dex || 0)}</span>
                        </div>
                        <div class="skill-item">
                            <span>Constitution</span>
                            <span>${conMod >= 0 ? '+' : ''}${conMod + (player.savingThrows.con || 0)}</span>
                        </div>
                        <div class="skill-item">
                            <span>Intelligence</span>
                            <span>${intMod >= 0 ? '+' : ''}${intMod + (player.savingThrows.int || 0)}</span>
                        </div>
                        <div class="skill-item">
                            <span>Wisdom</span>
                            <span>${wisMod >= 0 ? '+' : ''}${wisMod + (player.savingThrows.wis || 0)}</span>
                        </div>
                        <div class="skill-item">
                            <span>Charisma</span>
                            <span>${chaMod >= 0 ? '+' : ''}${chaMod + (player.savingThrows.cha || 0)}</span>
                        </div>
                    </div>
                    
                    <h3>Skills</h3>
                    <div class="skill-list">
                        ${Object.entries(this.skillsList).map(([skill, ability]) => {
                            const mod = this.getAbilityModifier(player[ability]);
                            const bonus = player.skills[skill] || mod;
                            return `
                                <div class="skill-item">
                                    <span>${skill.replace(/([A-Z])/g, ' $1').trim()}</span>
                                    <span>${bonus >= 0 ? '+' : ''}${bonus}</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <h3>Attacks</h3>
                    ${player.attacks.map(a => `
                        <div class="stat-row">
                            <span>${a.name}</span>
                            <span>+${a.toHit} to hit, ${a.damage} ${a.damageType}</span>
                        </div>
                    `).join('')}
                    
                    <h3>Spells</h3>
                    <div class="stat-group">
                        ${[1,2,3,4,5,6,7,8,9].map(level => {
                            if (!player.spellSlots[level]) return '';
                            return `
                                <div class="stat-box">
                                    <div class="stat-label">Level ${level}</div>
                                    <div>${player.spellSlotsUsed[level]}/${player.spellSlots[level]}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    ${player.spells.map(s => `
                        <div class="stat-row">
                            <span>${s.name} (Level ${s.level})</span>
                        </div>
                    `).join('')}
                    
                    <h3>Equipment</h3>
                    ${Object.entries(player.equipment).filter(([slot, item]) => item).map(([slot, item]) => `
                        <div class="stat-row">
                            <span>${slot}:</span>
                            <span>${item.name}</span>
                        </div>
                    `).join('')}
                    
                    <h3>Inventory</h3>
                    ${player.inventory.map(i => `
                        <div class="stat-row">
                            <span>${i.name}</span>
                        </div>
                    `).join('')}
                `;
                
                content.innerHTML = html;
            }
        };
        
        // Global tab switching function
        function switchTab(event, tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            if (tabName === 'characters') game.updateCharacterList();
            if (tabName === 'backgrounds') game.updateBackgroundList();
        }
        
        // Initialize the game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
    </script>
</body>
</html> 'Goblin',
                        type: 'monster',
                        hp: 7, maxHp: 7, ac: 15, speed: 30,
                        str: 8, dex: 14, con: 10, int: 10, wis: 8, cha: 8,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Scimitar', toHit: 4, damage: '1d6+2', damageType: 'slashing', range: 5}],
                        abilities: [{name: 'Nimble Escape', description: 'Disengage or Hide as bonus action', actionType: 'bonus'}],
                        skills: {stealth: 6},
                        savingThrows: {str: -1, dex: 2, con: 0, int: 0, wis: -1, cha: -1},
                        color: '#4a7c59',
                        cr: 0.25,
                        description: 'Small green-skinned humanoid, sneaky and aggressive.',
                        image: ''
                    },
                    {
                        name: 'Orc',
                        type: 'monster',
                        hp: 15, maxHp: 15, ac: 13, speed: 30,
                        str: 16, dex: 12, con: 16, int: 7, wis: 11, cha: 10,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Greataxe', toHit: 5, damage: '1d12+3', damageType: 'slashing', range: 5}],
                        abilities: [{name: 'Aggressive', description: 'Bonus action to move up to speed toward enemy', actionType: 'bonus'}],
                        skills: {intimidation: 2},
                        savingThrows: {str: 3, dex: 1, con: 3, int: -2, wis: 0, cha: 0},
                        color: '#8b4513',
                        cr: 0.5,
                        description: 'Savage humanoid warrior with gray skin and tusks.',
                        image: ''
                    },
                    {
                        name: 'Skeleton',
                        type: 'monster',
                        hp: 13, maxHp: 13, ac: 13, speed: 30,
                        str: 10, dex: 14, con: 15, int: 6, wis: 8, cha: 5,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Shortsword', toHit: 4, damage: '1d6+2', damageType: 'piercing', range: 5}],
                        damageVulnerabilities: ['bludgeoning'],
                        damageImmunities: ['poison'],
                        conditionImmunities: ['exhaustion', 'poisoned'],
                        skills: {},
                        savingThrows: {str: 0, dex: 2, con: 2, int: -2, wis: -1, cha: -3},
                        color: '#a9a9a9',
                        cr: 0.25,
                        description: 'Animated undead bones, immune to poison.',
                        image: ''
                    },
                    {
                        name: 'Zombie',
                        type: 'monster',
                        hp: 22, maxHp: 22, ac: 8, speed: 20,
                        str: 13, dex: 6, con: 16, int: 3, wis: 6, cha: 5,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Slam', toHit: 3, damage: '1d6+1', damageType: 'bludgeoning', range: 5}],
                        abilities: [{name: 'Undead Fortitude', description: 'If damage reduces to 0 HP, Con save DC 5+damage. On success, drop to 1 HP instead', actionType: 'special'}],
                        damageImmunities: ['poison'],
                        conditionImmunities: ['poisoned'],
                        skills: {},
                        savingThrows: {str: 1, dex: -2, con: 3, int: -4, wis: -2, cha: -3},
                        color: '#556b2f',
                        cr: 0.25,
                        description: 'Shambling undead corpse, slow but resilient.',
                        image: ''
                    },
                    {
                        name: 'Wolf',
                        type: 'monster',
                        hp: 11, maxHp: 11, ac: 13, speed: 40,
                        str: 12, dex: 15, con: 12, int: 3, wis: 12, cha: 6,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Bite', toHit: 4, damage: '2d4+2', damageType: 'piercing', range: 5, special: 'DC 11 Str save or knocked prone'}],
                        abilities: [{name: 'Pack Tactics', description: 'Advantage on attack if ally within 5ft of target', actionType: 'passive'}],
                        skills: {perception: 3, stealth: 4},
                        savingThrows: {str: 1, dex: 2, con: 1, int: -4, wis: 1, cha: -2},
                        color: '#808080',
                        cr: 0.25,
                        description: 'Pack-hunting beast with keen senses.',
                        image: ''
                    },
                    {
                        name: 'Bugbear',
                        type: 'monster',
                        hp: 27, maxHp: 27, ac: 16, speed: 30,
                        str: 15, dex: 14, con: 13, int: 8, wis: 11, cha: 9,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Morningstar', toHit: 4, damage: '2d8+2', damageType: 'piercing', range: 5}],
                        abilities: [
                            {name: 'Brute', description: 'Extra die of weapon damage on melee hit', actionType: 'passive'},
                            {name: 'Surprise Attack', description: 'Extra 2d6 damage if target is surprised', actionType: 'passive'}
                        ],
                        skills: {stealth: 6, survival: 2},
                        savingThrows: {str: 2, dex: 2, con: 1, int: -1, wis: 0, cha: -1},
                        color: '#8b4513',
                        cr: 1,
                        description: 'Large goblinoid with furry body, sneaky ambusher.',
                        image: ''
                    },
                    {
                        name: 'Hobgoblin',
                        type: 'monster',
                        hp: 11, maxHp: 11, ac: 18, speed: 30,
                        str: 13, dex: 12, con: 12, int: 10, wis: 10, cha: 9,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Longsword', toHit: 3, damage: '1d8+1', damageType: 'slashing', range: 5}],
                        abilities: [{name: 'Martial Advantage', description: 'Extra 2d6 damage if ally within 5ft of target', actionType: 'passive'}],
                        skills: {},
                        savingThrows: {str: 1, dex: 1, con: 1, int: 0, wis: 0, cha: -1},
                        color: '#a52a2a',
                        cr: 0.5,
                        description: 'Militaristic goblinoid, disciplined fighter.',
                        image: ''
                    },
                    {
                        name: 'Kobold',
                        type: 'monster',
                        hp: 5, maxHp: 5, ac: 12, speed: 30,
                        str: 7, dex: 15, con: 9, int: 8, wis: 7, cha: 8,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Dagger', toHit: 4, damage: '1d4+2', damageType: 'piercing', range: 5}],
                        abilities: [
                            {name: 'Pack Tactics', description: 'Advantage if ally within 5ft', actionType: 'passive'},
                            {name: 'Sunlight Sensitivity', description: 'Disadvantage in sunlight', actionType: 'passive'}
                        ],
                        skills: {},
                        savingThrows: {str: -2, dex: 2, con: -1, int: -1, wis: -2, cha: -1},
                        color: '#cd853f',
                        cr: 0.125,
                        description: 'Small reptilian humanoid, trap-maker and pack hunter.',
                        image: ''
                    },
                    {
                        name: 'Gnoll',
                        type: 'monster',
                        hp: 22, maxHp: 22, ac: 15, speed: 30,
                        str: 14, dex: 12, con: 11, int: 6, wis: 10, cha: 7,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Bite', toHit: 4, damage: '1d4+2', damageType: 'piercing', range: 5}],
                        abilities: [{name: 'Rampage', description: 'Move and attack after reducing enemy to 0 HP', actionType: 'reaction'}],
                        skills: {},
                        savingThrows: {str: 2, dex: 1, con: 0, int: -2, wis: 0, cha: -2},
                        color: '#d2691e',
                        cr: 0.5,
                        description: 'Hyena-like humanoid, savage and demonic.',
                        image: ''
                    },
                    {
                        name: 'Ogre',
                        type: 'monster',
                        hp: 59, maxHp: 59, ac: 11, speed: 40,
                        str: 19, dex: 8, con: 16, int: 5, wis: 7, cha: 7,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Greatclub', toHit: 6, damage: '2d8+4', damageType: 'bludgeoning', range: 5}],
                        abilities: [],
                        skills: {},
                        savingThrows: {str: 4, dex: -1, con: 3, int: -3, wis: -2, cha: -2},
                        color: '#556b2f',
                        cr: 2,
                        description: 'Large, brutish giant with low intelligence.',
                        image: ''
                    },
                    {
                        name: 'Troll',
                        type: 'monster',
                        hp: 84, maxHp: 84, ac: 15, speed: 30,
                        str: 18, dex: 13, con: 20, int: 7, wis: 9, cha: 7,
                        proficiencyBonus: 3,
                        attacks: [
                            {name: 'Bite', toHit: 7, damage: '1d6+4', damageType: 'piercing', range: 5},
                            {name: 'Claw', toHit: 7, damage: '2d6+4', damageType: 'slashing', range: 5}
                        ],
                        abilities: [{name: 'Regeneration', description: 'Regain 10 HP at start of turn unless took fire/acid damage', actionType: 'passive'}],
                        skills: {},
                        savingThrows: {str: 4, dex: 1, con: 5, int: -2, wis: -1, cha: -2},
                        color: '#006400',
                        cr: 5,
                        description: 'Tall, lanky giant that regenerates.',
                        image: ''
                    },
                    {
                        name: 'Giant Spider',
                        type: 'monster',
                        hp: 26, maxHp: 26, ac: 14, speed: 30,
                        str: 14, dex: 16, con: 12, int: 2, wis: 11, cha: 4,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing', range: 5, special: 'DC 11 Con save or 2d8 poison damage'}],
                        abilities: [
                            {name: 'Spider Climb', description: 'Can climb difficult surfaces', actionType: 'passive'},
                            {name: 'Web Sense', description: 'Knows location of creatures touching web', actionType: 'passive'}
                        ],
                        skills: {stealth: 7},
                        savingThrows: {str: 2, dex: 3, con: 1, int: -4, wis: 0, cha: -3},
                        color: '#000000',
                        cr: 1,
                        description: 'Large arachnid with venomous bite.',
                        image: ''
                    },
                    {
                        name: 'Owlbear',
                        type: 'monster',
                        hp: 59, maxHp: 59, ac: 13, speed: 40,
                        str: 20, dex: 12, con: 17, int: 3, wis: 12, cha: 7,
                        proficiencyBonus: 2,
                        attacks: [
                            {name: 'Beak', toHit: 7, damage: '1d10+5', damageType: 'piercing', range: 5},
                            {name: 'Claw', toHit: 7, damage: '2d8+5', damageType: 'slashing', range: 5}
                        ],
                        abilities: [{name: 'Keen Sight', description: 'Advantage on Perception checks using sight', actionType: 'passive'}],
                        skills: {perception: 3},
                        savingThrows: {str: 5, dex: 1, con: 3, int: -4, wis: 1, cha: -2},
                        color: '#654321',
                        cr: 3,
                        description: 'Monstrous hybrid of owl and bear.',
                        image: ''
                    },
                    {
                        name: 'Mimic',
                        type: 'monster',
                        hp: 58, maxHp: 58, ac: 12, speed: 15,
                        str: 17, dex: 12, con: 15, int: 5, wis: 13, cha: 8,
                        proficiencyBonus: 2,
                        attacks: [
                            {name: 'Pseudopod', toHit: 5, damage: '1d8+3', damageType: 'bludgeoning', range: 5},
                            {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing', range: 5, special: 'Grapples target (escape DC 13)'}
                        ],
                        abilities: [
                            {name: 'Shapechanger', description: 'Can polymorph into object', actionType: 'action'},
                            {name: 'Adhesive', description: 'Adheres to anything that touches it', actionType: 'passive'}
                        ],
                        skills: {stealth: 5},
                        savingThrows: {str: 3, dex: 1, con: 2, int: -3, wis: 1, cha: -1},
                        color: '#8B4513',
                        cr: 2,
                        description: 'Shapeshifting predator that mimics objects.',
                        image: ''
                    },
                    {
                        name: 'Gelatinous Cube',
                        type: 'monster',
                        hp: 84, maxHp: 84, ac: 6, speed: 15,
                        str: 14, dex: 3, con: 20, int: 1, wis: 6, cha: 1,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Pseudopod', toHit: 4, damage: '3d6', damageType: 'acid', range: 5}],
                        abilities: [
                            {name: 'Transparent', description: 'DC 15 Perception to notice', actionType: 'passive'},
                            {name: 'Engulf', description: 'Can move through enemy space, DC 12 Dex save or engulfed', actionType: 'action'}
                        ],
                        conditionImmunities: ['blinded', 'charmed', 'deafened', 'exhaustion', 'frightened', 'prone'],
                        skills: {},
                        savingThrows: {str: 2, dex: -4, con: 5, int: -5, wis: -2, cha: -5},
                        color: '#90EE90',
                        cr: 2,
                        description: 'Transparent ooze that dissolves organic matter.',
                        image: ''
                    },
                    {
                        name: 'Dire Wolf',
                        type: 'monster',
                        hp: 37, maxHp: 37, ac: 14, speed: 50,
                        str: 17, dex: 15, con: 15, int: 3, wis: 12, cha: 7,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Bite', toHit: 5, damage: '2d6+3', damageType: 'piercing', range: 5, special: 'DC 13 Str save or knocked prone'}],
                        abilities: [
                            {name: 'Pack Tactics', description: 'Advantage if ally within 5ft', actionType: 'passive'},
                            {name: 'Keen Hearing and Smell', description: 'Advantage on Perception using hearing/smell', actionType: 'passive'}
                        ],
                        skills: {perception: 3, stealth: 4},
                        savingThrows: {str: 3, dex: 2, con: 2, int: -4, wis: 1, cha: -2},
                        color: '#696969',
                        cr: 1,
                        description: 'Large, fierce wolf.',
                        image: ''
                    },
                    {
                        name: 'Wight',
                        type: 'monster',
                        hp: 45, maxHp: 45, ac: 14, speed: 30,
                        str: 15, dex: 14, con: 16, int: 10, wis: 13, cha: 15,
                        proficiencyBonus: 2,
                        attacks: [
                            {name: 'Life Drain', toHit: 4, damage: '1d6+2', damageType: 'necrotic', range: 5, special: 'DC 13 Con save or max HP reduced by damage taken'},
                            {name: 'Longsword', toHit: 4, damage: '1d8+2', damageType: 'slashing', range: 5}
                        ],
                        abilities: [{name: 'Sunlight Sensitivity', description: 'Disadvantage in sunlight', actionType: 'passive'}],
                        damageResistances: ['necrotic', 'bludgeoning', 'piercing', 'slashing'],
                        damageImmunities: ['poison'],
                        conditionImmunities: ['exhaustion', 'poisoned'],
                        skills: {perception: 3, stealth: 4},
                        savingThrows: {str: 2, dex: 2, con: 3, int: 0, wis: 1, cha: 2},
                        color: '#483D8B',
                        cr: 3,
                        description: 'Undead warrior that drains life force.',
                        image: ''
                    },
                    {
                        name: 'Basilisk',
                        type: 'monster',
                        hp: 52, maxHp: 52, ac: 15, speed: 20,
                        str: 16, dex: 8, con: 15, int: 2, wis: 8, cha: 7,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Bite', toHit: 5, damage: '2d6+3', damageType: 'piercing', range: 5, special: 'Plus 2d6 poison damage'}],
                        abilities: [{name: 'Petrifying Gaze', description: 'DC 12 Con save or begin turning to stone', actionType: 'action'}],
                        skills: {},
                        savingThrows: {str: 3, dex: -1, con: 2, int: -4, wis: -1, cha: -2},
                        color: '#2F4F4F',
                        cr: 3,
                        description: 'Eight-legged reptile with deadly gaze.',
                        image: ''
                    },
                    {
                        name: 'Manticore',
                        type: 'monster',
                        hp: 68, maxHp: 68, ac: 14, speed: 30,
                        str: 17, dex: 16, con: 17, int: 7, wis: 12, cha: 8,
                        proficiencyBonus: 3,
                        attacks: [
                            {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing', range: 5},
                            {name: 'Claw', toHit: 5, damage: '1d6+3', damageType: 'slashing', range: 5},
                            {name: 'Tail Spike', toHit: 5, damage: '1d8+3', damageType: 'piercing', range: 100, ranged: true}
                        ],
                        abilities: [{name: 'Tail Spike Regrowth', description: 'Regrows 24 tail spikes per day', actionType: 'passive'}],
                        skills: {},
                        savingThrows: {str: 3, dex: 3, con: 3, int: -2, wis: 1, cha: -1},
                        color: '#B22222',
                        cr: 3,
                        description: 'Lion body with human face and spiked tail.',
                        image: ''
                    },
                    {
                        name: 'Vampire Spawn',
                        type: 'monster',
                        hp: 82, maxHp: 82, ac: 15, speed: 30,
                        str: 16, dex: 16, con: 16, int: 11, wis: 10, cha: 12,
                        proficiencyBonus: 3,
                        attacks: [
                            {name: 'Bite', toHit: 6, damage: '1d6+3', damageType: 'piercing', range: 5, special: 'Plus 2d6 necrotic, max HP reduced'},
                            {name: 'Claws', toHit: 6, damage: '2d4+3', damageType: 'slashing', range: 5}
                        ],
                        abilities: [
                            {name: 'Spider Climb', description: 'Can climb difficult surfaces', actionType: 'passive'},
                            {name: 'Regeneration', description: 'Regain 10 HP at start of turn unless radiant damage or running water', actionType: 'passive'}
                        ],
                        damageResistances: ['necrotic', 'bludgeoning', 'piercing', 'slashing'],
                        skills: {perception: 3, stealth: 6},
                        savingThrows: {str: 3, dex: 3, con: 3, int: 0, wis: 0, cha: 1},
                        color: '#8B0000',
                        cr: 5,
                        description: 'Lesser vampire under control of creator.',
                        image: ''
                    }
                ],
                spells: [
                    {
                        name: 'Fireball',
                        type: 'spell',
                        level: 3,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 150,
                        components: 'V, S, M',
                        duration: 'instantaneous',
                        damage: '8d6',
                        damageType: 'fire',
                        savingThrow: 'dexterity',
                        saveDC: 15,
                        aoe: '20-foot radius sphere',
                        description: 'Each creature in a 20-foot-radius sphere must make a Dexterity saving throw. Takes 8d6 fire damage on failed save, half on success.',
                        higherLevel: 'Additional 1d6 damage per spell slot above 3rd',
                        image: ''
                    },
                    {
                        name: 'Cure Wounds',
                        type: 'spell',
                        level: 1,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 'touch',
                        components: 'V, S',
                        duration: 'instantaneous',
                        healing: '1d8+3',
                        description: 'A creature you touch regains 1d8 + spellcasting modifier hit points.',
                        higherLevel: 'Additional 1d8 healing per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Shield',
                        type: 'spell',
                        level: 1,
                        school: 'abjuration',
                        castingTime: 'reaction',
                        range: 'self',
                        components: 'V, S',
                        duration: '1 round',
                        effect: {type: 'ac_bonus', value: 5},
                        description: '+5 bonus to AC until start of next turn, including against triggering attack.',
                        image: ''
                    },
                    {
                        name: 'Mage Armor',
                        type: 'spell',
                        level: 1,
                        school: 'abjuration',
                        castingTime: 'action',
                        range: 'touch',
                        components: 'V, S, M',
                        duration: '8 hours',
                        effect: {type: 'ac_set', value: 13},
                        description: 'Target\'s base AC becomes 13 + Dex modifier.',
                        image: ''
                    },
                    {
                        name: 'Lightning Bolt',
                        type: 'spell',
                        level: 3,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 'self',
                        components: 'V, S, M',
                        duration: 'instantaneous',
                        damage: '8d6',
                        damageType: 'lightning',
                        savingThrow: 'dexterity',
                        saveDC: 15,
                        aoe: '100-foot line',
                        description: 'Each creature in line must make Dexterity saving throw. Takes 8d6 lightning damage on failed save, half on success.',
                        higherLevel: 'Additional 1d6 damage per spell slot above 3rd',
                        image: ''
                    },
                    {
                        name: 'Magic Missile',
                        type: 'spell',
                        level: 1,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 120,
                        components: 'V, S',
                        duration: 'instantaneous',
                        damage: '1d4+1',
                        damageType: 'force',
                        missiles: 3,
                        description: 'Create 3 darts dealing 1d4+1 force damage each. Automatically hit.',
                        higherLevel: 'One additional dart per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Burning Hands',
                        type: 'spell',
                        level: 1,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 'self',
                        components: 'V, S',
                        duration: 'instantaneous',
                        damage: '3d6',
                        damageType: 'fire',
                        savingThrow: 'dexterity',
                        saveDC: 13,
                        aoe: '15-foot cone',
                        description: 'Each creature in cone must make Dexterity saving throw. Takes 3d6 fire damage on failed save, half on success.',
                        higherLevel: 'Additional 1d6 damage per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Sleep',
                        type: 'spell',
                        level: 1,
                        school: 'enchantment',
                        castingTime: 'action',
                        range: 90,
                        components: 'V, S, M',
                        duration: '1 minute',
                        effect: {type: 'sleep', hitpoints: '5d8'},
                        description: 'Roll 5d8. Creatures within 20 feet fall unconscious in ascending order of HP until total exceeded.',
                        higherLevel: 'Additional 2d8 per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Hold Person',
                        type: 'spell',
                        level: 2,
                        school: 'enchantment',
                        castingTime: 'action',
                        range: 60,
                        components: 'V, S, M',
                        duration: '1 minute',
                        effect: {type: 'condition', condition: 'paralyzed'},
                        savingThrow: 'wisdom',
                        saveDC: 14,
                        description: 'Target must make Wisdom saving throw or be paralyzed. Can repeat save at end of turns.',
                        higherLevel: 'Target one additional creature per spell slot above 2nd',
                        image: ''
                    },
                    {
                        name: 'Invisibility',
                        type: 'spell',
                        level: 2,
                        school: 'illusion',
                        castingTime: 'action',
                        range: 'touch',
                        components: 'V, S, M',
                        duration: '1 hour',
                        effect: {type: 'condition', condition: 'invisible'},
                        description: 'Target becomes invisible until spell ends or target attacks/casts spell.',
                        higherLevel: 'Target one additional creature per spell slot above 2nd',
                        image: ''
                    },
                    {
                        name: 'Haste',
                        type: 'spell',
                        level: 3,
                        school: 'transmutation',
                        castingTime: 'action',
                        range: 30,
                        components: 'V, S, M',
                        duration: '1 minute',
                        effect: {type: 'buff', effects: ['double speed', '+2 AC', 'advantage on Dex saves', 'additional action']},
                        description: 'Target gains double speed, +2 AC, advantage on Dex saves, and additional action each turn.',
                        concentration: true,
                        image: ''
                    },
                    {
                        name: 'Counterspell',
                        type: 'spell',
                        level: 3,
                        school: 'abjuration',
                        castingTime: 'reaction',
                        range: 60,
                        components: 'S',
                        duration: 'instantaneous',
                        effect: {type: 'counter'},
                        description: 'Interrupt creature casting spell of 3rd level or lower. Higher levels require ability check.',
                        higherLevel: 'Automatically counter spell of this level or lower',
                        image: ''
                    },
                    {
                        name: 'Healing Word',
                        type: 'spell',
                        level: 1,
                        school: 'evocation',
                        castingTime: 'bonus action',
                        range: 60,
                        components: 'V',
                        duration: 'instantaneous',
                        healing: '1d4+3',
                        description: 'Creature within range regains 1d4 + spellcasting modifier hit points.',
                        higherLevel: 'Additional 1d4 healing per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Bless',
                        type: 'spell',
                        level: 1,
                        school: 'enchantment',
                        castingTime: 'action',
                        range: 30,
                        components: 'V, S, M',
                        duration: '1 minute',
                        effect: {type: 'buff', effects: ['+1d4 to attack rolls and saving throws']},
                        targets: 3,
                        description: 'Up to 3 creatures add 1d4 to attack rolls and saving throws.',
                        concentration: true,
                        higherLevel: 'Target one additional creature per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Bane',
                        type: 'spell',
                        level: 1,
                        school: 'enchantment',
                        castingTime: 'action',
                        range: 30,
                        components: 'V, S, M',
                        duration: '1 minute',
                        effect: {type: 'debuff', effects: ['-1d4 to attack rolls and saving throws']},
                        savingThrow: 'charisma',
                        saveDC: 13,
                        targets: 3,
                        description: 'Up to 3 creatures must make Charisma save or subtract 1d4 from attack rolls and saves.',
                        concentration: true,
                        higherLevel: 'Target one additional creature per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Dispel Magic',
                        type: 'spell',
                        level: 3,
                        school: 'abjuration',
                        castingTime: 'action',
                        range: 120,
                        components: 'V, S',
                        duration: 'instantaneous',
                        effect: {type: 'dispel'},
                        description: 'End spells of 3rd level or lower on target. Higher levels require ability check.',
                        higherLevel: 'Automatically dispel spell of this level or lower',
                        image: ''
                    },
                    {
                        name: 'Misty Step',
                        type: 'spell',
                        level: 2,
                        school: 'conjuration',
                        castingTime: 'bonus action',
                        range: 'self',
                        components: 'V',
                        duration: 'instantaneous',
                        effect: {type: 'teleport', distance: 30},
                        description: 'Teleport up to 30 feet to unoccupied space you can see.',
                        image: ''
                    },
                    {
                        name: 'Thunderwave',
                        type: 'spell',
                        level: 1,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 'self',
                        components: 'V, S',
                        duration: 'instantaneous',
                        damage: '2d8',
                        damageType: 'thunder',
                        savingThrow: 'constitution',
                        saveDC: 13,
                        aoe: '15-foot cube',
                        effect: {type: 'push', distance: 10},
                        description: 'Each creature in cube must make Con save. Takes 2d8 thunder damage and pushed 10 feet on fail.',
                        higherLevel: 'Additional 1d8 damage per spell slot above 1st',
                        image: ''
                    },
                    {
                        name: 'Web',
                        type: 'spell',
                        level: 2,
                        school: 'conjuration',
                        castingTime: 'action',
                        range: 60,
                        components: 'V, S, M',
                        duration: '1 hour',
                        effect: {type: 'restrain'},
                        savingThrow: 'dexterity',
                        saveDC: 14,
                        aoe: '20-foot cube',
                        description: 'Creates webs in 20-foot cube. Creatures must make Dex save or be restrained.',
                        concentration: true,
                        image: ''
                    },
                    {
                        name: 'Darkness',
                        type: 'spell',
                        level: 2,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 60,
                        components: 'V, M',
                        duration: '10 minutes',
                        effect: {type: 'obscure'},
                        aoe: '15-foot radius sphere',
                        description: 'Magical darkness spreads in 15-foot radius. Darkvision cannot see through it.',
                        concentration: true,
                        image: ''
                    }
                ],
                items: [
                    {
                        name: 'Healing Potion',
                        type: 'potion',
                        rarity: 'common',
                        healing: '2d4+2',
                        value: 50,
                        weight: 0.5,
                        description: 'Regain 2d4+2 hit points when consumed.',
                        consumable: true,
                        image: ''
                    },
                    {
                        name: 'Greater Healing Potion',
                        type: 'potion',
                        rarity: 'uncommon',
                        healing: '4d4+4',
                        value: 150,
                        weight: 0.5,
                        description: 'Regain 4d4+4 hit points when consumed.',
                        consumable: true,
                        image: ''
                    },
                    {
                        name: 'Potion of Speed',
                        type: 'potion',
                        rarity: 'very rare',
                        effect: {type: 'buff', effects: ['double speed', 'additional action'], duration: 1},
                        value: 400,
                        weight: 0.5,
                        description: 'Gain effects of haste spell for 1 minute.',
                        consumable: true,
                        image: ''
                    },
                    {
                        name: 'Potion of Invisibility',
                        type: 'potion',
                        rarity: 'very rare',
                        effect: {type: 'condition', condition: 'invisible', duration: 60},
                        value: 180,
                        weight: 0.5,
                        description: 'Become invisible for 1 hour or until you attack.',
                        consumable: true,
                        image: ''
                    },
                    {
                        name: 'Antitoxin',
                        type: 'potion',
                        rarity: 'common',
                        effect: {type: 'advantage', saves: ['poison'], duration: 60},
                        value: 50,
                        weight: 0.5,
                        description: 'Advantage on saving throws against poison for 1 hour.',
                        consumable: true,
                        image: ''
                    },
                    {
                        name: 'Thieves\' Tools',
                        type: 'gear',
                        value: 25,
                        weight: 1,
                        description: 'Used for locks and traps. Proficiency adds to checks.',
                        image: ''
                    },
                    {
                        name: 'Chest',
                        type: 'container',
                        inventory: [],
                        isMimic: false,
                        value: 0,
                        weight: 25,
                        description: 'A wooden chest that can hold items.',
                        image: ''
                    },
                    {
                        name: 'Longsword',
                        type: 'weapon',
                        weaponType: 'martial',
                        damage: '1d8',
                        damageType: 'slashing',
                        properties: ['versatile (1d10)'],
                        value: 15,
                        weight: 3,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Versatile martial weapon.',
                        image: ''
                    },
                    {
                        name: '+1 Longsword',
                        type: 'weapon',
                        weaponType: 'martial',
                        damage: '1d8',
                        damageType: 'slashing',
                        properties: ['versatile (1d10)', 'magic'],
                        value: 1000,
                        weight: 3,
                        equipSlot: 'mainHand',
                        attackBonus: 1,
                        damageBonus: 1,
                        rarity: 'uncommon',
                        description: 'Magic weapon with +1 to attack and damage rolls.',
                        image: ''
                    },
                    {
                        name: 'Dagger',
                        type: 'weapon',
                        weaponType: 'simple',
                        damage: '1d4',
                        damageType: 'piercing',
                        properties: ['finesse', 'light', 'thrown (20/60)'],
                        value: 2,
                        weight: 1,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Simple light weapon.',
                        image: ''
                    },
                    {
                        name: 'Shortbow',
                        type: 'weapon',
                        weaponType: 'simple',
                        damage: '1d6',
                        damageType: 'piercing',
                        properties: ['ammunition (80/320)', 'two-handed'],
                        value: 25,
                        weight: 2,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        ranged: true,
                        range: 80,
                        description: 'Simple ranged weapon.',
                        image: ''
                    },
                    {
                        name: 'Greatsword',
                        type: 'weapon',
                        weaponType: 'martial',
                        damage: '2d6',
                        damageType: 'slashing',
                        properties: ['heavy', 'two-handed'],
                        value: 50,
                        weight: 6,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Heavy two-handed weapon.',
                        image: ''
                    },
                    {
                        name: 'Handaxe',
                        type: 'weapon',
                        weaponType: 'simple',
                        damage: '1d6',
                        damageType: 'slashing',
                        properties: ['light', 'thrown (20/60)'],
                        value: 5,
                        weight: 2,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Simple throwing weapon.',
                        image: ''
                    },
                    {
                        name: 'Warhammer',
                        type: 'weapon',
                        weaponType: 'martial',
                        damage: '1d8',
                        damageType: 'bludgeoning',
                        properties: ['versatile (1d10)'],
                        value: 15,
                        weight: 2,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Versatile martial weapon.',
                        image: ''
                    },
                    {
                        name: 'Quarterstaff',
                        type: 'weapon',
                        weaponType: 'simple',
                        damage: '1d6',
                        damageType: 'bludgeoning',
                        properties: ['versatile (1d8)'],
                        value: 2,
                        weight: 4,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Simple versatile weapon.',
                        image: ''
                    }
                ],
                equipment: [
                    {
                        name: 'Leather Armor',
                        type: 'armor',
                        ac: 11,
                        maxDexBonus: null,
                        value: 10,
                        weight: 10,
                        description: 'Light armor.',
                        equipSlot: 'armor',
                        image: ''
                    },
                    {
                        name: 'Chain Mail',
                        type: 'armor',
                        ac: 16,
                        maxDexBonus: 0,
                        value: 75,
                        weight: 55,
                        description: 'Heavy armor.',
                        equipSlot: 'armor',
                        image: ''
                    },
                    {
                        name: 'Shield',
                        type: 'shield',
                        ac: 2,
                        value: 10,
                        weight: 6,
                        description: '+2 AC',
                        equipSlot: 'offHand',
                        image: ''
                    }
                ]
            }
        };
        
        // Initialize the game when page loads
        window.onload = function() {
            game.init();
            game.switchTab('combat'); // Start on combat tab
        };
    </script>
</body>
</html>
