<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DND 5e Complete System - Professional Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Tab System */
        .tab-container {
            display: flex;
            background: linear-gradient(180deg, #1a1a2e 0%, #16161f 100%);
            border-bottom: 2px solid #2a2a3e;
            padding: 0 20px;
            height: 50px;
        }
        
        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #9ca3af;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }
        
        .tab:hover {
            color: #e0e0e0;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .tab.active {
            color: #fbbf24;
            border-bottom-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }
        
        .tab-content {
            display: none;
            height: calc(100vh - 50px);
            overflow: hidden;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Combat Board Layout */
        .combat-container {
            display: flex;
            height: 100%;
        }
        
        /* Sidebar */
        .sidebar {
            width: 320px;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2a2a3e;
        }
        
        .sidebar h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 20px;
            color: #fbbf24;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #6b7280;
            margin-bottom: 12px;
            font-weight: 700;
        }
        
        /* Buttons */
        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        /* Quick Add Grid */
        .quick-add-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }
        
        .quick-add-btn {
            padding: 8px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: #93bbfc;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .quick-add-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: scale(1.05);
        }
        
        /* Dice Roll Grid */
        .dice-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }
        
        .dice-btn {
            padding: 8px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 6px;
            color: #fbbf24;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .dice-btn:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: scale(1.05);
        }
        
        /* Turn Order */
        .turn-order {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .turn-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            font-size: 13px;
            background: rgba(55, 65, 81, 0.3);
            justify-content: space-between;
        }
        
        .turn-item.active {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .turn-actions {
            font-size: 10px;
            opacity: 0.8;
        }
        
        /* Settings */
        .toggle-btn {
            background: #374151;
            position: relative;
            padding-left: 50px;
        }
        
        .toggle-btn.active {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }
        
        .toggle-switch {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 35px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }
        
        .toggle-btn.active .toggle-switch::after {
            left: 17px;
        }
        
        .input-field {
            width: 100%;
            padding: 8px 12px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 13px;
            margin-bottom: 8px;
        }
        
        /* Sound Settings */
        .sound-input {
            width: 100%;
            padding: 6px 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        /* Background Music Controls */
        .music-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .music-btn {
            padding: 6px 12px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 6px;
            color: #8b5cf6;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .music-btn:hover {
            background: rgba(139, 92, 246, 0.3);
        }
        
        .music-btn.active {
            background: rgba(139, 92, 246, 0.4);
        }
        
        /* Combat Log */
        .combat-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .log-entry {
            padding: 6px 10px;
            margin-bottom: 4px;
            background: rgba(55, 65, 81, 0.3);
            border-radius: 4px;
            font-size: 12px;
            border-left: 3px solid #4b5563;
        }
        
        .log-entry.damage { border-left-color: #ef4444; }
        .log-entry.heal { border-left-color: #10b981; }
        .log-entry.info { border-left-color: #3b82f6; }
        .log-entry.death { border-left-color: #dc2626; }
        .log-entry.save { border-left-color: #fbbf24; }
        
        /* Game Board */
        .game-board {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .board-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .board-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        /* Drawing Canvas */
        .drawing-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .drawing-canvas.drawing-mode {
            pointer-events: auto;
        }
        
        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
        }
        
        /* Drag Arrow */
        .drag-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            transform-origin: left center;
        }
        
        .persistent-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            animation: fadeOut 1s ease-out 0.5s forwards;
        }
        
        @keyframes fadeOut {
            to { opacity: 0; }
        }
        
        /* Entity Styles */
        .entity {
            position: absolute;
            width: 70px;
            height: 70px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            user-select: none;
        }
        
        .entity:hover {
            transform: scale(1.1);
            z-index: 20;
        }
        
        .entity.selected {
            z-index: 30;
        }
        
        .entity.dead {
            opacity: 0.4;
            filter: grayscale(100%);
        }
        
        .entity.unconscious {
            opacity: 0.6;
            filter: grayscale(50%);
        }
        
        .entity.valid-target {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.5));
            }
            50% { 
                transform: scale(1.08);
                filter: drop-shadow(0 0 20px rgba(251, 191, 36, 0.8));
            }
        }
        
        .entity-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border: 3px solid;
        }
        
        .entity.selected .entity-circle {
            box-shadow: 0 0 0 4px rgba(251, 191, 36, 0.4);
        }
        
        .entity-image {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .entity-content {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        /* HP Bar */
        .hp-bar {
            position: absolute;
            bottom: -4px;
            left: 10%;
            width: 80%;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .hp-fill {
            height: 100%;
            transition: all 0.5s;
            border-radius: 3px;
        }
        
        .hp-fill.high { background: linear-gradient(to right, #10b981, #34d399); }
        .hp-fill.medium { background: linear-gradient(to right, #f59e0b, #fbbf24); }
        .hp-fill.low { background: linear-gradient(to right, #dc2626, #ef4444); }
        
        /* Entity Name Label */
        .entity-name {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: 600;
        }
        
        /* Conditions Badge */
        .conditions-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(139, 92, 246, 0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
        }
        
        /* Status Effect Indicators */
        .status-indicator {
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #374151;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 16px;
            min-width: 20px;
            text-align: center;
            z-index: 25;
        }
        
        .status-indicator.death {
            color: #dc2626;
        }
        
        .status-indicator.unconscious {
            color: #f59e0b;
        }
        
        .status-indicator.condition {
            color: #8b5cf6;
            font-size: 12px;
        }
        
        /* Death Saves Indicator */
        .death-saves-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            display: flex;
            gap: 2px;
        }
        
        .death-save-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        .death-save-dot.success {
            background: #10b981;
        }
        
        .death-save-dot.failure {
            background: #ef4444;
        }
        
        /* Action Menu */
        .action-menu {
            position: absolute;
            top: 80px;
            left: 0;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 14px;
            min-width: 280px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1000;
        }
        
        .action-menu.pushed-left {
            left: -300px;
        }
        
        .action-section {
            margin-bottom: 12px;
        }
        
        .action-section-title {
            font-size: 10px;
            text-transform: uppercase;
            color: #6b7280;
            margin-bottom: 6px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .action-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            text-align: left;
            padding: 7px 10px;
            background: rgba(55, 65, 81, 0.3);
            border: 1px solid transparent;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
        }
        
        .action-btn:hover {
            background: rgba(55, 65, 81, 0.5);
            border-color: rgba(139, 92, 246, 0.3);
        }
        
        .action-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .spell-slot-info {
            font-size: 10px;
            color: #9ca3af;
            margin-left: auto;
        }
        
        /* Details Panel */
        .details-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 18px;
            min-width: 320px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 500;
        }
        
        .stat-input {
            background: #374151;
            border: 1px solid #4b5563;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-size: 13px;
            width: 60px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(55, 65, 81, 0.5);
        }
        
        .stat-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-box {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #9ca3af;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #fbbf24;
        }
        
        .stat-mod {
            font-size: 12px;
            color: #6b7280;
        }
        
        /* Close Button */
        .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: transparent;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 4px;
            font-size: 18px;
        }
        
        .close-btn:hover {
            color: #ef4444;
        }
        
        /* Targeting Indicator */
        .targeting-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
            z-index: 1000;
        }
        
        .targeting-text {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            color: white;
        }
        
        .cancel-btn {
            display: block;
            margin: 0 auto;
            font-size: 12px;
            color: #fca5a5;
            text-decoration: underline;
            cursor: pointer;
            background: none;
            border: none;
        }
        
        /* Manager Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .modal {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 30px;
            min-width: 500px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        
        .modal h2 {
            color: #fbbf24;
            margin-bottom: 20px;
        }
        
        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .item-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .item-card:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: #8b5cf6;
        }
        
        .item-card.selected {
            background: rgba(139, 92, 246, 0.2);
            border-color: #8b5cf6;
        }
        
        /* Enhanced Character Sheet */
        .character-sheet {
            padding: 20px;
            height: 100%;
            overflow-y: auto;
            background: #0f0f1e;
        }
        
        .character-list {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .character-card {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
            position: relative;
        }
        
        .character-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            border-color: #8b5cf6;
        }
        
        .character-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .character-card-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
        }
        
        .character-card-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .character-card-info h4 {
            color: #fbbf24;
            margin: 0;
            font-size: 16px;
        }
        
        .character-card-info p {
            color: #9ca3af;
            margin: 2px 0;
            font-size: 12px;
        }
        
        .character-card-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #374151;
        }
        
        .character-card-stat {
            text-align: center;
        }
        
        .character-card-stat-value {
            font-size: 14px;
            font-weight: bold;
            color: #e0e0e0;
        }
        
        .character-card-stat-label {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
        }
        
        .sheet-content {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 0;
            margin-top: 20px;
        }
        
        /* Character Sheet Header */
        .sheet-header {
            padding: 30px;
            border-bottom: 1px solid #374151;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .sheet-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: white;
            overflow: hidden;
        }
        
        .sheet-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .sheet-basic-info h2 {
            color: #fbbf24;
            margin: 0 0 10px 0;
            font-size: 28px;
        }
        
        .sheet-basic-info p {
            color: #9ca3af;
            margin: 0;
            font-size: 16px;
        }
        
        /* Character Sheet Tabs */
        .sheet-tabs {
            display: flex;
            background: #1a1a2e;
            border-bottom: 1px solid #374151;
        }
        
        .sheet-tab {
            padding: 15px 25px;
            background: transparent;
            border: none;
            color: #9ca3af;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }
        
        .sheet-tab:hover {
            color: #e0e0e0;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .sheet-tab.active {
            color: #fbbf24;
            border-bottom-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }
        
        .sheet-tab-content {
            display: none;
            padding: 30px;
        }
        
        .sheet-tab-content.active {
            display: block;
        }
        
        /* Core Stats Section */
        .core-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }
        
        .stat-card-large {
            background: rgba(251, 191, 36, 0.1);
            border-color: #fbbf24;
        }
        
        .stat-card h3 {
            color: #fbbf24;
            margin: 0 0 10px 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-card-value {
            font-size: 32px;
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 5px;
        }
        
        .stat-card-subtitle {
            font-size: 12px;
            color: #9ca3af;
        }
        
        /* HP Bar */
        .hp-display {
            position: relative;
            background: #1f2937;
            border: 2px solid #374151;
            border-radius: 8px;
            height: 40px;
            overflow: hidden;
        }
        
        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #dc2626);
            transition: width 0.3s ease;
            position: relative;
        }
        
        .hp-bar-fill.healthy {
            background: linear-gradient(90deg, #10b981, #059669);
        }
        
        .hp-bar-fill.wounded {
            background: linear-gradient(90deg, #f59e0b, #d97706);
        }
        
        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 2;
        }
        
        /* Ability Scores */
        .ability-scores {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .ability-score {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #374151;
            border-radius: 12px;
            padding: 15px 10px;
            transition: all 0.3s;
        }
        
        .ability-score:hover {
            border-color: #8b5cf6;
            transform: translateY(-2px);
        }
        
        .ability-score-name {
            font-size: 12px;
            color: #9ca3af;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        .ability-score-value {
            font-size: 24px;
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 5px;
        }
        
        .ability-score-modifier {
            font-size: 14px;
            color: #fbbf24;
            font-weight: 600;
        }
        
        /* Skills Section */
        .skills-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .skill-category h4 {
            color: #fbbf24;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #374151;
            padding-bottom: 8px;
        }
        
        .skill-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .skill-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid #374151;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .skill-item:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: #8b5cf6;
        }
        
        .skill-item.proficient {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        
        .skill-name {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #e0e0e0;
            font-weight: 500;
        }
        
        .proficiency-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #6b7280;
            background: transparent;
        }
        
        .proficiency-indicator.filled {
            background: #10b981;
            border-color: #10b981;
        }
        
        .skill-bonus {
            color: #fbbf24;
            font-weight: 600;
            font-size: 14px;
        }
        
        /* Combat Section */
        .combat-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .attacks-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 20px;
        }
        
        .attacks-section h4 {
            color: #ef4444;
            margin-bottom: 15px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .attack-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid #374151;
            border-radius: 8px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .attack-name {
            color: #e0e0e0;
            font-weight: 600;
        }
        
        .attack-stat {
            text-align: center;
            color: #9ca3af;
            font-size: 14px;
        }
        
        .attack-stat-value {
            color: #fbbf24;
            font-weight: 600;
        }
        
        /* Spells Section */
        .spell-slots {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 10px;
            margin-bottom: 30px;
        }
        
        .spell-slot-level {
            text-align: center;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid #8b5cf6;
            border-radius: 8px;
            padding: 10px;
        }
        
        .spell-slot-level h5 {
            color: #8b5cf6;
            margin: 0 0 5px 0;
            font-size: 12px;
        }
        
        .spell-slot-tracker {
            color: #e0e0e0;
            font-weight: 600;
        }
        
        /* Equipment Section */
        .equipment-slots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }
        
        .equipment-slot {
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed #374151;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .equipment-slot.filled {
            border-style: solid;
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        
        .equipment-slot-name {
            color: #9ca3af;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        .equipment-item {
            color: #e0e0e0;
            font-weight: 600;
        }
        
        /* Editable Fields */
        .editable-field {
            background: transparent;
            border: 1px solid transparent;
            color: inherit;
            font-size: inherit;
            font-weight: inherit;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.3s;
            text-align: center;
            width: 100%;
        }
        
        .editable-field:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: #374151;
        }
        
        .editable-field:focus {
            outline: none;
            background: #1f2937;
            border-color: #fbbf24;
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }
        
        /* Backgrounds Tab */
        .backgrounds-container {
            padding: 20px;
            height: 100%;
            overflow-y: auto;
            background: #0f0f1e;
        }
        
        .background-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .background-card {
            width: 200px;
            height: 150px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            border: 2px solid #374151;
        }
        
        .background-card:hover {
            border-color: #8b5cf6;
        }
        
        .background-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .background-delete-btn {
            background: #ef4444;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .background-delete-btn:hover {
            background: #dc2626;
        }
        
        /* Import/Export */
        .textarea-large {
            width: 100%;
            height: 200px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* Movement Range Indicator */
        .movement-range {
            position: absolute;
            border: 2px dashed rgba(59, 130, 246, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
        
        /* Animations */
        .floating-text {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            animation: floatUp 1.5s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 1;
            }
            100% {
                transform: translateY(-60px) scale(1.2);
                opacity: 0;
            }
        }
        
        .arrow-animation {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }
        
        .arrow-line {
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            animation: shootArrow 0.5s ease-out;
            position: relative;
        }
        
        @keyframes shootArrow {
            0% { width: 0; opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0.2; }
        }
        
        /* Targeting Arrow */
        .targeting-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }
        
        .targeting-line {
            height: 3px;
            background: linear-gradient(to right, transparent, #dc2626, transparent);
            position: relative;
        }
        
        /* Spell Effect Animation */
        .spell-effect {
            position: absolute;
            pointer-events: none;
            z-index: 600;
        }
        
        @keyframes magicPulse {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
        
        .magic-circle {
            width: 100px;
            height: 100px;
            border: 3px solid;
            border-radius: 50%;
            animation: magicPulse 1s ease-out;
        }
        
        /* Roll Result Display */
        .roll-result {
            position: fixed;
            top: 60px;
            right: 20px;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1500;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
            min-width: 200px;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .roll-result h3 {
            color: #fbbf24;
            margin-bottom: 10px;
        }
        
        .roll-breakdown {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 5px;
        }
        
        /* Expandable Library Sidebar */
        .library-sidebar-toggle {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            border: none;
            padding: 12px 8px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            cursor: pointer;
            border-radius: 8px 0 0 8px;
            font-size: 12px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
        }
        
        .library-sidebar-toggle:hover {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            transform: translateY(-50%) translateX(-5px);
        }
        
        .expandable-library-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
            border-left: 2px solid #2a2a3e;
            transition: right 0.3s ease-out;
            z-index: 999;
            display: flex;
            flex-direction: column;
        }
        
        .expandable-library-sidebar.open {
            right: 0;
        }
        
        .expandable-library-header {
            padding: 20px;
            border-bottom: 1px solid #2a2a3e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .expandable-library-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .expandable-library-content .search-bar {
            margin-bottom: 15px;
        }
        
        .expandable-library-content .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        
        .expandable-library-content .content-card {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .expandable-library-content .content-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            border-color: #8b5cf6;
        }
        
        .expandable-library-filters {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .expandable-library-filters .btn-small {
            padding: 4px 8px;
            font-size: 10px;
            margin: 0;
        }
        
        /* Search Bar */
        .search-bar {
            width: 100%;
            padding: 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            margin-bottom: 15px;
        }

        /* Enhanced Creation Modal Styles */
        .creation-modal {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 30px;
            min-width: 400px;
            max-width: 600px;
            position: relative;
        }
        
        .creation-modal h2 {
            color: #fbbf24;
            margin-bottom: 25px;
            text-align: center;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-weight: 600;
            font-size: 14px;
        }
        
        .form-select {
            width: 100%;
            padding: 12px 16px;
            background: #1f2937;
            border: 2px solid #374151;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .form-select:focus {
            outline: none;
            border-color: #fbbf24;
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.1);
        }
        
        .custom-input {
            width: 100%;
            padding: 12px 16px;
            background: #1f2937;
            border: 2px solid #374151;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            margin-top: 10px;
            display: none;
            transition: all 0.3s;
        }
        
        .custom-input.show {
            display: block;
        }
        
        .custom-input:focus {
            outline: none;
            border-color: #fbbf24;
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.1);
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }
        
        .modal-buttons .btn {
            min-width: 120px;
            margin-bottom: 0;
        }
        
        /* Advanced Options Dropdown */
        .advanced-toggle {
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid #8b5cf6;
            color: #8b5cf6;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: all 0.3s;
        }
        
        .advanced-toggle:hover {
            background: rgba(139, 92, 246, 0.3);
        }
        
        .advanced-options {
            display: none;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .advanced-options.show {
            display: block;
        }
        
        .advanced-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .advanced-input {
            width: 100%;
            padding: 8px 12px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 13px;
        }
        
        /* NPC Token Styling */
        .entity.npc .entity-circle {
            border-color: #f59e0b !important;
            background: #f59e0b !important;
        }

        .effect-entity {
            position: absolute;
            pointer-events: none;
            z-index: 20;
        }

        .effect-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <!-- Tab Navigation -->
    <div class="tab-container">
        <button class="tab active" onclick="switchTab(event, 'combat')">‚öîÔ∏è Combat Board</button>
        <button class="tab" onclick="switchTab(event, 'characters')">üë§ Character Sheets</button>
        <button class="tab" onclick="switchTab(event, 'backgrounds')">üñºÔ∏è Backgrounds</button>
        <button class="tab" onclick="switchTab(event, 'import-export')">üìÅ Import/Export</button>
    </div>
    
    <!-- Combat Board Tab -->
    <div id="combat-tab" class="tab-content active">
        <div class="combat-container">
            <!-- Sidebar -->
            <div class="sidebar">
                <h2>‚öîÔ∏è Combat Control</h2>
                
                <!-- Quick Add Section -->
                <div class="section">
                    <div class="section-title">Quick Add</div>
                    <button class="btn btn-primary" onclick="game.addPlayerCharacter()">
                        üõ°Ô∏è Add Player Character
                    </button>
                    <button class="btn btn-primary" onclick="game.addNPC()">
                        ü§ñ Add NPC
                    </button>
                    <button class="btn btn-primary" onclick="game.addMonster()">
                        üëπ Add Monster
                    </button>
                    <button class="btn btn-primary" onclick="game.addItem()">
                        üì¶ Add Item
                    </button>
                    <button class="btn btn-primary" onclick="game.addChest()">
                        üóÉÔ∏è Add Chest
                    </button>
                    <button class="btn btn-primary" onclick="game.customizeQuickSlots()">
                        ‚öôÔ∏è Customize Quick Slots
                    </button>
                    <div class="quick-add-grid" id="quickAddGrid"></div>
                </div>
                
                <!-- Dice Rolls Section -->
                <div class="section">
                    <div class="section-title">Dice Rolls</div>
                    <div class="dice-grid">
                        <button class="dice-btn" onclick="game.rollDice('1d20')">d20</button>
                        <button class="dice-btn" onclick="game.rollDice('1d4')">1d4</button>
                        <button class="dice-btn" onclick="game.rollDice('1d6')">1d6</button>
                        <button class="dice-btn" onclick="game.rollDice('1d8')">1d8</button>
                        <button class="dice-btn" onclick="game.rollDice('1d10')">1d10</button>
                        <button class="dice-btn" onclick="game.rollDice('1d12')">1d12</button>
                        <button class="dice-btn" onclick="game.rollDice('2d6')">2d6</button>
                        <button class="dice-btn" onclick="game.rollDice('1d20+5')">d20+5</button>
                        <button class="dice-btn" onclick="game.rollDice('1d20-1')">d20-1</button>
                    </div>
                </div>
                
                <!-- Turn Order Section -->
                <div class="section">
                    <div class="section-title">Turn Order</div>
                    <div class="turn-order" id="turnOrder"></div>
                    <button class="btn btn-success" onclick="game.nextTurn()">‚ñ∂Ô∏è Next Turn</button>
                    <button class="btn btn-warning" onclick="game.endTurn()">‚è∏Ô∏è End Current Turn</button>
                    <button class="btn btn-danger" onclick="game.rollInitiative()">üé≤ Roll Initiative</button>
                </div>
                
                <!-- Settings Section -->
                <div class="section">
                    <div class="section-title">Settings</div>
                    <button class="btn toggle-btn active" id="gridToggle" onclick="game.toggleGrid()">
                        <div class="toggle-switch"></div>
                        Show Grid
                    </button>
                    <button class="btn toggle-btn" id="turnToggle" onclick="game.toggleTurnEnforcement()">
                        <div class="toggle-switch"></div>
                        Enforce Turns
                    </button>
                    <button class="btn toggle-btn" id="movementToggle" onclick="game.toggleMovementRange()">
                        <div class="toggle-switch"></div>
                        Show Movement Range
                    </button>
                    <button class="btn toggle-btn" id="editToggle" onclick="game.toggleEditMode()">
                        <div class="toggle-switch"></div>
                        Edit Mode
                    </button>
                    <button class="btn toggle-btn" id="drawToggle" onclick="game.toggleDrawMode()">
                        <div class="toggle-switch"></div>
                        Draw Mode
                    </button>
                    <input type="text" class="input-field" id="bgUrl" placeholder="Background Image URL" onchange="game.changeBackground()">
                    
                    <div class="section-title">Drawing Tools</div>
                    <button class="btn btn-danger" id="eraseToggle" onclick="game.toggleEraseMode()">
                        üßΩ Erase Mode
                    </button>
                    <button class="btn btn-warning" onclick="game.clearDrawing()">
                        üóëÔ∏è Clear Drawing
                    </button>
                    
                    <div class="section-title">Background Music</div>
                    <input type="file" accept=".mp3" id="backgroundMusicFile" onchange="game.setBackgroundMusicFromFile(this.files[0])">
                    <div class="music-controls">
                        <button class="music-btn" id="playBtn" onclick="game.playBackgroundMusic()">‚ñ∂Ô∏è Play</button>
                        <button class="music-btn" id="pauseBtn" onclick="game.pauseBackgroundMusic()">‚è∏Ô∏è Pause</button>
                    </div>
                    
                    <div class="section-title">Sound Effects</div>
                    <input type="file" accept=".mp3" id="soundHealFile" onchange="game.setSoundFromFile('heal', this.files[0])">
                    <input type="file" accept=".mp3" id="soundAttackFile" onchange="game.setSoundFromFile('attack', this.files[0])">
                    <input type="file" accept=".mp3" id="soundSpellFile" onchange="game.setSoundFromFile('spell', this.files[0])">
                    <input type="file" accept=".mp3" id="soundOpenFile" onchange="game.setSoundFromFile('open', this.files[0])">
                </div>
                
                <!-- Combat Log Section -->
                <div class="section">
                    <div class="section-title">Combat Log</div>
                    <div class="combat-log" id="combatLog">
                        <div class="log-entry info">Ready for combat...</div>
                    </div>
                </div>
                
                <!-- Game Controls -->
                <div class="section">
                    <div class="section-title">Game Controls</div>
                    <button class="btn btn-primary" onclick="game.saveGameState()">üíæ Save Game</button>
                    <button class="btn btn-primary" onclick="game.loadGameState()">üìÇ Load Game</button>
                    <button class="btn btn-danger" onclick="game.clearBoard()">üóëÔ∏è Clear Board</button>
                </div>
            </div>
            
            <!-- Game Board -->
            <div class="game-board" id="gameBoard">
                <div class="board-container" id="boardContainer">
                    <svg class="grid-overlay" id="gridOverlay">
                        <defs>
                            <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                                <path d="M 50 0 L 0 0 0 50" fill="none" stroke="white" stroke-width="1"/>
                            </pattern>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#grid)"/>
                    </svg>
                    <canvas class="drawing-canvas" id="drawingCanvas"></canvas>
                    <div class="board-canvas" id="boardCanvas"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Expandable Library Sidebar -->
    <button class="library-sidebar-toggle" id="libraryToggle" onclick="game.toggleLibrarySidebar()">
        üìö Library
    </button>
    
    <div class="expandable-library-sidebar" id="expandableLibrarySidebar">
        <div class="expandable-library-header">
            <h3 style="color: #fbbf24; margin: 0;">üìö Content Library</h3>
            <button class="close-btn" onclick="game.toggleLibrarySidebar()" style="position: static;">‚úï</button>
        </div>
        <div class="expandable-library-content">
            <input type="text" class="search-bar" id="sidebarLibrarySearch" placeholder="Search library..." onkeyup="game.searchSidebarLibrary(this.value)">
            
            <div class="expandable-library-filters">
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('all')">All</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('player')">Players</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('monster')">Monsters</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('spell')">Spells</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('item')">Items</button>
            </div>
            
            <button class="btn btn-primary" style="margin-bottom: 15px;" onclick="game.saveCurrentEntity()">
                üíæ Save Selected Entity
            </button>
            
            <div class="content-grid" id="sidebarLibraryGrid"></div>
        </div>
    </div>
    
    <!-- Character Sheets Tab -->
    <div id="characters-tab" class="tab-content">
        <div class="character-sheet">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">üë§ Character Sheets</h2>
            <div class="character-list" id="characterList"></div>
            <div class="sheet-content" id="sheetContent" style="display: none;"></div>
        </div>
    </div>
    
    <!-- Backgrounds Tab -->
    <div id="backgrounds-tab" class="tab-content">
        <div class="backgrounds-container">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">üñºÔ∏è Saved Backgrounds</h2>
            <input type="text" class="input-field" id="newBgUrl" placeholder="New Background URL">
            <button class="btn btn-primary" onclick="game.saveBackground()">Save Background</button>
            <div class="background-list" id="backgroundList"></div>
        </div>
    </div>
    
    <!-- Import/Export Tab -->
    <div id="import-export-tab" class="tab-content">
        <div style="padding: 40px;">
            <h2 style="color: #fbbf24; margin-bottom: 30px;">üìÅ Import/Export Content</h2>
            
            <div style="margin-bottom: 30px;">
                <h3 style="margin-bottom: 15px;">Export Library</h3>
                <button class="btn btn-primary" onclick="game.exportLibrary()">Export to JSON</button>
                <textarea class="textarea-large" id="exportData" readonly placeholder="Exported data will appear here..."></textarea>
            </div>
            
            <div>
                <h3 style="margin-bottom: 15px;">Import Library</h3>
                <textarea class="textarea-large" id="importData" placeholder="Paste JSON data here..."></textarea>
                <button class="btn btn-success" onclick="game.importLibrary()">Import from JSON</button>
            </div>
        </div>
    </div>
    
    <script>
        // Complete DND 5e Game System - Professional Edition
        const game = {
            // Core Game State
            entities: [],
            selectedEntity: null,
            currentTurn: 0,
            turnOrder: [],
            showGrid: true,
            showMovementRange: false,
            enforceTurns: false,
            editMode: false,
            drawMode: false,
            eraseMode: false,
            targetingMode: null,
            draggingEntity: null,
            dragStartPos: null,
            nextId: 1,
            gameNotes: '',
            diceRollHistory: [],
            roundNumber: 1,
            dragArrow: null,
            persistentArrow: null,
            backgroundUrl: '',
            savedBackgrounds: [],
            sounds: {
                heal: '',
                attack: '',
                spell: '',
                open: ''
            },
            backgroundMusic: {
                url: '',
                audio: null,
                isPlaying: false
            },
            
            // Drawing
            isDrawing: false,
            lastDrawX: 0,
            lastDrawY: 0,
            drawingCanvas: null,
            drawingCtx: null,
            
            // Library Sidebar
            librarySidebarOpen: false,
            
            // Action Economy State
            currentTurnActions: {
                movement: 0,
                action: false,
                bonusAction: false,
                reaction: true
            },
            
            // Enhanced D&D 5e Classes and Races Lists
            classList: [
                'Artificer', 'Barbarian', 'Bard', 'Cleric', 'Druid', 'Fighter', 
                'Monk', 'Paladin', 'Ranger', 'Rogue', 'Sorcerer', 'Warlock', 'Wizard',
                'Blood Hunter', 'Mystic', 'Custom'
            ],
            
            raceList: [
                'Aarakocra', 'Aasimar', 'Bugbear', 'Centaur', 'Changeling', 'Dragonborn', 
                'Dwarf', 'Elf', 'Firbolg', 'Genasi', 'Githyanki', 'Githzerai', 'Gnome', 
                'Goblin', 'Goliath', 'Half-Elf', 'Halfling', 'Half-Orc', 'Hobgoblin', 
                'Human', 'Kalashtar', 'Kenku', 'Kobold', 'Lizardfolk', 'Loxodon', 
                'Minotaur', 'Orc', 'Shifter', 'Simic Hybrid', 'Tabaxi', 'Tiefling', 
                'Tortle', 'Triton', 'Vedalken', 'Warforged', 'Yuan-ti Pureblood', 'Custom'
            ],
            
            // Comprehensive Content Library
            library: {
                monsters: [
                    {
                        name: 'Goblin',
                        type: 'monster',
                        hp: 7, maxHp: 7, ac: 15, speed: 30,
                        str: 8, dex: 14, con: 10, int: 10, wis: 8, cha: 8,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Scimitar', toHit: 4, damage: '1d6+2', damageType: 'slashing', range: 5, sound: ''}],
                        abilities: [{name: 'Nimble Escape', description: 'Disengage or Hide as bonus action', actionType: 'bonus', sound: ''}],
                        skills: {stealth: 6},
                        savingThrows: {str: -1, dex: 2, con: 0, int: 0, wis: -1, cha: -1},
                        color: '#4a7c59',
                        cr: 0.25,
                        description: 'Small green-skinned humanoid, sneaky and aggressive.',
                        image: ''
                    },
                    {
                        name: 'Orc',
                        type: 'monster',
                        hp: 15, maxHp: 15, ac: 13, speed: 30,
                        str: 16, dex: 12, con: 16, int: 7, wis: 11, cha: 10,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Greataxe', toHit: 5, damage: '1d12+3', damageType: 'slashing', range: 5, sound: ''}],
                        abilities: [{name: 'Aggressive', description: 'Bonus action to move up to speed toward enemy', actionType: 'bonus', sound: ''}],
                        skills: {intimidation: 2},
                        savingThrows: {str: 3, dex: 1, con: 3, int: -2, wis: 0, cha: 0},
                        color: '#8b4513',
                        cr: 0.5,
                        description: 'Savage humanoid warrior with gray skin and tusks.',
                        image: ''
                    },
                    {
                        name: 'Mimic',
                        type: 'monster',
                        hp: 58, maxHp: 58, ac: 12, speed: 15,
                        str: 17, dex: 12, con: 15, int: 5, wis: 13, cha: 8,
                        proficiencyBonus: 2,
                        attacks: [
                            {name: 'Pseudopod', toHit: 5, damage: '1d8+3', damageType: 'bludgeoning', range: 5, sound: ''},
                            {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing', range: 5, special: 'Grapples target (escape DC 13)', sound: ''}
                        ],
                        abilities: [
                            {name: 'Shapechanger', description: 'Can polymorph into object', actionType: 'action', sound: ''},
                            {name: 'Adhesive', description: 'Adheres to anything that touches it', actionType: 'passive', sound: ''}
                        ],
                        skills: {stealth: 5},
                        savingThrows: {str: 3, dex: 1, con: 2, int: -3, wis: 1, cha: -1},
                        color: '#8B4513',
                        cr: 2,
                        isMimic: true,
                        description: 'Shapeshifting predator that mimics objects.',
                        image: ''
                    }
                ],
                spells: [
                    {
                        name: 'Fireball',
                        type: 'spell',
                        level: 3,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 150,
                        components: 'V, S, M',
                        duration: 'instantaneous',
                        damage: '8d6',
                        damageType: 'fire',
                        savingThrow: 'dexterity',
                        saveDC: 15,
                        aoe: '20-foot radius sphere',
                        description: 'Each creature in a 20-foot-radius sphere must make a Dexterity saving throw. Takes 8d6 fire damage on failed save, half on success.',
                        higherLevel: 'Additional 1d6 damage per spell slot above 3rd',
                        image: '',
                        sound: '',
                        visualEffect: {url: '', loop: false}
                    },
                    {
                        name: 'Cure Wounds',
                        type: 'spell',
                        level: 1,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 'touch',
                        components: 'V, S',
                        duration: 'instantaneous',
                        healing: '1d8+3',
                        description: 'A creature you touch regains 1d8 + spellcasting modifier hit points.',
                        higherLevel: 'Additional 1d8 healing per spell slot above 1st',
                        image: '',
                        sound: '',
                        visualEffect: {url: '', loop: false}
                    }
                ],
                items: [
                    {
                        name: 'Healing Potion',
                        type: 'potion',
                        rarity: 'common',
                        healing: '2d4+2',
                        value: 50,
                        weight: 0.5,
                        description: 'Regain 2d4+2 hit points when consumed.',
                        consumable: true,
                        image: '',
                        sound: ''
                    },
                    {
                        name: 'Chest',
                        type: 'container',
                        inventory: [],
                        isMimic: false,
                        value: 0,
                        weight: 25,
                        description: 'A wooden chest that can hold items.',
                        image: '',
                        sound: ''
                    }
                ],
                equipment: [
                    {
                        name: 'Leather Armor',
                        type: 'armor',
                        armorType: 'light',
                        ac: 11,
                        maxDexBonus: null,
                        stealthDisadvantage: false,
                        weight: 10,
                        value: 10,
                        equipSlot: 'armor',
                        description: 'Light armor. AC = 11 + Dex modifier.',
                        image: '',
                        sound: ''
                    },
                    {
                        name: 'Longsword',
                        type: 'weapon',
                        weaponType: 'martial',
                        damage: '1d8',
                        damageType: 'slashing',
                        properties: ['versatile (1d10)'],
                        value: 15,
                        weight: 3,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Versatile martial weapon.',
                        image: '',
                        sound: ''
                    }
                ],
                players: []
            },
            
            // Skills list for D&D 5e
            skillsList: {
                acrobatics: 'dex',
                animalHandling: 'wis',
                arcana: 'int',
                athletics: 'str',
                deception: 'cha',
                history: 'int',
                insight: 'wis',
                intimidation: 'cha',
                investigation: 'int',
                medicine: 'wis',
                nature: 'int',
                perception: 'wis',
                performance: 'cha',
                persuasion: 'cha',
                religion: 'int',
                sleightOfHand: 'dex',
                stealth: 'dex',
                survival: 'wis'
            },
            
            // All D&D 5e Conditions
            conditions: {
                blinded: {
                    description: 'Cannot see. Auto-fail sight checks. Disadvantage on attacks. Advantage on attacks against.',
                    effects: {attackDisadvantage: true, defenseAdvantage: true}
                },
                charmed: {
                    description: 'Cannot attack charmer. Charmer has advantage on social checks.',
                    effects: {}
                },
                deafened: {
                    description: 'Cannot hear. Auto-fail hearing checks.',
                    effects: {}
                },
                exhaustion: {
                    description: 'Multiple levels with cumulative effects.',
                    levels: [
                        'Disadvantage on ability checks',
                        'Speed halved',
                        'Disadvantage on attacks and saves',
                        'HP maximum halved',
                        'Speed reduced to 0',
                        'Death'
                    ]
                },
                frightened: {
                    description: 'Disadvantage on ability checks and attacks while source in sight. Cannot willingly move closer.',
                    effects: {attackDisadvantage: true}
                },
                grappled: {
                    description: 'Speed becomes 0. Ends if grappler incapacitated.',
                    effects: {speed: 0}
                },
                incapacitated: {
                    description: 'Cannot take actions or reactions.',
                    effects: {noActions: true, noReactions: true}
                },
                invisible: {
                    description: 'Cannot be seen. Advantage on attacks. Disadvantage on attacks against.',
                    effects: {attackAdvantage: true, defenseDisadvantage: true}
                },
                paralyzed: {
                    description: 'Incapacitated, cannot move or speak. Auto-fail Str and Dex saves. Attacks have advantage. Hits within 5ft are crits.',
                    effects: {noActions: true, noReactions: true, speed: 0, attackDisadvantage: true, defenseAdvantage: true, autoFailSaves: ['str', 'dex']}
                },
                petrified: {
                    description: 'Transformed to stone. Incapacitated. Resistance to all damage. Immune to poison and disease.',
                    effects: {noActions: true, noReactions: true, speed: 0, damageResistance: 'all', immunities: ['poison', 'disease']}
                },
                poisoned: {
                    description: 'Disadvantage on attack rolls and ability checks.',
                    effects: {attackDisadvantage: true, checkDisadvantage: true}
                },
                prone: {
                    description: 'Disadvantage on attacks. Attacks within 5ft have advantage, beyond have disadvantage. Half movement to stand.',
                    effects: {attackDisadvantage: true, meleeDefenseAdvantage: true, rangedDefenseDisadvantage: true}
                },
                restrained: {
                    description: 'Speed 0. Disadvantage on attacks and Dex saves. Advantage on attacks against.',
                    effects: {speed: 0, attackDisadvantage: true, defenseAdvantage: true, saveDisadvantage: ['dex']}
                },
                stunned: {
                    description: 'Incapacitated, cannot move, speak falteringly. Auto-fail Str and Dex saves. Attacks have advantage.',
                    effects: {noActions: true, noReactions: true, speed: 0, defenseAdvantage: true, autoFailSaves: ['str', 'dex']}
                },
                unconscious: {
                    description: 'Incapacitated, cannot move or speak, unaware. Drop items, fall prone. Auto-fail Str and Dex saves. Attacks have advantage. Hits within 5ft are crits.',
                    effects: {noActions: true, noReactions: true, speed: 0, prone: true, defenseAdvantage: true, autoFailSaves: ['str', 'dex'], meleeCritical: true}
                }
            },
            
            quickSlots: [], // For customizable quick slots
            
            init() {
                this.loadGameState();
                this.loadLibrary();
                this.loadSounds();
                this.loadSavedBackgrounds();
                this.setupDrawingCanvas();
                this.setupEventListeners();
                this.setupQuickAdd();
                this.populateLibrarySidebar(); // Initialize sidebar content
                this.render();
                this.updateTurnOrder();
                
                // Add starting entities if none exist
                if (this.entities.length === 0) {
                    this.entities.push(this.createEntity('player', 'Fighter', 200, 300));
                    this.entities.push(this.createEntity('monster', 'Goblin', 500, 300));
                    this.render();
                }

                this.loadQuickSlots();
            },
            
            // Enhanced Add NPC function (renamed from addNPCToken)
            addNPC() {
                const name = prompt('Enter NPC name:');
                if (!name) return;
                
                // Create modal for class and race selection
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="creation-modal">
                        <h2>ü§ñ Create NPC</h2>
                        <div class="form-group">
                            <label class="form-label">Class:</label>
                            <select id="npcClassSelect" class="form-select">
                                ${this.classList.map(cls => `<option value="${cls}">${cls}</option>`).join('')}
                            </select>
                            <input type="text" id="npcCustomClass" placeholder="Enter custom class name" class="custom-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Race:</label>
                            <select id="npcRaceSelect" class="form-select">
                                ${this.raceList.map(race => `<option value="${race}">${race}</option>`).join('')}
                            </select>
                            <input type="text" id="npcCustomRace" placeholder="Enter custom race name" class="custom-input">
                        </div>
                        
                        <button class="advanced-toggle" onclick="this.nextElementSibling.classList.toggle('show')">‚öôÔ∏è Advanced Options</button>
                        <div class="advanced-options">
                            <div class="advanced-grid">
                                <div>
                                    <label class="form-label">Hit Points:</label>
                                    <input type="number" id="npcHP" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Armor Class:</label>
                                    <input type="number" id="npcAC" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Speed:</label>
                                    <input type="number" id="npcSpeed" value="30" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Strength:</label>
                                    <input type="number" id="npcStr" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Dexterity:</label>
                                    <input type="number" id="npcDex" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Constitution:</label>
                                    <input type="number" id="npcCon" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Intelligence:</label>
                                    <input type="number" id="npcInt" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Wisdom:</label>
                                    <input type="number" id="npcWis" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Charisma:</label>
                                    <input type="number" id="npcCha" value="10" class="advanced-input">
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Character Image URL:</label>
                                <input type="text" id="npcImage" placeholder="Image URL" class="advanced-input">
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button class="btn btn-danger" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createNPCFromModal('${name}')">Create NPC</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for custom option toggles
                modal.querySelector('#npcClassSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#npcCustomClass');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
                
                modal.querySelector('#npcRaceSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#npcCustomRace');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
                
                document.body.appendChild(modal);
            },
            
            createNPCFromModal(name) {
                const modal = document.querySelector('.modal-overlay');
                const classSelect = modal.querySelector('#npcClassSelect');
                const customClass = modal.querySelector('#npcCustomClass');
                const raceSelect = modal.querySelector('#npcRaceSelect');
                const customRace = modal.querySelector('#npcCustomRace');
                
                const selectedClass = classSelect.value === 'Custom' ? customClass.value || 'Commoner' : classSelect.value;
                const selectedRace = raceSelect.value === 'Custom' ? customRace.value || 'Human' : raceSelect.value;
                
                const entity = this.createEntity('npc', name, 300 + Math.random() * 100, 250 + Math.random() * 100);
                entity.class = selectedClass;
                entity.race = selectedRace;
                entity.color = '#f59e0b'; // Orange color for NPCs
                
                // Apply advanced options if filled
                const hp = parseInt(modal.querySelector('#npcHP').value) || 10;
                const ac = parseInt(modal.querySelector('#npcAC').value) || 10;
                const speed = parseInt(modal.querySelector('#npcSpeed').value) || 30;
                const str = parseInt(modal.querySelector('#npcStr').value) || 10;
                const dex = parseInt(modal.querySelector('#npcDex').value) || 10;
                const con = parseInt(modal.querySelector('#npcCon').value) || 10;
                const int = parseInt(modal.querySelector('#npcInt').value) || 10;
                const wis = parseInt(modal.querySelector('#npcWis').value) || 10;
                const cha = parseInt(modal.querySelector('#npcCha').value) || 10;
                const image = modal.querySelector('#npcImage').value || '';
                
                entity.hp = hp;
                entity.maxHp = hp;
                entity.ac = ac;
                entity.speed = speed;
                entity.str = str;
                entity.dex = dex;
                entity.con = con;
                entity.int = int;
                entity.wis = wis;
                entity.cha = cha;
                entity.image = image;
                
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
                
                modal.remove();
            },
            
            // Library Sidebar Functions
            toggleLibrarySidebar() {
                this.librarySidebarOpen = !this.librarySidebarOpen;
                const sidebar = document.getElementById('expandableLibrarySidebar');
                const toggle = document.getElementById('libraryToggle');
                
                if (this.librarySidebarOpen) {
                    sidebar.classList.add('open');
                    toggle.style.right = '400px';
                    this.populateLibrarySidebar();
                    
                    // Check if action menu or details panel is open and push it left
                    const actionMenus = document.querySelectorAll('.action-menu');
                    actionMenus.forEach(menu => {
                        menu.classList.add('pushed-left');
                    });
                    
                    const detailsPanels = document.querySelectorAll('.details-panel');
                    detailsPanels.forEach(panel => {
                        panel.style.right = '420px';
                    });
                } else {
                    sidebar.classList.remove('open');
                    toggle.style.right = '0px';
                    
                    // Restore action menu and details panel position
                    const actionMenus = document.querySelectorAll('.action-menu');
                    actionMenus.forEach(menu => {
                        menu.classList.remove('pushed-left');
                    });
                    
                    const detailsPanels = document.querySelectorAll('.details-panel');
                    detailsPanels.forEach(panel => {
                        panel.style.right = '20px';
                    });
                }
            },
            
            populateLibrarySidebar() {
                const grid = document.getElementById('sidebarLibraryGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                // Ensure all library arrays exist before mapping
                const monsters = this.library.monsters || [];
                const players = this.library.players || [];
                const spells = this.library.spells || [];
                const items = this.library.items || [];
                const equipment = this.library.equipment || [];
                
                const all = [
                    ...monsters.map(m => ({...m, category: 'monster'})),
                    ...players.map(p => ({...p, category: 'player'})),
                    ...spells.map(s => ({...s, category: 'spell'})),
                    ...items.map(i => ({...i, category: 'item'})),
                    ...equipment.map(e => ({...e, category: 'equipment'}))
                ];
                
                all.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'content-card';
                    card.dataset.type = item.category;
                    card.dataset.name = item.name.toLowerCase();
                    
                    let html = `<h4 style="color: #fbbf24; font-size: 14px; margin-bottom: 8px;">${item.name}</h4>`;
                    
                    if (item.category === 'monster' || item.category === 'player') {
                        html += `<p style="font-size: 11px; color: #9ca3af;">HP: ${item.hp}/${item.maxHp} | AC: ${item.ac}</p>`;
                        if (item.cr) html += `<p style="font-size: 10px; color: #6b7280;">CR: ${item.cr}</p>`;
                    } else if (item.category === 'spell') {
                        html += `<p style="font-size: 11px; color: #9ca3af;">Level ${item.level} ${item.school}</p>`;
                        if (item.damage) html += `<p style="font-size: 10px; color: #6b7280;">Damage: ${item.damage}</p>`;
                        if (item.healing) html += `<p style="font-size: 10px; color: #6b7280;">Healing: ${item.healing}</p>`;
                    } else if (item.category === 'item' || item.category === 'equipment') {
                        if (item.damage) html += `<p style="font-size: 10px; color: #6b7280;">Damage: ${item.damage}</p>`;
                        if (item.ac) html += `<p style="font-size: 10px; color: #6b7280;">AC: ${item.ac}</p>`;
                        if (item.healing) html += `<p style="font-size: 10px; color: #6b7280;">Healing: ${item.healing}</p>`;
                    }
                    
                    html += `<button class="btn btn-small btn-primary" style="width: 100%; margin-top: 8px; padding: 4px 8px; font-size: 10px;" onclick="game.addFromLibrarySidebar('${item.name}', '${item.category}')">Add to Board</button>`;
                    
                    card.innerHTML = html;
                    grid.appendChild(card);
                });
            },
            
            addFromLibrarySidebar(name, category) {
                this.addFromLibrary(name, category);
                // Keep sidebar open but switch to combat tab
                switchTab({target: document.querySelector('.tab[onclick*="combat"]')}, 'combat');
            },
            
            filterSidebarLibrary(filterType) {
                const cards = document.querySelectorAll('#sidebarLibraryGrid .content-card');
                cards.forEach(card => {
                    if (filterType === 'all' || card.dataset.type === filterType) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
            
            searchSidebarLibrary(searchTerm) {
                const cards = document.querySelectorAll('#sidebarLibraryGrid .content-card');
                const term = searchTerm.toLowerCase();
                
                cards.forEach(card => {
                    if (card.dataset.name.includes(term)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
            
            // Background Music Functions
            setBackgroundMusicFromFile(file) {
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.backgroundMusic.url = e.target.result;
                        localStorage.setItem('dndBackgroundMusic', e.target.result);
                        if (this.backgroundMusic.audio) {
                            this.backgroundMusic.audio.pause();
                            this.backgroundMusic.audio = null;
                        }
                        this.backgroundMusic.audio = new Audio();
                        this.backgroundMusic.audio.src = e.target.result;
                        this.backgroundMusic.audio.loop = true;
                        this.backgroundMusic.audio.volume = 0.3;
                    };
                    reader.readAsDataURL(file);
                }
            },
            
            playBackgroundMusic() {
                if (this.backgroundMusic.audio && !this.backgroundMusic.isPlaying) {
                    this.backgroundMusic.audio.play().then(() => {
                        this.backgroundMusic.isPlaying = true;
                        document.getElementById('playBtn').classList.add('active');
                        document.getElementById('pauseBtn').classList.remove('active');
                    }).catch(e => console.log('Music play failed:', e));
                }
            },
            
            pauseBackgroundMusic() {
                if (this.backgroundMusic.audio && this.backgroundMusic.isPlaying) {
                    this.backgroundMusic.audio.pause();
                    this.backgroundMusic.isPlaying = false;
                    document.getElementById('playBtn').classList.remove('active');
                    document.getElementById('pauseBtn').classList.add('active');
                }
            },
            
            // Setup Drawing Canvas
            setupDrawingCanvas() {
                this.drawingCanvas = document.getElementById('drawingCanvas');
                this.drawingCtx = this.drawingCanvas.getContext('2d');
                
                const resizeCanvas = () => {
                    const board = document.getElementById('gameBoard');
                    this.drawingCanvas.width = board.offsetWidth;
                    this.drawingCanvas.height = board.offsetHeight;
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // Drawing event listeners
                this.drawingCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.drawingCanvas.addEventListener('mousemove', (e) => this.draw(e));
                this.drawingCanvas.addEventListener('mouseup', () => this.stopDrawing());
                this.drawingCanvas.addEventListener('mouseout', () => this.stopDrawing());
            },
            
            // Drawing Functions
            startDrawing(e) {
                if (!this.drawMode) return;
                
                const rect = this.drawingCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.isDrawing = true;
                this.lastDrawX = x;
                this.lastDrawY = y;
                
                if (this.eraseMode) {
                    this.drawingCtx.globalCompositeOperation = 'destination-out';
                    this.drawingCtx.lineWidth = 20;
                } else {
                    this.drawingCtx.globalCompositeOperation = 'source-over';
                    this.drawingCtx.strokeStyle = '#fbbf24';
                    this.drawingCtx.lineWidth = 3;
                }
                
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(x, y);
            },
            
            draw(e) {
                if (!this.isDrawing || !this.drawMode) return;
                
                const rect = this.drawingCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.eraseMode) {
                    this.drawingCtx.globalCompositeOperation = 'destination-out';
                    this.drawingCtx.lineWidth = 20;
                } else {
                    this.drawingCtx.globalCompositeOperation = 'source-over';
                    this.drawingCtx.strokeStyle = '#fbbf24';
                    this.drawingCtx.lineWidth = 3;
                }
                
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(this.lastDrawX, this.lastDrawY);
                this.drawingCtx.lineTo(x, y);
                this.drawingCtx.stroke();
                
                this.lastDrawX = x;
                this.lastDrawY = y;
            },
            
            stopDrawing() {
                this.isDrawing = false;
            },
            
            toggleDrawMode() {
                this.drawMode = !this.drawMode;
                const btn = document.getElementById('drawToggle');
                const canvas = document.getElementById('drawingCanvas');
                
                btn.classList.toggle('active', this.drawMode);
                canvas.classList.toggle('drawing-mode', this.drawMode);
                
                if (this.drawMode) {
                    this.eraseMode = false;
                    document.getElementById('eraseToggle').classList.remove('active');
                }
                
                this.addLog(`Draw mode ${this.drawMode ? 'enabled' : 'disabled'}`, 'info');
            },
            
            toggleEraseMode() {
                this.eraseMode = !this.eraseMode;
                const btn = document.getElementById('eraseToggle');
                btn.classList.toggle('active', this.eraseMode);
                
                if (this.eraseMode && !this.drawMode) {
                    this.toggleDrawMode();
                }
                
                this.addLog(`Erase mode ${this.eraseMode ? 'enabled' : 'disabled'}`, 'info');
            },
            
            clearDrawing() {
                console.log('clearDrawing function called');
                if (confirm('Clear all drawings?')) {
                    const canvas = document.getElementById('drawingCanvas');
                    console.log('Canvas found:', canvas);
                    if (canvas) {
                        console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                        const ctx = canvas.getContext('2d');
                        console.log('Context:', ctx);
                        
                        // Try multiple clearing methods
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'rgba(0,0,0,0)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Reset canvas completely
                        const parent = canvas.parentNode;
                        const newCanvas = document.createElement('canvas');
                        newCanvas.id = 'drawingCanvas';
                        newCanvas.className = canvas.className;
                        newCanvas.width = canvas.width;
                        newCanvas.height = canvas.height;
                        
                        parent.replaceChild(newCanvas, canvas);
                        
                        // Reinitialize drawing on new canvas
                        this.drawingCanvas = newCanvas;
                        this.drawingCtx = newCanvas.getContext('2d');
                        
                        // Re-add event listeners
                        this.drawingCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                        this.drawingCanvas.addEventListener('mousemove', (e) => this.draw(e));
                        this.drawingCanvas.addEventListener('mouseup', () => this.stopDrawing());
                        this.drawingCanvas.addEventListener('mouseout', () => this.stopDrawing());
                        
                        this.addLog('Drawing cleared', 'info');
                        console.log('Drawing cleared successfully');
                    } else {
                        this.addLog('Drawing canvas not found', 'info');
                        console.log('Canvas not found!');
                    }
                }
            },
            
            // Create Entity with full D&D 5e stats
            createEntity(type, name, x, y) {
                const entity = {
                    id: this.nextId++,
                    type: type,
                    name: name,
                    x: x,
                    y: y,
                    scale: 1.0, // Add scale property for token resizing
                    color: type === 'player' ? '#3b82f6' : 
                           type === 'npc' ? '#f59e0b' : 
                           type === 'monster' ? '#ef4444' : '#fbbf24',
                    image: ''
                };
                
                // Only add full character attributes for players, monsters, and NPCs
                if (type === 'player' || type === 'monster' || type === 'npc') {
                    Object.assign(entity, {
                        hp: 10,
                        maxHp: 10,
                        tempHp: 0,
                        ac: 10,
                        speed: 30,
                        initiative: 0,
                        str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10,
                        proficiencyBonus: 2,
                        attacks: [],
                        spells: [],
                        spellSlots: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0},
                        spellSlotsUsed: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0},
                        inventory: [],
                        equipment: {
                            armor: null,
                            mainHand: null,
                            offHand: null,
                            helmet: null,
                            boots: null,
                            gloves: null,
                            amulet: null,
                            cloak: null,
                            ring1: null,
                            ring2: null
                        },
                        conditions: [],
                        conditionTurns: {}, // Track turns remaining for conditions
                        savingThrows: {str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0},
                        skills: {},
                        damageResistances: [],
                        damageImmunities: [],
                        damageVulnerabilities: [],
                        conditionImmunities: [],
                        deathSaves: {successes: 0, failures: 0},
                        concentrating: null,
                        movement: 30,
                        actionUsed: false,
                        bonusActionUsed: false,
                        reactionUsed: false,
                        class: type === 'player' || type === 'npc' ? 'Fighter' : 'Monster',
                        race: type === 'player' || type === 'npc' ? 'Human' : 'Humanoid',
                        level: type === 'player' || type === 'npc' ? 1 : 1,
                        hitDice: '1d10',
                        hitDiceRemaining: 1
                    });
                    
                    if (type === 'player' || type === 'npc') {
                        entity.spellSlots = {1: 2, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0};
                    }
                    // Add base combat actions
                    this.addBaseCombatActions(entity);
                } else if (type === 'item' || type === 'container') {
                    // Items only have basic properties needed for their function
                    Object.assign(entity, {
                        description: '',
                        value: 0,
                        weight: 0,
                        consumable: false,
                        healing: null,
                        effect: null,
                        spell: null,
                        sound: ''
                    });
                    
                    if (type === 'container') {
                        entity.inventory = [];
                        entity.isMimic = false;
                    }
                } else if (type === 'effect') {
                    Object.assign(entity, {
                        url: '',
                        loop: false,
                        playOnce: true,
                        duration: 1000 // ms, if playOnce
                    });
                }
                
                // Apply template if exists
                if (type === 'monster') {
                    const template = this.library.monsters.find(m => m.name === name);
                    if (template) {
                        Object.assign(entity, JSON.parse(JSON.stringify(template)));
                        entity.id = this.nextId - 1;
                        entity.x = x;
                        entity.y = y;
                        entity.scale = 1.0;
                        // Ensure monsters have inventories for loot drops
                        if (!entity.inventory) {
                            entity.inventory = [];
                        }
                    } else {
                        // Add some random loot to custom monsters
                        entity.inventory = [];
                        if (Math.random() < 0.3) { // 30% chance for loot
                            const lootTable = [...this.library.items, ...this.library.equipment];
                            const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                            entity.inventory.push(JSON.parse(JSON.stringify(randomLoot)));
                        }
                    }
                } else if (type === 'item' || type === 'container') {
                    let template = this.library.items.find(i => i.name === name);
                    if (!template) {
                        template = this.library.equipment.find(e => e.name === name);
                    }
                    if (template) {
                        Object.assign(entity, JSON.parse(JSON.stringify(template)));
                        entity.id = this.nextId - 1;
                        entity.x = x;
                        entity.y = y;
                        entity.scale = 1.0;
                        if (type === 'container' && !entity.inventory) {
                            entity.inventory = [];
                        }
                    }
                    
                    // Set container color based on content
                    if (type === 'container') {
                        if (entity.isMimic) {
                            entity.color = '#8B4513'; // Brown for mimics
                        } else if (!entity.inventory || entity.inventory.length === 0) {
                            entity.color = '#6b7280'; // Grey for empty chests
                        } else {
                            entity.color = '#fbbf24'; // Gold for filled chests
                        }
                    }
                }
                
                return entity;
            },
            
            addBaseCombatActions(entity) {
                const unarmed = {
                    name: 'Unarmed Attack',
                    toHit: this.getAbilityModifier(entity.str) + entity.proficiencyBonus,
                    damage: '1+' + this.getAbilityModifier(entity.str),
                    damageType: 'bludgeoning',
                    range: 5,
                    actionType: 'action',
                    sound: ''
                };
                if (!entity.attacks.some(a => a.name === 'Unarmed Attack')) {
                    entity.attacks.push(unarmed);
                }
                
                const baseAbilities = [
                    {name: 'Shove', description: 'Push or prone target', actionType: 'action', sound: ''},
                    {name: 'Hide', description: 'Attempt to hide', actionType: 'action', sound: ''},
                    {name: 'Disengage', description: 'No opportunity attacks', actionType: 'action', sound: ''},
                    {name: 'Dash', description: 'Double movement', actionType: 'action', sound: ''},
                    {name: 'Help', description: 'Give advantage to ally', actionType: 'action', sound: ''},
                    {name: 'Ready', description: 'Prepare an action', actionType: 'action', sound: ''}
                ];

                baseAbilities.forEach(ability => {
                    if (!entity.abilities.some(a => a.name === ability.name)) {
                        entity.abilities.push(ability);
                    }
                });
            },
            
            // Get Ability Modifier
            getAbilityModifier(score) {
                return Math.floor((score - 10) / 2);
            },
            
            // Calculate Total AC
            calculateAC(entity) {
                let baseAC = 10;
                let dexMod = this.getAbilityModifier(entity.dex);
                
                if (entity.equipment && entity.equipment.armor) {
                    const armor = entity.equipment.armor;
                    baseAC = armor.ac;
                    
                    if (armor.maxDexBonus !== null && armor.maxDexBonus !== undefined) {
                        dexMod = Math.min(dexMod, armor.maxDexBonus);
                    } else if (armor.maxDexBonus === 0) {
                        dexMod = 0;
                    }
                } else {
                    // Unarmored defense
                    baseAC = 10 + dexMod;
                }
                
                // Add shield
                if (entity.equipment && entity.equipment.offHand && entity.equipment.offHand.type === 'shield') {
                    baseAC += entity.equipment.offHand.ac;
                }
                
                // Add other bonuses
                if (entity.equipment) {
                    Object.values(entity.equipment).forEach(item => {
                        if (item && item.ac && item.type !== 'armor' && item.type !== 'shield') {
                            baseAC += item.ac;
                        }
                    });
                }
                
                return baseAC;
            },
            
            // Roll Initiative
            rollInitiative() {
                this.entities.forEach(entity => {
                    if (entity.type !== 'item' && entity.type !== 'container') {
                        const dexMod = this.getAbilityModifier(entity.dex);
                        const roll = this.rollDice('1d20');
                        entity.initiative = roll + dexMod;
                        
                        // Tiebreaker is dexterity score
                        entity.initiativeTiebreaker = entity.dex;
                    }
                });
                
                this.updateTurnOrder();
                this.currentTurn = 0;
                this.roundNumber = 1;
                this.resetTurnActions();
                this.addLog('üé≤ Initiative rolled! Round 1 begins!', 'info');
            },
            
            // Update Turn Order with proper tiebreaking
            updateTurnOrder() {
                this.turnOrder = this.entities
                    .filter(e => (e.type === 'player' || e.type === 'monster' || e.type === 'npc') && e.hp > 0)
                    .sort((a, b) => {
                        if (b.initiative !== a.initiative) {
                            return b.initiative - a.initiative;
                        }
                        return b.initiativeTiebreaker - a.initiativeTiebreaker;
                    });
                
                const div = document.getElementById('turnOrder');
                if (!div) return;
                
                div.innerHTML = '';
                this.turnOrder.forEach((entity, i) => {
                    const item = document.createElement('div');
                    item.className = `turn-item ${i === this.currentTurn ? 'active' : ''}`;
                    item.innerHTML = `
                        <span style="color: ${entity.color};">${entity.name}</span>
                        <div>
                            <span>Init: ${entity.initiative}</span>
                            <div class="turn-actions">
                                ${i === this.currentTurn ? this.getTurnActionsDisplay(entity) : ''}
                            </div>
                        </div>
                    `;
                    div.appendChild(item);
                });
            },
            
            // Get Turn Actions Display
            getTurnActionsDisplay(entity) {
                if (entity.type !== 'player' && entity.type !== 'monster' && entity.type !== 'npc') return '';
                
                return `
                    ${!entity.actionUsed ? '‚öîÔ∏è' : ''}
                    ${!entity.bonusActionUsed ? '‚ö°' : ''}
                    ${!entity.reactionUsed ? 'üõ°Ô∏è' : ''}
                    ${entity.movement > 0 ? `üë£${entity.movement}ft` : ''}
                `;
            },
            
            // Reset Turn Actions
            resetTurnActions() {
                if (this.turnOrder.length === 0) return;
                
                const current = this.turnOrder[this.currentTurn];
                if (current) {
                    current.actionUsed = false;
                    current.bonusActionUsed = false;
                    current.movement = current.speed;
                }
            },
            
            // Next Turn
            nextTurn() {
                if (this.turnOrder.length === 0) return;
                
                // Handle end of turn effects
                const current = this.turnOrder[this.currentTurn];
                if (current) {
                    this.handleEndOfTurn(current);
                }
                
                // Move to next
                this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
                
                // Check for new round
                if (this.currentTurn === 0) {
                    this.roundNumber++;
                    this.addLog(`üìú Round ${this.roundNumber} begins!`, 'info');
                    
                    // Reset reactions for all and update condition durations
                    this.entities.forEach(e => {
                        if (e.type === 'player' || e.type === 'monster' || e.type === 'npc') {
                            e.reactionUsed = false;
                            
                            // Decrement condition turn counters
                            Object.keys(e.conditionTurns).forEach(condition => {
                                e.conditionTurns[condition]--;
                                if (e.conditionTurns[condition] <= 0) {
                                    this.removeCondition(e, condition);
                                    delete e.conditionTurns[condition];
                                }
                            });
                        }
                    });
                }
                
                // Skip dead/unconscious
                while (this.turnOrder[this.currentTurn] && 
                       (this.turnOrder[this.currentTurn].hp <= 0 || 
                        this.turnOrder[this.currentTurn].conditions.includes('unconscious'))) {
                    if (this.turnOrder.every(e => e.hp <= 0 || e.conditions.includes('unconscious'))) {
                        this.addLog('Combat ended - no active combatants!', 'info');
                        return;
                    }
                    this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
                }
                
                const newCurrent = this.turnOrder[this.currentTurn];
                if (newCurrent) {
                    this.resetTurnActions();
                    this.handleStartOfTurn(newCurrent);
                    this.addLog(`‚û°Ô∏è ${newCurrent.name}'s turn begins!`, 'info');
                }
                
                this.updateTurnOrder();
                this.render();
            },
            
            // End Current Turn
            endTurn() {
                this.nextTurn();
            },
            
            // Handle Start of Turn
            handleStartOfTurn(entity) {
                // Regeneration
                if (entity.abilities) {
                    const regen = entity.abilities.find(a => a.name === 'Regeneration');
                    if (regen && entity.hp > 0 && entity.hp < entity.maxHp) {
                        const healing = 10; // Standard troll regen
                        entity.hp = Math.min(entity.maxHp, entity.hp + healing);
                        this.addLog(`${entity.name} regenerates ${healing} HP!`, 'heal');
                        this.createFloatingText(`+${healing}`, entity.x, entity.y - 30, '#00ff00');
                        this.playSound('heal');
                    }
                }
                
                // Death saves
                if (entity.hp === 0 && !entity.conditions.includes('stable')) {
                    this.rollDeathSave(entity);
                }
            },
            
            // Handle End of Turn
            handleEndOfTurn(entity) {
                // Nothing specific yet, but ready for concentration checks, etc.
            },
            
            // Roll Death Save
            rollDeathSave(entity) {
                const roll = this.rollDice('1d20');
                
                if (roll === 1) {
                    entity.deathSaves.failures += 2;
                    this.addLog(`${entity.name} critically fails death save! (${roll})`, 'death');
                } else if (roll === 20) {
                    entity.hp = 1;
                    entity.deathSaves.successes = 0;
                    entity.deathSaves.failures = 0;
                    this.addLog(`${entity.name} critically succeeds death save and regains consciousness with 1 HP!`, 'heal');
                } else if (roll >= 10) {
                    entity.deathSaves.successes++;
                    this.addLog(`${entity.name} succeeds death save (${roll}). Successes: ${entity.deathSaves.successes}/3`, 'save');
                } else {
                    entity.deathSaves.failures++;
                    this.addLog(`${entity.name} fails death save (${roll}). Failures: ${entity.deathSaves.failures}/3`, 'death');
                }
                
                if (entity.deathSaves.successes >= 3) {
                    entity.conditions.push('stable');
                    entity.deathSaves.successes = 0;
                    entity.deathSaves.failures = 0;
                    this.addLog(`${entity.name} is stabilized!`, 'heal');
                } else if (entity.deathSaves.failures >= 3) {
                    entity.conditions.push('dead');
                    this.addLog(`${entity.name} has died!`, 'death');
                }
                
                this.render();
            },
            
            // Perform Attack
            performAttack(attacker, target, attack) {
                if (attacker.id === target.id) {
                    this.addLog('Cannot target self!', 'info');
                    return;
                }
                
                // Check if attacker can act
                if (this.enforceTurns && !this.editMode && this.turnOrder[this.currentTurn]?.id !== attacker.id) {
                    this.addLog('Not your turn!', 'info');
                    return;
                }
                
                if (attacker.actionUsed && !attack.bonusAction) {
                    this.addLog(`${attacker.name} has already used their action!`, 'info');
                    return;
                }
                
                // Roll to hit
                const d20 = this.rollDice('1d20', true);
                const profBonus = attacker.proficiencyBonus || 2;
                const abilityMod = attack.finesse ? 
                    Math.max(this.getAbilityModifier(attacker.str), this.getAbilityModifier(attacker.dex)) :
                    this.getAbilityModifier(attack.ranged ? attacker.dex : attacker.str);
                
                let toHitBonus = (attack.toHit !== undefined) ? attack.toHit : abilityMod + profBonus;
                
                // Add equipment bonuses
                if (attacker.equipment && attacker.equipment.mainHand && attacker.equipment.mainHand.attackBonus) {
                    toHitBonus += attacker.equipment.mainHand.attackBonus;
                }
                
                // Check for advantage/disadvantage
                let hasAdvantage = false;
                let hasDisadvantage = false;
                
                if (attacker.conditions.includes('invisible')) hasAdvantage = true;
                if (attacker.conditions.includes('poisoned')) hasDisadvantage = true;
                if (attacker.conditions.includes('frightened')) hasDisadvantage = true;
                if (target.conditions.includes('paralyzed')) hasAdvantage = true;
                if (target.conditions.includes('stunned')) hasAdvantage = true;
                if (target.conditions.includes('unconscious')) hasAdvantage = true;
                
                let roll = d20;
                if (hasAdvantage && !hasDisadvantage) {
                    const second = this.rollDice('1d20', true);
                    roll = Math.max(d20, second);
                    this.showEventPopup(`Attack Roll (Advantage)`, `${roll} (${d20}, ${second}) + ${toHitBonus} = ${roll + toHitBonus}`);
                } else if (hasDisadvantage && !hasAdvantage) {
                    const second = this.rollDice('1d20', true);
                    roll = Math.min(d20, second);
                    this.showEventPopup(`Attack Roll (Disadvantage)`, `${roll} (${d20}, ${second}) + ${toHitBonus} = ${roll + toHitBonus}`);
                } else {
                    this.showEventPopup(`Attack Roll`, `${roll} + ${toHitBonus} = ${roll + toHitBonus}`);
                }
                
                const totalHit = roll + toHitBonus;
                const targetAC = this.calculateAC(target);
                
                if (roll === 1) {
                    this.addLog(`${attacker.name} critically misses ${target.name}!`, 'info');
                    this.createFloatingText('CRITICAL MISS!', target.x, target.y - 30, '#808080');
                } else if (roll === 20 || totalHit >= targetAC) {
                    // Calculate damage
                    let damage = this.rollDice(attack.damage);
                    
                    if (roll === 20) {
                        damage *= 2;
                        this.addLog(`üí• ${attacker.name} CRITICALLY HITS ${target.name} for ${damage} ${attack.damageType} damage!`, 'damage');
                    } else {
                        this.addLog(`‚öîÔ∏è ${attacker.name} hits ${target.name} for ${damage} ${attack.damageType} damage!`, 'damage');
                    }
                    
                    // Apply damage
                    this.dealDamage(target, damage, attack.damageType);
                    this.createFloatingText(`-${damage}`, target.x, target.y - 30, '#ff0000');
                    
                    // Special effects
                    if (attack.special) {
                        this.applySpecialAttackEffect(target, attack.special);
                    }
                    this.playSpecificSound(attack.sound);
                } else {
                    this.addLog(`${attacker.name} misses ${target.name}! (${totalHit} vs AC ${targetAC})`, 'info');
                    this.createFloatingText('MISS', target.x, target.y - 30, '#808080');
                }
                
                // Mark action used
                if (!attack.bonusAction) {
                    attacker.actionUsed = true;
                } else {
                    attacker.bonusActionUsed = true;
                }
                
                // Animation
                this.createPersistentArrow(attacker.x + 35, attacker.y + 35, target.x + 35, target.y + 35);
                setTimeout(() => this.createArrowAnimation(attacker.x + 35, attacker.y + 35, target.x + 35, target.y + 35), 100);
                
                this.updateTurnOrder();
                this.render();
            },
            
            // Apply Special Attack Effect
            applySpecialAttackEffect(target, special) {
                // Parse special effects like "DC 13 Str save or knocked prone"
                if (special.includes('save')) {
                    const dcMatch = special.match(/DC (\d+)/);
                    const saveMatch = special.match(/(Str|Dex|Con|Int|Wis|Cha)/i);
                    
                    if (dcMatch && saveMatch) {
                        const dc = parseInt(dcMatch[1]);
                        const ability = saveMatch[1].toLowerCase();
                        const mod = this.getAbilityModifier(target[ability]);
                        const roll = this.rollDice('1d20');
                        const total = roll + mod;
                        
                        if (total < dc) {
                            if (special.includes('prone')) {
                                this.addCondition(target, 'prone');
                                this.addLog(`${target.name} is knocked prone! (Save: ${total} vs DC ${dc})`, 'info');
                            } else if (special.includes('poison')) {
                                const poisonDamage = this.rollDice('2d8');
                                this.dealDamage(target, poisonDamage, 'poison');
                                this.addLog(`${target.name} takes ${poisonDamage} poison damage! (Save: ${total} vs DC ${dc})`, 'damage');
                            }
                        } else {
                            this.addLog(`${target.name} resists the effect! (Save: ${total} vs DC ${dc})`, 'info');
                        }
                    }
                }
            },
            
            // Deal Damage (with resistances/immunities/vulnerabilities)
            dealDamage(target, amount, damageType) {
                let finalDamage = amount;
                
                // Check immunities
                if (target.damageImmunities && target.damageImmunities.includes(damageType)) {
                    this.addLog(`${target.name} is immune to ${damageType} damage!`, 'info');
                    this.showEventPopup('Damage', `${target.name} is immune to ${damageType} damage!`);
                    return;
                }
                
                // Check resistances
                if (target.damageResistances && target.damageResistances.includes(damageType)) {
                    finalDamage = Math.floor(finalDamage / 2);
                    this.addLog(`${target.name} resists ${damageType} damage!`, 'info');
                    this.showEventPopup('Damage', `${target.name} resists ${damageType} damage!`);
                }
                
                // Check vulnerabilities
                if (target.damageVulnerabilities && target.damageVulnerabilities.includes(damageType)) {
                    finalDamage = finalDamage * 2;
                    this.addLog(`${target.name} is vulnerable to ${damageType} damage!`, 'info');
                    this.showEventPopup('Damage', `${target.name} is vulnerable to ${damageType} damage!`);
                }
                
                // Apply to temp HP first
                if (target.tempHp > 0) {
                    const tempDamage = Math.min(target.tempHp, finalDamage);
                    target.tempHp -= tempDamage;
                    finalDamage -= tempDamage;
                }
                
                // Then regular HP
                target.hp = Math.max(0, target.hp - finalDamage);
                
                // Check for death/unconscious
                if (target.hp === 0) {
                    if (target.type === 'player' || target.type === 'npc') {
                        if (!target.conditions.includes('unconscious')) {
                            this.addCondition(target, 'unconscious');
                            this.addLog(`${target.name} falls unconscious!`, 'death');
                            this.showEventPopup('Condition', `${target.name} falls unconscious!`);
                        }
                    } else if (target.type === 'monster') {
                        this.addCondition(target, 'dead');
                        this.addLog(`${target.name} is defeated!`, 'death');
                        this.showEventPopup('Condition', `${target.name} is defeated!`);
                        
                        // Drop inventory items when monster dies
                        if (target.inventory && target.inventory.length > 0) {
                            target.inventory.forEach((item, index) => {
                                const angle = (index / target.inventory.length) * Math.PI * 2;
                                const distance = 60 + (index * 15); // Spread items around the dead monster
                                const newX = target.x + Math.cos(angle) * distance;
                                const newY = target.y + Math.sin(angle) * distance;
                                
                                const newItem = this.createEntity('item', item.name, newX, newY);
                                Object.assign(newItem, item);
                                newItem.id = this.nextId++;
                                newItem.x = newX;
                                newItem.y = newY;
                                this.entities.push(newItem);
                            });
                            this.addLog(`${target.name} drops ${target.inventory.length} items!`, 'info');
                        }
                    }
                }
            },
            
            // Cast Spell
            castSpell(caster, target, spell, spellLevel = null) {
                if (caster.id === target.id && spell.name !== 'Shield' && spell.name !== 'Misty Step') {
                    this.addLog('Cannot target self with this spell!', 'info');
                    return;
                }
                
                // Check spell slots
                const actualLevel = spellLevel || spell.level;
                if (spell.level > 0) {
                    if (!caster.spellSlots || caster.spellSlots[actualLevel] <= caster.spellSlotsUsed[actualLevel]) {
                        this.addLog(`${caster.name} has no level ${actualLevel} spell slots remaining!`, 'info');
                        return;
                    }
                }
                
                // Check action economy
                if (spell.castingTime === 'action' && caster.actionUsed) {
                    this.addLog(`${caster.name} has already used their action!`, 'info');
                    return;
                } else if (spell.castingTime === 'bonus action' && caster.bonusActionUsed) {
                    this.addLog(`${caster.name} has already used their bonus action!`, 'info');
                    return;
                } else if (spell.castingTime === 'reaction' && caster.reactionUsed) {
                    this.addLog(`${caster.name} has already used their reaction!`, 'info');
                    return;
                }
                
                // Cast the spell
                this.addLog(`‚ú® ${caster.name} casts ${spell.name}${actualLevel > spell.level ? ` at level ${actualLevel}` : ''}!`, 'info');
                this.showEventPopup('Action', `${caster.name} casts ${spell.name}!`);
                this.playSpecificSound(spell.sound);
                
                // Use spell slot
                if (spell.level > 0) {
                    caster.spellSlotsUsed[actualLevel]++;
                }
                
                // Handle concentration
                if (spell.concentration) {
                    if (caster.concentrating) {
                        this.addLog(`${caster.name} loses concentration on ${caster.concentrating}`, 'info');
                    }
                    caster.concentrating = spell.name;
                }
                
                // Apply spell effects
                if (spell.damage) {
                    let damage = this.rollDice(spell.damage);
                    
                    // Higher level casting
                    if (actualLevel > spell.level && spell.higherLevel) {
                        const extraLevels = actualLevel - spell.level;
                        const extraDamage = this.rollDice(`${extraLevels}d6`);
                        damage += extraDamage;
                    }
                    
                    if (spell.savingThrow) {
                        const saveMod = this.getAbilityModifier(target[spell.savingThrow.substr(0, 3)]);
                        const saveRoll = this.rollDice('1d20');
                        const saveTotal = saveRoll + saveMod;
                        
                        if (saveTotal >= spell.saveDC) {
                            damage = Math.floor(damage / 2);
                            this.addLog(`${target.name} saves! (${saveTotal} vs DC ${spell.saveDC}) Half damage.`, 'save');
                        } else {
                            this.addLog(`${target.name} fails save! (${saveTotal} vs DC ${spell.saveDC})`, 'save');
                        }
                    }
                    
                    this.dealDamage(target, damage, spell.damageType);
                    this.createFloatingText(`-${damage}`, target.x, target.y - 30, '#ff00ff');
                } else if (spell.healing) {
                    let healing = this.rollDice(spell.healing.replace('mod', '3'));
                    
                    // Higher level casting
                    if (actualLevel > spell.level && spell.higherLevel) {
                        const extraLevels = actualLevel - spell.level;
                        const extraHealing = this.rollDice(`${extraLevels}d8`);
                        healing += extraHealing;
                    }
                    
                    target.hp = Math.min(target.maxHp, target.hp + healing);
                    this.addLog(`${target.name} heals ${healing} HP!`, 'heal');
                    this.createFloatingText(`+${healing}`, target.x, target.y - 30, '#00ff00');
                    this.playSpecificSound(spell.sound);
                } else if (spell.effect) {
                    this.applySpellEffect(caster, target, spell.effect, spell);
                }
                
                // Mark action used
                if (spell.castingTime === 'action') caster.actionUsed = true;
                else if (spell.castingTime === 'bonus action') caster.bonusActionUsed = true;
                else if (spell.castingTime === 'reaction') caster.reactionUsed = true;
                
                // Animation
                this.createPersistentArrow(caster.x + 35, caster.y + 35, target.x + 35, target.y + 35);
                setTimeout(() => this.createSpellAnimation(caster.x + 35, caster.y + 35, target.x + 35, target.y + 35, spell.school), 100);
                
                // Visual effect
                this.applyVisualEffect(target, spell.visualEffect);
                
                this.updateTurnOrder();
                this.render();
            },
            
            // Apply Spell Effect
            applySpellEffect(caster, target, effect, spell) {
                switch (effect.type) {
                    case 'condition':
                        if (spell.savingThrow) {
                            const saveMod = this.getAbilityModifier(target[spell.savingThrow.substr(0, 3)]);
                            const saveRoll = this.rollDice('1d20');
                            const saveTotal = saveRoll + saveMod;
                            
                            if (saveTotal >= spell.saveDC) {
                                this.addLog(`${target.name} resists! (${saveTotal} vs DC ${spell.saveDC})`, 'save');
                                this.showEventPopup('Save', `${target.name} resists! (${saveTotal} vs DC ${spell.saveDC})`);
                                return;
                            }
                        }
                        this.addCondition(target, effect.condition);
                        this.showEventPopup('Condition', `${target.name} is now ${effect.condition}!`);
                        break;
                        
                    case 'ac_bonus':
                        target.ac += effect.value;
                        this.addLog(`${target.name} gains +${effect.value} AC!`, 'info');
                        this.showEventPopup('Buff', `${target.name} gains +${effect.value} AC!`);
                        break;
                        
                    case 'ac_set':
                        const dexMod = this.getAbilityModifier(target.dex);
                        target.ac = effect.value + dexMod;
                        this.addLog(`${target.name}'s AC is now ${target.ac}!`, 'info');
                        this.showEventPopup('Buff', `${target.name}'s AC is now ${target.ac}!`);
                        break;
                        
                    case 'buff':
                        this.addLog(`${target.name} is buffed: ${effect.effects.join(', ')}`, 'info');
                        this.showEventPopup('Buff', `${target.name} is buffed: ${effect.effects.join(', ')}`);
                        // Store buff for later reference
                        if (!target.buffs) target.buffs = [];
                        target.buffs.push({name: spell.name, effects: effect.effects});
                        break;
                        
                    case 'debuff':
                        this.addLog(`${target.name} is debuffed: ${effect.effects.join(', ')}`, 'info');
                        this.showEventPopup('Debuff', `${target.name} is debuffed: ${effect.effects.join(', ')}`);
                        if (!target.debuffs) target.debuffs = [];
                        target.debuffs.push({name: spell.name, effects: effect.effects});
                        break;
                        
                    case 'teleport':
                        // Move caster
                        const angle = Math.random() * Math.PI * 2;
                        caster.x += Math.cos(angle) * effect.distance * 5; // 5 pixels per foot
                        caster.y += Math.sin(angle) * effect.distance * 5;
                        this.addLog(`${caster.name} teleports!`, 'info');
                        this.showEventPopup('Action', `${caster.name} teleports!`);
                        break;
                        
                    case 'sleep':
                        const hpPool = this.rollDice(effect.hitpoints);
                        this.addLog(`Sleep affects ${hpPool} HP worth of creatures`, 'info');
                        this.showEventPopup('Spell', `Sleep affects ${hpPool} HP worth of creatures`);
                        // Would need to implement area selection for full effect
                        break;
                }
            },
            
            // Add Condition
            addCondition(entity, condition, turns = null) {
                if (!entity.conditions.includes(condition)) {
                    // Remove conflicting conditions
                    if (condition === 'unconscious') {
                        entity.hp = 0;
                    }
                    
                    entity.conditions.push(condition);
                    
                    // Track turns if specified
                    if (turns && turns > 0) {
                        if (!entity.conditionTurns) entity.conditionTurns = {};
                        entity.conditionTurns[condition] = turns;
                    }
                    
                    this.addLog(`${entity.name} is now ${condition}!`, 'info');
                    this.showEventPopup('Condition', `${entity.name} is now ${condition}!`);
                    
                    // Apply condition effects
                    const conditionData = this.conditions[condition];
                    if (conditionData && conditionData.effects) {
                        if (conditionData.effects.speed === 0) {
                            entity.movement = 0;
                        }
                    }
                }
                this.render();
            },
            
            // Remove Condition
            removeCondition(entity, condition) {
                const idx = entity.conditions.indexOf(condition);
                if (idx > -1) {
                    entity.conditions.splice(idx, 1);
                    if (entity.conditionTurns && entity.conditionTurns[condition]) {
                        delete entity.conditionTurns[condition];
                    }
                    this.addLog(`${entity.name} is no longer ${condition}!`, 'info');
                    this.showEventPopup('Condition', `${entity.name} is no longer ${condition}!`);
                }
                this.render();
            },
            
            // Roll Dice with display
            rollDice(formula, silent = false) {
                if (!formula) return 0;
                
                // Handle pure numbers
                if (!isNaN(formula)) return parseInt(formula);
                
                const match = formula.match(/(\d+)d(\d+)([+-]\d+)?/);
                if (!match) return parseInt(formula) || 0;
                
                const [, num, sides, mod] = match;
                const rolls = [];
                let total = 0;
                
                for (let i = 0; i < parseInt(num); i++) {
                    const roll = Math.floor(Math.random() * parseInt(sides)) + 1;
                    rolls.push(roll);
                    total += roll;
                }
                
                if (mod) total += parseInt(mod);
                total = Math.max(0, total);
                
                // Log the roll
                if (!silent) {
                    this.diceRollHistory.push({
                        formula,
                        rolls,
                        modifier: mod ? parseInt(mod) : 0,
                        total
                    });
                    
                    if (this.diceRollHistory.length > 20) {
                        this.diceRollHistory.shift();
                    }
                    this.showEventPopup(`Roll: ${formula}`, `Total: ${total} (${rolls.join(', ')}${mod ? ` ${mod}` : ''})`);
                }
                
                return total;
            },
            
            // Enhanced Event Popup
            showEventPopup(title, breakdown) {
                const existing = document.querySelector('.roll-result');
                if (existing) existing.remove();
                
                const result = document.createElement('div');
                result.className = 'roll-result';
                result.innerHTML = `
                    <h3>${title}</h3>
                    <div class="roll-breakdown">${breakdown}</div>
                `;
                document.body.appendChild(result);
                
                setTimeout(() => result.remove(), 5000);
            },
            
            // Play Sound
            playSpecificSound(url) {
                if (url) {
                    const audio = new Audio(url);
                    audio.play().catch(e => console.log('Sound play failed:', e));
                }
            },
            
            setSoundFromFile(type, file) {
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.sounds[type] = e.target.result;
                        localStorage.setItem('dndSounds', JSON.stringify(this.sounds));
                    };
                    reader.readAsDataURL(file);
                }
            },
            
            // Load Sounds
            loadSounds() {
                const saved = localStorage.getItem('dndSounds');
                if (saved) {
                    this.sounds = JSON.parse(saved);
                }
                
                // Load background music
                const savedMusic = localStorage.getItem('dndBackgroundMusic');
                if (savedMusic) {
                    this.backgroundMusic.url = savedMusic;
                    this.backgroundMusic.audio = new Audio();
                    this.backgroundMusic.audio.src = savedMusic;
                    this.backgroundMusic.audio.loop = true;
                    this.backgroundMusic.audio.volume = 0.3;
                }
            },
            
            // Equipment Management
            equipItem(entity, item) {
                if (!item || !item.equipSlot) return;
                
                const slot = item.equipSlot;
                const currentItem = entity.equipment[slot];
                
                // Unequip current item
                if (currentItem) {
                    this.unequipItem(entity, currentItem);
                }
                
                // Equip new item
                entity.equipment[slot] = item;
                
                // Apply effects
                if (item.attackBonus) {
                    entity.attacks.forEach(attack => {
                        attack.toHit = (attack.toHit || 0) + item.attackBonus;
                    });
                }
                
                if (item.damageBonus) {
                    entity.attacks.forEach(attack => {
                        const current = parseInt(attack.damage.match(/[+-]\d+$/)?.[0] || '0');
                        attack.damage = attack.damage.replace(/[+-]\d+$/, '') + 
                                      (current + item.damageBonus >= 0 ? '+' : '') + 
                                      (current + item.damageBonus);
                    });
                }
                
                if (item.effect) {
                    this.applyEquipmentEffect(entity, item.effect, true);
                }
                
                // Remove from inventory
                const idx = entity.inventory.findIndex(i => i === item);
                if (idx > -1) entity.inventory.splice(idx, 1);
                
                // Recalculate AC
                entity.ac = this.calculateAC(entity);
                
                this.addLog(`${entity.name} equips ${item.name}`, 'info');
                this.showEventPopup('Action', `${entity.name} equips ${item.name}`);
                this.render();
            },
            
            unequipItem(entity, item) {
                if (!item || !item.equipSlot) return;
                
                const slot = item.equipSlot;
                entity.equipment[slot] = null;
                
                // Reverse effects
                if (item.attackBonus) {
                    entity.attacks.forEach(attack => {
                        attack.toHit = (attack.toHit || 0) - item.attackBonus;
                    });
                }
                
                if (item.damageBonus) {
                    entity.attacks.forEach(attack => {
                        const current = parseInt(attack.damage.match(/[+-]\d+$/)?.[0] || '0');
                        const newBonus = current - item.damageBonus;
                        attack.damage = attack.damage.replace(/[+-]\d+$/, '') + 
                                      (newBonus !== 0 ? (newBonus >= 0 ? '+' : '') + newBonus : '');
                    });
                }
                
                if (item.effect) {
                    this.applyEquipmentEffect(entity, item.effect, false);
                }
                
                // Add to inventory
                entity.inventory.push(item);
                
                // Recalculate AC
                entity.ac = this.calculateAC(entity);
                
                this.addLog(`${entity.name} unequips ${item.name}`, 'info');
                this.showEventPopup('Action', `${entity.name} unequips ${item.name}`);
                this.render();
            },
            
            // Apply Equipment Effect
            applyEquipmentEffect(entity, effect, apply) {
                const multiplier = apply ? 1 : -1;
                
                switch (effect.type) {
                    case 'ability_score':
                        if (apply) {
                            entity[`original_${effect.ability}`] = entity[effect.ability];
                            entity[effect.ability] = effect.value;
                        } else {
                            entity[effect.ability] = entity[`original_${effect.ability}`] || entity[effect.ability];
                        }
                        break;
                        
                    case 'speed':
                        entity.speed += effect.bonus * multiplier;
                        entity.movement = entity.speed;
                        break;
                        
                    case 'advantage':
                        // Track for later use in rolls
                        if (!entity.advantages) entity.advantages = {};
                        entity.advantages[effect.skill] = apply;
                        break;
                }
            },
            
            // Use Item
            useItem(user, item, target = null) {
                if (user.id === target.id && !item.healing) {
                    this.addLog('Cannot target self with this item!', 'info');
                    return;
                }
                
                target = target || user;
                
                if (item.healing) {
                    const healing = this.rollDice(item.healing);
                    target.hp = Math.min(target.maxHp, target.hp + healing);
                    this.addLog(`${user.name} uses ${item.name} on ${target.name}, healing ${healing} HP!`, 'heal');
                    this.createFloatingText(`+${healing}`, target.x, target.y - 30, '#00ff00');
                    this.playSpecificSound(item.sound);
                } else if (item.effect) {
                    this.applyItemEffect(target, item.effect);
                    this.addLog(`${user.name} uses ${item.name} on ${target.name}!`, 'info');
                    this.showEventPopup('Action', `${user.name} uses ${item.name} on ${target.name}!`);
                    this.playSpecificSound(item.sound);
                } else if (item.spell) {
                    // Scroll
                    const spell = this.library.spells.find(s => s.name === item.spell);
                    if (spell) {
                        this.castSpell(user, target, spell);
                    }
                }
                
                // Remove if consumable
                if (item.consumable) {
                    const idx = user.inventory.findIndex(i => i === item);
                    if (idx > -1) user.inventory.splice(idx, 1);
                }
                
                this.render();
            },
            
            // Apply Item Effect
            applyItemEffect(target, effect) {
                switch (effect.type) {
                    case 'condition':
                        this.addCondition(target, effect.condition);
                        if (effect.duration) {
                            // Track for later removal
                            setTimeout(() => this.removeCondition(target, effect.condition), effect.duration * 60000);
                        }
                        break;
                        
                    case 'buff':
                        if (!target.buffs) target.buffs = [];
                        target.buffs.push({effects: effect.effects, duration: effect.duration});
                        break;
                        
                    case 'advantage':
                        if (!target.advantages) target.advantages = {};
                        effect.saves.forEach(save => {
                            target.advantages[save] = true;
                        });
                        if (effect.duration) {
                            setTimeout(() => {
                                effect.saves.forEach(save => {
                                    target.advantages[save] = false;
                                });
                            }, effect.duration * 60000);
                        }
                        break;
                }
            },
            
            // Render entities and board
            render() {
                const canvas = document.getElementById('boardCanvas');
                if (!canvas) return;
                
                canvas.innerHTML = '';
                
                // Draw movement range for current turn
                if (this.showMovementRange && this.turnOrder.length > 0 && !this.editMode) {
                    const current = this.turnOrder[this.currentTurn];
                    if (current && current.movement > 0) {
                        const range = document.createElement('div');
                        range.className = 'movement-range';
                        const radius = current.movement * 5; // 5 pixels per foot
                        range.style.width = radius * 2 + 'px';
                        range.style.height = radius * 2 + 'px';
                        range.style.left = (current.x - radius) + 'px';
                        range.style.top = (current.y - radius) + 'px';
                        canvas.appendChild(range);
                    }
                }
                
                // Render entities
                this.entities.forEach(entity => {
                    const elem = document.createElement('div');
                    elem.className = 'entity';
                    elem.dataset.id = entity.id;
                    
                    // Add type-specific classes
                    if (entity.type === 'npc') {
                        elem.classList.add('npc');
                    } else if (entity.type === 'effect') {
                        elem.className = 'effect-entity';
                        elem.style.left = `${entity.x - 35}px`; // Center
                        elem.style.top = `${entity.y - 35}px`;
                        elem.style.width = '70px';
                        elem.style.height = '70px';
                    }
                    
                    // Add condition classes
                    if (entity.conditions && entity.conditions.includes('dead')) {
                        elem.classList.add('dead');
                    } else if (entity.conditions && entity.conditions.includes('unconscious')) {
                        elem.classList.add('unconscious');
                    }
                    
                    if (this.selectedEntity && this.selectedEntity.id === entity.id) {
                        elem.classList.add('selected');
                    }
                    
                    if (this.targetingMode && entity.id !== this.targetingMode.source.id) {
                        elem.classList.add('valid-target');
                    }
                    
                    // Apply scaling
                    const scale = entity.scale || 1.0;
                    const size = 70 * scale;
                    elem.style.width = size + 'px';
                    elem.style.height = size + 'px';
                    elem.style.left = (entity.x - size/2) + 'px';
                    elem.style.top = (entity.y - size/2) + 'px';
                    
                    const borderColor = entity.type === 'player' ? '#60a5fa' : 
                                      entity.type === 'npc' ? '#f59e0b' :
                                      entity.type === 'monster' ? '#ef4444' : '#fbbf24';
                    
                    let content = '';
                    if (entity.image) {
                        content = `<img src="${entity.image}" class="entity-image" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                         <span class="entity-content" style="display:none;">${entity.name[0]}</span>`;
                    } else {
                        content = `<span class="entity-content">${entity.name[0]}</span>`;
                    }
                    
                    let hpBar = '';
                    if (entity.type !== 'item' && entity.type !== 'container' && entity.type !== 'effect') {
                        const hpPercent = entity.hp / entity.maxHp * 100;
                        const hpClass = hpPercent > 75 ? 'high' : hpPercent > 25 ? 'medium' : 'low';
                        hpBar = `
                            <div class="hp-bar">
                                <div class="hp-fill ${hpClass}" style="width: ${hpPercent}%"></div>
                            </div>
                        `;
                    }
                    
                    let deathSaves = '';
                    if (entity.hp === 0 && (entity.type === 'player' || entity.type === 'npc') && (!entity.conditions || !entity.conditions.includes('dead'))) {
                        deathSaves = '<div class="death-saves-indicator">';
                        for (let i = 0; i < 3; i++) {
                            deathSaves += `<div class="death-save-dot ${i < entity.deathSaves.successes ? 'success' : ''}"></div>`;
                        }
                        for (let i = 0; i < 3; i++) {
                            deathSaves += `<div class="death-save-dot ${i < entity.deathSaves.failures ? 'failure' : ''}"></div>`;
                        }
                        deathSaves += '</div>';
                    }
                    
                    let conditionsBadge = '';
                    if (entity.conditions && entity.conditions.length > 0 && !entity.conditions.includes('dead')) {
                        conditionsBadge = `<div class="conditions-badge">${entity.conditions.length}</div>`;
                    }
                    
                    // Status Effect Indicators
                    let statusIndicator = '';
                    if (entity.conditions && entity.conditions.length > 0) {
                        if (entity.conditions.includes('dead')) {
                            statusIndicator = '<div class="status-indicator death">üíÄ</div>';
                        } else if (entity.conditions.includes('unconscious') || entity.conditions.includes('prone')) {
                            statusIndicator = '<div class="status-indicator unconscious">‚ùå</div>';
                        } else {
                            // Show number of active conditions with turns remaining
                            const conditionsWithTurns = entity.conditions.filter(c => 
                                entity.conditionTurns && entity.conditionTurns[c] > 0
                            );
                            if (conditionsWithTurns.length > 0) {
                                const maxTurns = Math.max(...conditionsWithTurns.map(c => entity.conditionTurns[c]));
                                statusIndicator = `<div class="status-indicator condition">${maxTurns}</div>`;
                            }
                        }
                    }
                    
                    let nameDisplay = entity.name;
                    if (entity.type === 'player' || entity.type === 'monster' || entity.type === 'npc') {
                        nameDisplay += ` (${entity.hp}/${entity.maxHp})`;
                    } else if (entity.type === 'container') {
                        if (!entity.inventory || entity.inventory.length === 0) {
                            nameDisplay = 'Empty Chest';
                        } else {
                            nameDisplay += ` (${entity.inventory.length} items)`;
                        }
                    } else if (entity.type === 'item') {
                        // Items just show their name, no additional info
                        nameDisplay = entity.name;
                        if (entity.rarity && entity.rarity !== 'common') {
                            nameDisplay += ` (${entity.rarity})`;
                        }
                    } else if (entity.type === 'effect') {
                        elem.innerHTML = `<img src="${entity.url}" class="effect-img">`;
                        if (!entity.loop && entity.playOnce) {
                            setTimeout(() => this.removeEntity(entity.id), entity.duration || 1000);
                        }
                        return;
                    }
                    
                    elem.innerHTML = `
                        <div class="entity-circle" style="background: ${entity.color}; border-color: ${borderColor};">
                            ${content}
                            ${hpBar}
                            <div class="entity-name">${nameDisplay}</div>
                            ${deathSaves}
                            ${conditionsBadge}
                            ${statusIndicator}
                        </div>
                    `;
                    
                    elem.addEventListener('click', () => this.selectEntity(entity));
                    elem.draggable = true;
                    elem.addEventListener('dragstart', (e) => this.handleDragStart(e, entity));
                    elem.addEventListener('dragend', (e) => this.handleDragEnd(e, entity));
                    
                    // Add wheel event for token resizing in edit mode
                    elem.addEventListener('wheel', (e) => {
                        if (this.editMode && this.selectedEntity && this.selectedEntity.id === entity.id) {
                            e.preventDefault();
                            const scaleChange = e.deltaY > 0 ? -0.1 : 0.1;
                            entity.scale = Math.max(0.5, Math.min(2.0, (entity.scale || 1.0) + scaleChange));
                            this.render();
                        }
                    });
                    
                    canvas.appendChild(elem);
                });
            },
            
            // Toggle Edit Mode
            toggleEditMode() {
                this.editMode = !this.editMode;
                const btn = document.getElementById('editToggle');
                btn.classList.toggle('active', this.editMode);
                this.addLog(`Edit mode ${this.editMode ? 'enabled' : 'disabled'}`, 'info');
                this.render();
            },
            
            // Drag Arrow Functions
            createDragArrow(startX, startY, endX, endY) {
                if (this.dragArrow) {
                    this.dragArrow.remove();
                }
                
                const angle = Math.atan2(endY - startY, endX - startX);
                const distance = Math.hypot(endX - startX, endY - startY);
                
                this.dragArrow = document.createElement('div');
                this.dragArrow.className = 'drag-arrow';
                this.dragArrow.style.left = `${startX}px`;
                this.dragArrow.style.top = `${startY}px`;
                this.dragArrow.style.width = `${distance}px`;
                this.dragArrow.style.transform = `rotate(${angle}rad)`;
                
                document.getElementById('boardCanvas').appendChild(this.dragArrow);
            },
            
            removeDragArrow() {
                if (this.dragArrow) {
                    this.dragArrow.remove();
                    this.dragArrow = null;
                }
            },
            
            createPersistentArrow(startX, startY, endX, endY) {
                if (this.persistentArrow) {
                    this.persistentArrow.remove();
                }
                
                const angle = Math.atan2(endY - startY, endX - startX);
                const distance = Math.hypot(endX - startX, endY - startY);
                
                this.persistentArrow = document.createElement('div');
                this.persistentArrow.className = 'persistent-arrow';
                this.persistentArrow.style.left = `${startX}px`;
                this.persistentArrow.style.top = `${startY}px`;
                this.persistentArrow.style.width = `${distance}px`;
                this.persistentArrow.style.transform = `rotate(${angle}rad)`;
                
                document.getElementById('boardCanvas').appendChild(this.persistentArrow);
            },
            
            removePersistentArrow() {
                if (this.persistentArrow) {
                    this.persistentArrow.remove();
                    this.persistentArrow = null;
                }
            },
            
            // Drag handling
            handleDragStart(e, entity) {
                this.draggingEntity = entity;
                this.dragStartPos = {x: entity.x, y: entity.y};
                e.dataTransfer.effectAllowed = 'move';
                
                // Start tracking mouse for drag arrow
                document.addEventListener('mousemove', this.updateDragArrow.bind(this));
            },
            
            updateDragArrow(e) {
                if (!this.draggingEntity || !this.dragStartPos) return;
                
                const rect = document.getElementById('gameBoard').getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                this.createDragArrow(this.dragStartPos.x, this.dragStartPos.y, mouseX, mouseY);
            },
            
            handleDragEnd(e, entity) {
                this.removeDragArrow();
                document.removeEventListener('mousemove', this.updateDragArrow.bind(this));
                
                this.draggingEntity = null;
                this.dragStartPos = null;
            },
            
            // Enhanced Token Interaction System (Fixed inventory drag issue)
            handleTokenInteraction(draggingEntity, target, dropX, dropY) {
                let actionPerformed = false;
                
                // Item dragged onto Player/NPC - Add to inventory (NEW FIX)
                if (draggingEntity.type === 'item' && (target.type === 'player' || target.type === 'npc')) {
                    if (!target.inventory) target.inventory = [];
                    target.inventory.push({...draggingEntity});
                    this.removeEntity(draggingEntity.id);
                    this.addLog(`${target.name} picks up ${draggingEntity.name}!`, 'info');
                    actionPerformed = true;
                }
                
                // Player Token Interactions
                else if (draggingEntity.type === 'player' || draggingEntity.type === 'npc') {
                    
                    // Token placed on Item - Add to inventory 
                    if (target.type === 'item') {
                        if (!draggingEntity.inventory) draggingEntity.inventory = [];
                        draggingEntity.inventory.push({...target});
                        this.removeEntity(target.id);
                        this.addLog(`${draggingEntity.name} picks up ${target.name}!`, 'info');
                        actionPerformed = true;
                    }
                    
                    // Token placed on Enemy - Attack
                    else if (target.type === 'monster' || 
                            (target.type === 'player' && draggingEntity.type === 'npc') ||
                            (target.type === 'npc' && draggingEntity.type === 'player')) {
                        if (draggingEntity.attacks && draggingEntity.attacks.length > 0) {
                            this.performAttack(draggingEntity, target, draggingEntity.attacks[0]);
                            actionPerformed = true;
                        } else {
                            // Create basic unarmed attack if no weapons
                            const unarmedAttack = {
                                name: 'Unarmed Strike',
                                toHit: this.getAbilityModifier(draggingEntity.str) + draggingEntity.proficiencyBonus,
                                damage: '1+' + this.getAbilityModifier(draggingEntity.str),
                                damageType: 'bludgeoning',
                                range: 5
                            };
                            this.performAttack(draggingEntity, target, unarmedAttack);
                            actionPerformed = true;
                        }
                    }
                    
                    // Token placed on Chest - Open and spill contents
                    else if (target.type === 'container') {
                        if (target.isMimic || (target.name === 'Mimic')) {
                            // Reveal mimic and attack
                            target.name = 'Mimic';
                            target.type = 'monster';
                            const mimicTemplate = this.library.monsters.find(m => m.name === 'Mimic');
                            if (mimicTemplate) {
                                // Store the original inventory before applying template
                                const originalInventory = target.inventory || [];
                                Object.assign(target, JSON.parse(JSON.stringify(mimicTemplate)));
                                target.id = target.id; // Keep original ID
                                target.x = target.x;   // Keep position
                                target.y = target.y;
                                target.inventory = originalInventory; // Restore chest inventory for when mimic dies
                            }
                            this.addLog(`${target.name} reveals itself as a Mimic!`, 'info');
                            const mimicAttack = target.attacks[0] || {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing'};
                            this.performAttack(target, draggingEntity, mimicAttack);
                            this.playSound('attack');
                        } else {
                            // Spill chest contents around the chest
                            if (target.inventory && target.inventory.length > 0) {
                                target.inventory.forEach((item, index) => {
                                    const angle = (index / target.inventory.length) * Math.PI * 2;
                                    const distance = 80 + (index * 20); // Spread items in a circle
                                    const newX = target.x + Math.cos(angle) * distance;
                                    const newY = target.y + Math.sin(angle) * distance;
                                    
                                    const newItem = this.createEntity('item', item.name, newX, newY);
                                    Object.assign(newItem, item);
                                    newItem.id = this.nextId++;
                                    newItem.x = newX;
                                    newItem.y = newY;
                                    this.entities.push(newItem);
                                });
                                this.addLog(`${draggingEntity.name} opens the chest! ${target.inventory.length} items spill out.`, 'info');
                                target.inventory = []; // Empty the chest
                                
                                // Update chest color to grey since it's now empty
                                target.color = '#6b7280';
                            } else {
                                this.addLog(`${draggingEntity.name} opens the chest. It's empty.`, 'info');
                            }
                            this.playSound('open');
                        }
                        actionPerformed = true;
                    }
                }
                
                // Item Token Interactions
                else if (draggingEntity.type === 'item') {
                    
                    // Item placed on Chest - Add to chest inventory
                    if (target.type === 'container' && !target.isMimic) {
                        if (!target.inventory) target.inventory = [];
                        target.inventory.push({...draggingEntity});
                        this.removeEntity(draggingEntity.id);
                        this.addLog(`${draggingEntity.name} added to chest.`, 'info');
                        
                        // Update chest color to gold since it now has items
                        target.color = '#fbbf24';
                        actionPerformed = true;
                    }
                }
                
                return actionPerformed;
            },
            
            // Setup event listeners
            setupEventListeners() {
                const canvas = document.getElementById('boardCanvas');
                const gameBoard = document.getElementById('gameBoard');
                
                canvas.addEventListener('dragover', e => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                
                canvas.addEventListener('drop', e => {
                    e.preventDefault();
                    if (!this.draggingEntity) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Create persistent arrow from start to drop pos
                    this.createPersistentArrow(this.dragStartPos.x, this.dragStartPos.y, x, y);
                    
                    // Check for target entity
                    const target = this.entities.find(ent => 
                        ent.id !== this.draggingEntity.id && 
                        Math.abs(ent.x - x) < 40 && 
                        Math.abs(ent.y - y) < 40
                    );
                    
                    let actionPerformed = false;
                    
                    if (this.targetingMode && this.draggingEntity.id === this.targetingMode.source.id && target) {
                        // Execute targeted action
                        this.executeTargetedAction(target);
                        actionPerformed = true;
                    } else if (target) {
                        // Use enhanced token interaction system
                        actionPerformed = this.handleTokenInteraction(this.draggingEntity, target, x, y);
                    } else {
                        // Normal movement
                        if (this.editMode) {
                            // Free movement in edit mode - no restrictions
                            this.draggingEntity.x = x;
                            this.draggingEntity.y = y;
                            this.addLog(`${this.draggingEntity.name} moved freely in edit mode.`, 'info');
                            actionPerformed = true;
                        } else {
                            const distance = Math.hypot(x - this.dragStartPos.x, y - this.dragStartPos.y);
                            const movementCost = Math.floor(distance / 5);
                            
                            if (this.enforceTurns && this.turnOrder[this.currentTurn]?.id !== this.draggingEntity.id) {
                                this.addLog('Not your turn!', 'info');
                                return;
                            }
                            
                            if (this.draggingEntity.movement !== undefined && movementCost <= this.draggingEntity.movement) {
                                this.draggingEntity.x = x;
                                this.draggingEntity.y = y;
                                this.draggingEntity.movement -= movementCost;
                                this.updateTurnOrder();
                                this.addLog(`${this.draggingEntity.name} moves ${movementCost}ft.`, 'info');
                                actionPerformed = true;
                            } else if (this.draggingEntity.movement === undefined) {
                                // Items and containers can always move
                                this.draggingEntity.x = x;
                                this.draggingEntity.y = y;
                                actionPerformed = true;
                            } else {
                                this.addLog(`Not enough movement! (${movementCost}ft needed, ${this.draggingEntity.movement}ft remaining)`, 'info');
                            }
                        }
                    }
                    
                    // Remove persistent arrow after action
                    setTimeout(() => {
                        this.removePersistentArrow();
                    }, actionPerformed ? 1500 : 500);
                    
                    this.render();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', e => {
                    if (e.key === 'Enter') this.nextTurn();
                    if (e.key === 'Delete' && this.selectedEntity) this.removeEntity(this.selectedEntity.id);
                });
            },
            
            // Targeting system
            startTargeting(source, action) {
                this.targetingMode = {source, action};
                
                document.querySelectorAll('.action-menu, .details-panel').forEach(el => el.remove());
                
                const indicator = document.createElement('div');
                indicator.className = 'targeting-indicator';
                indicator.id = 'targetingIndicator';
                indicator.innerHTML = `
                    <div class="targeting-text">Select target for ${action.name}</div>
                    <button class="cancel-btn" onclick="game.cancelTargeting()">Cancel</button>
                `;
                document.getElementById('gameBoard').appendChild(indicator);
                
                this.render();
            },
            
            executeTargetedAction(target) {
                if (!this.targetingMode) return;
                
                if (this.targetingMode.source.id === target.id) {
                    this.addLog('Cannot target self!', 'info');
                    return;
                }
                
                const {source, action} = this.targetingMode;
                
                if (action.level !== undefined) {
                    // It's a spell
                    this.castSpell(source, target, action);
                } else if (action.toHit !== undefined) {
                    // It's an attack
                    this.performAttack(source, target, action);
                } else if (action.healing || action.effect) {
                    // It's an item
                    this.useItem(source, action, target);
                } else if (action.name === 'Shove') {
                    this.performShove(source, target, action);
                } else if (action.name === 'Hide') {
                    this.performHide(source);
                } else if (action.name === 'Disengage') {
                    this.performDisengage(source);
                } else if (action.name === 'Dash') {
                    this.performDash(source);
                } else if (action.name === 'Help') {
                    this.performHelp(source, target);
                } else if (action.name === 'Ready') {
                    this.performReady(source);
                }
                
                this.cancelTargeting();
            },
            
            cancelTargeting() {
                this.targetingMode = null;
                document.getElementById('targetingIndicator')?.remove();
                this.render();
            },
            
            // UI Functions
            selectEntity(entity) {
                if (this.targetingMode) {
                    this.executeTargetedAction(entity);
                    return;
                }
                
                // Only trigger token interactions when there's already a selected entity AND they're different
                if (this.selectedEntity && this.selectedEntity.id !== entity.id) {
                    // Only trigger interactions if we're dragging or the entities are compatible for interaction
                    if (this.draggingEntity || this.shouldInteractOnClick(this.selectedEntity, entity)) {
                        const actionPerformed = this.handleTokenInteraction(this.selectedEntity, entity, entity.x, entity.y);
                        if (actionPerformed) {
                            this.selectedEntity = null; // Clear selection after interaction
                            this.render();
                            return;
                        }
                    }
                }
                
                this.selectedEntity = entity;
                
                // Remove any existing panels first
                document.querySelectorAll('.details-panel, .action-menu').forEach(el => el.remove());
                
                this.render();
                
                // Show appropriate panel based on entity type
                if (entity.type === 'item' || entity.type === 'container') {
                    this.showItemDetailsPanel(entity);
                    if (entity.type === 'item') {
                        this.showItemActionMenu(entity);
                    }
                } else {
                    this.showDetailsPanel(entity);
                    
                    if ((entity.type === 'player' || entity.type === 'monster' || entity.type === 'npc') && entity.hp > 0) {
                        this.showActionMenu(entity);
                    }
                }
            },
            
            // Helper function to determine if entities should interact on click
            shouldInteractOnClick(selectedEntity, targetEntity) {
                // Players/NPCs clicking on items should pick them up
                if ((selectedEntity.type === 'player' || selectedEntity.type === 'npc') && targetEntity.type === 'item') {
                    return true;
                }
                
                // Items clicking on players/NPCs should be picked up
                if (selectedEntity.type === 'item' && (targetEntity.type === 'player' || targetEntity.type === 'npc')) {
                    return true;
                }
                
                // Items clicking on containers
                if (selectedEntity.type === 'item' && targetEntity.type === 'container') {
                    return true;
                }
                
                // Players/NPCs clicking on containers
                if ((selectedEntity.type === 'player' || selectedEntity.type === 'npc') && targetEntity.type === 'container') {
                    return true;
                }
                
                return false;
            },
            
            showItemDetailsPanel(entity) {
                document.querySelectorAll('.details-panel').forEach(el => el.remove());
                
                const panel = document.createElement('div');
                panel.className = 'details-panel';
                
                let html = `
                    <button class="close-btn" onclick="this.parentElement.remove()">‚úï</button>
                    <h3 style="color: #fbbf24; margin-bottom: 15px;">${entity.name}</h3>
                    
                    <div class="stat-row">
                        <span>Name:</span>
                        <input type="text" value="${entity.name}" onchange="game.updateEntity(${entity.id}, 'name', this.value)" class="stat-input" style="width: 120px;">
                    </div>
                    
                    <div class="stat-row">
                        <span>Type:</span>
                        <span>${entity.type === 'container' ? 'Container' : 'Item'}</span>
                    </div>
                    
                    <div class="stat-row">
                        <span>Description:</span>
                        <input type="text" value="${entity.description || ''}" onchange="game.updateEntity(${entity.id}, 'description', this.value)" class="stat-input" style="width: 200px;">
                    </div>
                    
                    <div class="stat-row">
                        <span>Value (gp):</span>
                        <input type="number" value="${entity.value || 0}" onchange="game.updateEntity(${entity.id}, 'value', this.value)" class="stat-input">
                    </div>
                    
                    <div class="stat-row">
                        <span>Weight (lbs):</span>
                        <input type="number" step="0.1" value="${entity.weight || 0}" onchange="game.updateEntity(${entity.id}, 'weight', this.value)" class="stat-input">
                    </div>
                    
                    <div class="stat-row">
                        <span>Consumable:</span>
                        <input type="checkbox" ${entity.consumable ? 'checked' : ''} onchange="game.updateEntity(${entity.id}, 'consumable', this.checked)">
                    </div>
                    
                    <div class="stat-row">
                        <span>Healing:</span>
                        <input type="text" value="${entity.healing || ''}" onchange="game.updateEntity(${entity.id}, 'healing', this.value)" class="stat-input" placeholder="e.g., 2d4+2">
                    </div>
                    
                    <div class="stat-row">
                        <span>Damage:</span>
                        <input type="text" value="${entity.damage || ''}" onchange="game.updateEntity(${entity.id}, 'damage', this.value)" class="stat-input" placeholder="e.g., 1d8+2">
                    </div>
                    
                    <div class="stat-row">
                        <span>Damage Type:</span>
                        <input type="text" value="${entity.damageType || ''}" onchange="game.updateEntity(${entity.id}, 'damageType', this.value)" class="stat-input" placeholder="e.g., slashing">
                    </div>
                    
                    <div class="stat-row">
                        <span>AC Bonus:</span>
                        <input type="number" value="${entity.ac || 0}" onchange="game.updateEntity(${entity.id}, 'ac', this.value)" class="stat-input">
                    </div>
                    
                    <div class="stat-row">
                        <span>Rarity:</span>
                        <select onchange="game.updateEntity(${entity.id}, 'rarity', this.value)" class="stat-input">
                            <option value="common" ${entity.rarity === 'common' ? 'selected' : ''}>Common</option>
                            <option value="uncommon" ${entity.rarity === 'uncommon' ? 'selected' : ''}>Uncommon</option>
                            <option value="rare" ${entity.rarity === 'rare' ? 'selected' : ''}>Rare</option>
                            <option value="very rare" ${entity.rarity === 'very rare' ? 'selected' : ''}>Very Rare</option>
                            <option value="legendary" ${entity.rarity === 'legendary' ? 'selected' : ''}>Legendary</option>
                            <option value="artifact" ${entity.rarity === 'artifact' ? 'selected' : ''}>Artifact</option>
                        </select>
                    </div>
                    
                    <div class="stat-row">
                        <span>Sound:</span>
                        <input type="file" accept=".mp3" onchange="game.setItemSound(${entity.id}, this.files[0])">
                    </div>
                `;
                
                if (entity.type === 'container') {
                    html += `
                        <div class="stat-row">
                            <span>Is Mimic:</span>
                            <input type="checkbox" ${entity.isMimic ? 'checked' : ''} onchange="game.updateEntity(${entity.id}, 'isMimic', this.checked)">
                        </div>
                        
                        <h4 style="margin-top: 15px;">Container Contents</h4>
                        <div style="margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
                            ${entity.inventory && entity.inventory.length > 0 ? 
                                entity.inventory.map(item => `
                                    <div style="padding: 4px; background: rgba(0,0,0,0.2); margin: 2px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;">
                                        <span>${item.name}</span>
                                        <button onclick="game.removeItemFromContainer(${entity.id}, '${item.name}')" style="background: #ef4444; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer;">Remove</button>
                                    </div>
                                `).join('') : 
                                '<p style="color: #9ca3af; text-align: center; padding: 10px;">Empty</p>'
                            }
                        </div>
                    `;
                }
                
                html += `
                    <div class="stat-row">
                        <span>Image URL:</span>
                        <input type="text" value="${entity.image || ''}" onchange="game.updateEntity(${entity.id}, 'image', this.value)" class="stat-input" style="width: 200px;">
                    </div>
                    
                    <button class="btn btn-danger btn-small" onclick="game.removeEntity(${entity.id})">Remove</button>
                    <button class="btn btn-success btn-small" onclick="game.saveToLibrary(${entity.id})">Save to Library</button>
                `;
                
                panel.innerHTML = html;
                document.getElementById('gameBoard').appendChild(panel);
            },
            
            setItemSound(id, file) {
                const entity = this.getEntity(id);
                if (entity && file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        entity.sound = e.target.result;
                        this.render();
                    };
                    reader.readAsDataURL(file);
                }
            },
            
            showItemActionMenu(entity) {
                document.querySelectorAll('.action-menu').forEach(el => el.remove());
                
                const elem = document.querySelector(`[data-id="${entity.id}"]`);
                if (!elem) return;
                
                const menu = document.createElement('div');
                menu.className = 'action-menu';
                
                let html = `<h4 style="color: #fbbf24;">üì¶ ${entity.name} Actions</h4>`;
                
                if (entity.type === 'item') {
                    html += '<div class="action-section"><div class="action-section-title">Item Actions</div>';
                    
                    if (entity.healing) {
                        html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), {name: 'Use ${entity.name}', healing: '${entity.healing}', consumable: ${entity.consumable}})">
                            üíä Use for Healing (${entity.healing})
                        </button>`;
                    }
                    
                    if (entity.damage) {
                        html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), {name: 'Attack with ${entity.name}', damage: '${entity.damage}', damageType: '${entity.damageType || 'bludgeoning'}'})">
                            ‚öîÔ∏è Attack with Item (${entity.damage} ${entity.damageType || 'bludgeoning'})
                        </button>`;
                    }
                    
                    html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), {name: 'Give ${entity.name}', effect: 'transfer'})">
                        ü§ù Give to Character
                    </button>`;
                    
                    html += '</div>';
                    
                    if (entity.spell) {
                        html += '<div class="action-section"><div class="action-section-title">Spell Scroll</div>';
                        html += `<button class="action-btn" onclick="game.castSpellFromItem(${entity.id})">
                            ‚ú® Cast ${entity.spell}
                        </button>`;
                        html += '</div>';
                    }
                } else if (entity.type === 'container') {
                    html += '<div class="action-section"><div class="action-section-title">Container Actions</div>';
                    html += `<button class="action-btn" onclick="game.openContainer(${entity.id})">
                        üìÇ Open Container
                    </button>`;
                    
                    if (entity.inventory && entity.inventory.length > 0) {
                        html += `<button class="action-btn" onclick="game.spillContainerContents(${entity.id})">
                            üì§ Spill Contents
                        </button>`;
                    }
                    html += '</div>';
                }
                
                menu.innerHTML = html;
                
                // Add close button
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-btn';
                closeBtn.innerHTML = '‚úï';
                closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    menu.remove();
                };
                menu.appendChild(closeBtn);
                
                elem.appendChild(menu);
            },
            
            // Item action functions
            removeItemFromContainer(containerId, itemName) {
                const container = this.getEntity(containerId);
                if (container && container.inventory) {
                    container.inventory = container.inventory.filter(item => item.name !== itemName);
                    this.addLog(`${itemName} removed from ${container.name}`, 'info');
                    this.render();
                    // Refresh the details panel
                    this.showItemDetailsPanel(container);
                }
            },
            
            openContainer(containerId) {
                const container = this.getEntity(containerId);
                if (container) {
                    this.spillContainerContents(containerId);
                }
            },
            
            spillContainerContents(containerId) {
                const container = this.getEntity(containerId);
                if (container && container.inventory && container.inventory.length > 0) {
                    container.inventory.forEach((item, index) => {
                        const angle = (index / container.inventory.length) * Math.PI * 2;
                        const distance = 80 + (index * 20);
                        const newX = container.x + Math.cos(angle) * distance;
                        const newY = container.y + Math.sin(angle) * distance;
                        
                        const newItem = this.createEntity('item', item.name, newX, newY);
                        Object.assign(newItem, item);
                        newItem.id = this.nextId++;
                        newItem.x = newX;
                        newItem.y = newY;
                        this.entities.push(newItem);
                    });
                    
                    this.addLog(`${container.name} contents spilled! ${container.inventory.length} items.`, 'info');
                    container.inventory = [];
                    container.color = '#6b7280'; // Grey for empty
                    this.playSound('open');
                    this.render();
                }
            },
            
            castSpellFromItem(itemId) {
                const item = this.getEntity(itemId);
                if (item && item.spell) {
                    const spell = this.library.spells.find(s => s.name === item.spell);
                    if (spell) {
                        // For now, just log that the spell would be cast
                        this.addLog(`${item.name} scroll activates ${spell.name}!`, 'info');
                        if (item.consumable) {
                            this.removeEntity(itemId);
                        }
                    }
                }
            },
            
            showDetailsPanel(entity) {
                // Don't show character details panel for items or containers
                if (entity.type === 'item' || entity.type === 'container') {
                    return;
                }
                
                document.querySelectorAll('.details-panel').forEach(el => el.remove());
                
                const panel = document.createElement('div');
                panel.className = 'details-panel';
                
                let html = `
                    <button class="close-btn" onclick="this.parentElement.remove()">‚úï</button>
                    <h3 style="color: #fbbf24; margin-bottom: 15px;">${entity.name}</h3>
                    <div class="stat-row">
                        <span>Name:</span>
                        <input type="text" value="${entity.name}" onchange="game.updateEntity(${entity.id}, 'name', this.value)" class="stat-input" style="width: 120px;">
                    </div>
                `;
                
                if (entity.type === 'player' || entity.type === 'npc') {
                    html += `
                        <div class="stat-row">
                            <span>Class:</span>
                            <input type="text" value="${entity.class}" onchange="game.updateEntity(${entity.id}, 'class', this.value)" class="stat-input" style="width: 80px;">
                            <span>Race:</span>
                            <input type="text" value="${entity.race}" onchange="game.updateEntity(${entity.id}, 'race', this.value)" class="stat-input" style="width: 80px;">
                        </div>
                        <div class="stat-row">
                            <span>Level:</span>
                            <input type="number" value="${entity.level}" onchange="game.updateEntity(${entity.id}, 'level', this.value)" class="stat-input">
                        </div>
                    `;
                }
                
                const strMod = this.getAbilityModifier(entity.str);
                const dexMod = this.getAbilityModifier(entity.dex);
                const conMod = this.getAbilityModifier(entity.con);
                const intMod = this.getAbilityModifier(entity.int);
                const wisMod = this.getAbilityModifier(entity.wis);
                const chaMod = this.getAbilityModifier(entity.cha);
                
                html += `
                    <div class="stat-row">
                        <span>HP:</span>
                        <div>
                            <input type="number" value="${entity.hp}" onchange="game.updateEntity(${entity.id}, 'hp', this.value)" class="stat-input">
                            / <input type="number" value="${entity.maxHp}" onchange="game.updateEntity(${entity.id}, 'maxHp', this.value)" class="stat-input">
                            ${entity.tempHp > 0 ? `(+${entity.tempHp} temp)` : ''}
                        </div>
                    </div>
                    <div class="stat-row">
                        <span>AC:</span>
                        <span>${this.calculateAC(entity)}</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <input type="number" value="${entity.speed}" onchange="game.updateEntity(${entity.id}, 'speed', this.value)" class="stat-input">ft
                    </div>
                    
                    <h4 style="margin-top: 15px;">Ability Scores</h4>
                    <div class="stat-group">
                        <div class="stat-box">
                            <div class="stat-label">STR</div>
                            <input type="number" value="${entity.str}" onchange="game.updateEntity(${entity.id}, 'str', this.value)" class="stat-input">
                            <div class="stat-mod">${strMod >= 0 ? '+' : ''}${strMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">DEX</div>
                            <input type="number" value="${entity.dex}" onchange="game.updateEntity(${entity.id}, 'dex', this.value)" class="stat-input">
                            <div class="stat-mod">${dexMod >= 0 ? '+' : ''}${dexMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">CON</div>
                            <input type="number" value="${entity.con}" onchange="game.updateEntity(${entity.id}, 'con', this.value)" class="stat-input">
                            <div class="stat-mod">${conMod >= 0 ? '+' : ''}${conMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">INT</div>
                            <input type="number" value="${entity.int}" onchange="game.updateEntity(${entity.id}, 'int', this.value)" class="stat-input">
                            <div class="stat-mod">${intMod >= 0 ? '+' : ''}${intMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">WIS</div>
                            <input type="number" value="${entity.wis}" onchange="game.updateEntity(${entity.id}, 'wis', this.value)" class="stat-input">
                            <div class="stat-mod">${wisMod >= 0 ? '+' : ''}${wisMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">CHA</div>
                            <input type="number" value="${entity.cha}" onchange="game.updateEntity(${entity.id}, 'cha', this.value)" class="stat-input">
                            <div class="stat-mod">${chaMod >= 0 ? '+' : ''}${chaMod}</div>
                        </div>
                    </div>
                    
                    <h4 style="margin-top: 15px;">Conditions</h4>
                    <div style="margin-bottom: 10px;">
                        ${entity.conditions && entity.conditions.length > 0 ? 
                            entity.conditions.map(cond => `
                                <span style="display: inline-block; background: rgba(139, 92, 246, 0.2); padding: 2px 8px; border-radius: 4px; margin: 2px;">
                                    ${cond}${entity.conditionTurns && entity.conditionTurns[cond] ? ` (${entity.conditionTurns[cond]})` : ''}
                                    <button onclick="game.removeCondition(game.getEntity(${entity.id}), '${cond}')" style="background: none; border: none; color: #ef4444; cursor: pointer;">‚úï</button>
                                </span>
                            `).join('') : 
                            'None'
                        }
                    </div>
                    
                    ${entity.type === 'player' || entity.type === 'npc' ? `
                        <h4>Spell Slots</h4>
                        <div class="stat-group">
                            ${[1,2,3].map(level => `
                                <div class="stat-box">
                                    <div class="stat-label">Lvl ${level}</div>
                                    <div>${entity.spellSlotsUsed[level] || 0}/${entity.spellSlots[level] || 0}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div class="stat-row">
                        <span>Image URL:</span>
                        <input type="text" value="${entity.image}" onchange="game.updateEntity(${entity.id}, 'image', this.value)" class="stat-input" style="width: 200px;">
                    </div>
                    
                    <button class="btn btn-primary btn-small" onclick="game.openSpellManager(${entity.id})">Manage Spells</button>
                    <button class="btn btn-primary btn-small" onclick="game.openInventoryManager(${entity.id})">Manage Inventory</button>
                    
                    <button class="btn btn-danger btn-small" onclick="game.removeEntity(${entity.id})">Remove</button>
                    <button class="btn btn-success btn-small" onclick="game.saveToLibrary(${entity.id})">Save to Library</button>
                `;
                
                panel.innerHTML = html;
                document.getElementById('gameBoard').appendChild(panel);
            },
            
            showActionMenu(entity) {
                document.querySelectorAll('.action-menu').forEach(el => el.remove());
                
                const elem = document.querySelector(`[data-id="${entity.id}"]`);
                if (!elem) return;
                
                const menu = document.createElement('div');
                menu.className = 'action-menu';
                
                let html = `<h4 style="color: #fbbf24;">‚≠ê Actions for ${entity.name}</h4>
                           <p style="font-size: 11px; color: #9ca3af; margin: 5px 0;">Click an action, then click target</p>`;
                
                // Attacks
                if (entity.attacks && entity.attacks.length > 0) {
                    html += '<div class="action-section"><div class="action-section-title">Attacks</div>';
                    entity.attacks.forEach((attack, index) => {
                        const disabled = entity.actionUsed && !attack.bonusAction ? 'disabled' : '';
                        const range = attack.range || 5;
                        html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).attacks[${index}])">
                            ‚öîÔ∏è ${attack.name} (+${attack.toHit}, ${attack.damage}) [${range}ft]
                        </button>`;
                    });
                    html += '</div>';
                }
                
                // Spells
                if (entity.spells && entity.spells.length > 0) {
                    html += '<div class="action-section"><div class="action-section-title">Spells</div>';
                    entity.spells.forEach((spell, index) => {
                        const canCast = spell.level === 0 || 
                                       (entity.spellSlots && entity.spellSlots[spell.level] > entity.spellSlotsUsed[spell.level]);
                        const disabled = !canCast || 
                                       (spell.castingTime === 'action' && entity.actionUsed) ||
                                       (spell.castingTime === 'bonus action' && entity.bonusActionUsed) ? 'disabled' : '';
                        
                        const slotInfo = spell.level > 0 ? 
                            `<span class="spell-slot-info">${entity.spellSlotsUsed[spell.level]}/${entity.spellSlots[spell.level]}</span>` : '';
                        
                        html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).spells[${index}])">
                            ‚ú® ${spell.name} (Lvl ${spell.level}) ${slotInfo}
                        </button>`;
                    });
                    html += '</div>';
                }
                
                // Items
                if (entity.inventory && entity.inventory.length > 0) {
                    const usableItems = entity.inventory.filter(item => item.healing || item.effect || item.spell);
                    if (usableItems.length > 0) {
                        html += '<div class="action-section"><div class="action-section-title">Items</div>';
                        usableItems.forEach((item, index) => {
                            const actualIndex = entity.inventory.indexOf(item);
                            html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).inventory[${actualIndex}])">
                                üß™ ${item.name}
                            </button>`;
                        });
                        html += '</div>';
                    }
                }
                
                // Abilities (non-targeting ones)
                if (entity.abilities && entity.abilities.length > 0) {
                    const activeAbilities = entity.abilities.filter(a => a.actionType !== 'passive');
                    if (activeAbilities.length > 0) {
                        html += '<div class="action-section"><div class="action-section-title">Special Abilities</div>';
                        activeAbilities.forEach((ability, index) => {
                            const disabled = (ability.actionType === 'action' && entity.actionUsed) ||
                                           (ability.actionType === 'bonus' && entity.bonusActionUsed) ||
                                           (ability.actionType === 'reaction' && entity.reactionUsed) ? 'disabled' : '';
                            html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).abilities[${index}])" title="${ability.description}">
                                üí´ ${ability.name}
                            </button>`;
                        });
                        html += '</div>';
                    }
                }
                
                menu.innerHTML = html;
                
                // Add close button after menu is created
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-btn';
                closeBtn.innerHTML = '‚úï';
                closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    menu.remove();
                };
                menu.appendChild(closeBtn);
                
                elem.appendChild(menu);
            },
            
            // Managers
            openSpellManager(entityId) {
                const entity = this.getEntity(entityId);
                if (!entity) return;
                
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                let html = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                        <h2>‚ú® Manage Spells for ${entity.name}</h2>
                        
                        <h3>Current Spells</h3>
                        <div class="item-list">
                            ${entity.spells.map((s, i) => `
                                <div class="item-card">
                                    <strong>${s.name}</strong> (Level ${s.level})<br>
                                    <small>${s.description}</small><br>
                                    <input type="file" accept=".mp3" onchange="game.setSpellSound(${entityId}, ${i}, this.files[0])"><br>
                                    <input type="text" value="${s.visualEffect.url || ''}" placeholder="Visual Effect URL" onchange="game.setSpellVisual(${entityId}, ${i}, this.value, document.querySelector('#loop${i}').checked)"><br>
                                    <label><input type="checkbox" id="loop${i}" ${s.visualEffect.loop ? 'checked' : ''} onchange="game.setSpellVisual(${entityId}, ${i}, document.querySelector('#vis${i}').value, this.checked)"> Loop</label><br>
                                    <button class="btn btn-small btn-danger" onclick="game.removeSpell(${entityId}, ${i}); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openSpellManager(${entityId});">Remove</button>
                                </div>
                            `).join('')}
                        </div>
                        
                        <h3>Available Spells</h3>
                        <div class="item-list">
                            ${this.library.spells.filter(s => !entity.spells.some(es => es.name === s.name)).map(s => `
                                <div class="item-card" onclick="game.addSpell(${entityId}, '${s.name}'); this.parentElement.parentElement.parentElement.remove(); game.openSpellManager(${entityId});">
                                    <strong>${s.name}</strong> (Level ${s.level})<br>
                                    <small>${s.description}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                modal.innerHTML = html;
                document.body.appendChild(modal);
            },
            
            setSpellSound(entityId, index, file) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index] && file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        entity.spells[index].sound = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            },
            
            setSpellVisual(entityId, index, url, loop) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index]) {
                    entity.spells[index].visualEffect = {url, loop};
                }
            },
            
            openInventoryManager(entityId) {
                const entity = this.getEntity(entityId);
                if (!entity) return;
                
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                let html = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                        <h2>üéí Manage Inventory for ${entity.name}</h2>
                        
                        <h3>Equipment</h3>
                        <div class="item-list">
                            ${Object.entries(entity.equipment).map(([slot, item]) => `
                                <div class="item-card">
                                    <strong>${slot}:</strong> ${item ? item.name : 'Empty'}
                                    ${item ? `<button class="btn btn-small btn-danger" onclick="game.unequipItem(game.getEntity(${entityId}), game.getEntity(${entityId}).equipment['${slot}']); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Unequip</button>` : ''}
                                </div>
                            `).join('')}
                        </div>
                        
                        <h3>Inventory</h3>
                        <div class="item-list">
                            ${entity.inventory.map((item, i) => `
                                <div class="item-card">
                                    <strong>${item.name}</strong><br>
                                    <small>${item.description || ''}</small><br>
                                    <input type="file" accept=".mp3" onchange="game.setInventorySound(${entityId}, ${i}, this.files[0])"><br>
                                    <button class="btn btn-small btn-danger" onclick="game.removeInventoryItem(${entityId}, ${i}); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Remove</button>
                                    ${item.equipSlot ? `<button class="btn btn-small btn-primary" onclick="game.equipItem(game.getEntity(${entityId}), game.getEntity(${entityId}).inventory[${i}]); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Equip</button>` : ''}
                                </div>
                            `).join('')}
                        </div>
                        
                        <h3>Add Items</h3>
                        <div class="item-list">
                            ${[...this.library.items, ...this.library.equipment].map(item => `
                                <div class="item-card" onclick="game.addInventoryItem(${entityId}, '${item.name}'); this.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">
                                    <strong>${item.name}</strong><br>
                                    <small>${item.description || ''}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                modal.innerHTML = html;
                document.body.appendChild(modal);
            },
            
            setInventorySound(entityId, index, file) {
                const entity = this.getEntity(entityId);
                if (entity && entity.inventory[index] && file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        entity.inventory[index].sound = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            },
            
            // Helper functions for managers
            addSpell(entityId, spellName) {
                const entity = this.getEntity(entityId);
                const spell = this.library.spells.find(s => s.name === spellName);
                if (entity && spell) {
                    entity.spells.push(JSON.parse(JSON.stringify(spell)));
                    this.addLog(`${entity.name} learns ${spell.name}`, 'info');
                }
            },
            
            removeSpell(entityId, index) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index]) {
                    const spellName = entity.spells[index].name;
                    entity.spells.splice(index, 1);
                    this.addLog(`${entity.name} forgets ${spellName}`, 'info');
                }
            },
            
            addInventoryItem(entityId, itemName) {
                const entity = this.getEntity(entityId);
                const item = [...this.library.items, ...this.library.equipment].find(i => i.name === itemName);
                if (entity && item) {
                    entity.inventory.push(JSON.parse(JSON.stringify(item)));
                    this.addLog(`${entity.name} receives ${item.name}`, 'info');
                }
            },
            
            removeInventoryItem(entityId, index) {
                const entity = this.getEntity(entityId);
                if (entity && entity.inventory[index]) {
                    const itemName = entity.inventory[index].name;
                    entity.inventory.splice(index, 1);
                    this.addLog(`${entity.name} discards ${itemName}`, 'info');
                }
            },
            
            // Entity management
            getEntity(id) {
                return this.entities.find(e => e.id === id);
            },
            
            updateEntity(id, prop, value) {
                const entity = this.getEntity(id);
                if (!entity) return;
                
                const numericProps = ['hp', 'maxHp', 'ac', 'speed', 'str', 'dex', 'con', 'int', 'wis', 'cha', 'tempHp'];
                const booleanProps = ['isMimic', 'consumable'];
                
                if (numericProps.includes(prop)) {
                    entity[prop] = parseInt(value) || 0;
                } else if (booleanProps.includes(prop)) {
                    entity[prop] = value;
                } else {
                    entity[prop] = value;
                }
                
                // Recalculate AC if ability scores change
                if (['str', 'dex'].includes(prop)) {
                    entity.ac = this.calculateAC(entity);
                }
                
                this.render();
            },
            
            removeEntity(id) {
                this.entities = this.entities.filter(e => e.id !== id);
                if (this.selectedEntity && this.selectedEntity.id === id) {
                    this.selectedEntity = null;
                }
                this.updateTurnOrder();
                this.render();
                document.querySelectorAll('.details-panel, .action-menu').forEach(el => el.remove());
            },
            
            // Enhanced Add entities with better modals
            addPlayerCharacter() {
                const name = prompt('Enter character name:');
                if (!name) return;
                
                // Create modal for class and race selection
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="creation-modal">
                        <h2>üõ°Ô∏è Create Player Character</h2>
                        <div class="form-group">
                            <label class="form-label">Class:</label>
                            <select id="classSelect" class="form-select">
                                ${this.classList.map(cls => `<option value="${cls}">${cls}</option>`).join('')}
                            </select>
                            <input type="text" id="customClass" placeholder="Enter custom class name" class="custom-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Race:</label>
                            <select id="raceSelect" class="form-select">
                                ${this.raceList.map(race => `<option value="${race}">${race}</option>`).join('')}
                            </select>
                            <input type="text" id="customRace" placeholder="Enter custom race name" class="custom-input">
                        </div>
                        
                        <button class="advanced-toggle" onclick="this.nextElementSibling.classList.toggle('show')">‚öôÔ∏è Advanced Options</button>
                        <div class="advanced-options">
                            <div class="advanced-grid">
                                <div>
                                    <label class="form-label">Hit Points:</label>
                                    <input type="number" id="playerHP" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Armor Class:</label>
                                    <input type="number" id="playerAC" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Speed:</label>
                                    <input type="number" id="playerSpeed" value="30" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Strength:</label>
                                    <input type="number" id="playerStr" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Dexterity:</label>
                                    <input type="number" id="playerDex" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Constitution:</label>
                                    <input type="number" id="playerCon" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Intelligence:</label>
                                    <input type="number" id="playerInt" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Wisdom:</label>
                                    <input type="number" id="playerWis" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Charisma:</label>
                                    <input type="number" id="playerCha" value="10" class="advanced-input">
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Character Image URL:</label>
                                <input type="text" id="playerImage" placeholder="Image URL" class="advanced-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Spell Slots (Level 1):</label>
                                <input type="number" id="playerSpellSlots1" value="2" class="advanced-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Spell Slots (Level 2):</label>
                                <input type="number" id="playerSpellSlots2" value="0" class="advanced-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Spell Slots (Level 3):</label>
                                <input type="number" id="playerSpellSlots3" value="0" class="advanced-input">
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button class="btn btn-danger" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createPlayerFromModal('${name}')">Create Character</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for custom option toggles
                modal.querySelector('#classSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#customClass');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
                
                modal.querySelector('#raceSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#customRace');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
                
                document.body.appendChild(modal);
            },
            
            createPlayerFromModal(name) {
                const modal = document.querySelector('.modal-overlay');
                const classSelect = modal.querySelector('#classSelect');
                const customClass = modal.querySelector('#customClass');
                const raceSelect = modal.querySelector('#raceSelect');
                const customRace = modal.querySelector('#customRace');
                
                const selectedClass = classSelect.value === 'Custom' ? customClass.value || 'Fighter' : classSelect.value;
                const selectedRace = raceSelect.value === 'Custom' ? customRace.value || 'Human' : raceSelect.value;
                
                const entity = this.createEntity('player', name, 200 + Math.random() * 100, 200 + Math.random() * 200);
                entity.class = selectedClass;
                entity.race = selectedRace;
                
                // Apply advanced options if filled
                const hp = parseInt(modal.querySelector('#playerHP').value) || 10;
                const ac = parseInt(modal.querySelector('#playerAC').value) || 10;
                const speed = parseInt(modal.querySelector('#playerSpeed').value) || 30;
                const str = parseInt(modal.querySelector('#playerStr').value) || 10;
                const dex = parseInt(modal.querySelector('#playerDex').value) || 10;
                const con = parseInt(modal.querySelector('#playerCon').value) || 10;
                const int = parseInt(modal.querySelector('#playerInt').value) || 10;
                const wis = parseInt(modal.querySelector('#playerWis').value) || 10;
                const cha = parseInt(modal.querySelector('#playerCha').value) || 10;
                const image = modal.querySelector('#playerImage').value || '';
                const spellSlots1 = parseInt(modal.querySelector('#playerSpellSlots1').value) || 2;
                const spellSlots2 = parseInt(modal.querySelector('#playerSpellSlots2').value) || 0;
                const spellSlots3 = parseInt(modal.querySelector('#playerSpellSlots3').value) || 0;
                
                entity.hp = hp;
                entity.maxHp = hp;
                entity.ac = ac;
                entity.speed = speed;
                entity.str = str;
                entity.dex = dex;
                entity.con = con;
                entity.int = int;
                entity.wis = wis;
                entity.cha = cha;
                entity.image = image;
                entity.spellSlots[1] = spellSlots1;
                entity.spellSlots[2] = spellSlots2;
                entity.spellSlots[3] = spellSlots3;
                
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
                
                modal.remove();
            },
            
            addMonster() {
                const name = prompt('Enter monster name:', 'Goblin');
                if (!name) return;
                
                const entity = this.createEntity('monster', name, 400 + Math.random() * 200, 200 + Math.random() * 200);
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
            },
            
            addItem() {
                const name = prompt('Enter item name:', 'Healing Potion');
                if (!name) return;
                
                const entity = this.createEntity('item', name, 350 + Math.random() * 100, 350 + Math.random() * 100);
                this.entities.push(entity);
                this.render();
            },
            
            // Enhanced Add Chest function with item selection
            addChest() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                        <h2>üóÉÔ∏è Create Chest</h2>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-weight: 600;">
                                <input type="checkbox" id="mimicToggle" style="transform: scale(1.2);">
                                This chest is a Mimic
                            </label>
                        </div>
                        
                        <h3>Select Items for Chest</h3>
                        <div style="margin-bottom: 15px;">
                            <input type="text" id="chestItemSearch" placeholder="Search items..." class="search-bar" onkeyup="game.filterChestItems(this.value)">
                        </div>
                        
                        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #374151; border-radius: 8px; padding: 10px; background: rgba(0,0,0,0.3);">
                            <div id="chestItemsList">
                                ${[...this.library.items, ...this.library.equipment].map((item, index) => `
                                    <div class="chest-item-option" data-name="${item.name.toLowerCase()}">
                                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px; cursor: pointer; color: #e0e0e0;" onclick="game.toggleChestItem('${item.name}', this)">
                                            <input type="checkbox" class="chest-item-checkbox" style="transform: scale(1.1);">
                                            <span>${item.name}</span>
                                            <span style="font-size: 11px; color: #9ca3af; margin-left: auto;">${item.description ? item.description.substring(0, 50) + '...' : ''}</span>
                                        </label>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn btn-danger" onclick="this.parentElement.parentElement.parentElement.remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createChestFromModal()">Create Chest</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
            },
            
            filterChestItems(searchTerm) {
                const items = document.querySelectorAll('.chest-item-option');
                const term = searchTerm.toLowerCase();
                
                items.forEach(item => {
                    if (item.dataset.name.includes(term)) {
                        item.style.display = 'block';
                    } else {
                        item.style.display = 'none';
                    }
                });
            },
            
            toggleChestItem(itemName, labelElement) {
                const checkbox = labelElement.querySelector('input[type="checkbox"]');
                checkbox.checked = !checkbox.checked;
            },
            
            createChestFromModal() {
                const modal = document.querySelector('.modal-overlay');
                const isMimic = modal.querySelector('#mimicToggle').checked;
                const checkedItems = modal.querySelectorAll('.chest-item-checkbox:checked');
                
                const selectedItems = [];
                checkedItems.forEach(checkbox => {
                    const itemName = checkbox.parentElement.querySelector('span').textContent;
                    const item = [...this.library.items, ...this.library.equipment].find(i => i.name === itemName);
                    if (item) {
                        selectedItems.push(JSON.parse(JSON.stringify(item)));
                    }
                });
                
                const entity = this.createEntity('container', 'Chest', 350 + Math.random() * 100, 350 + Math.random() * 100);
                entity.isMimic = isMimic;
                entity.inventory = selectedItems;
                
                // Set appropriate color based on content and type
                if (isMimic) {
                    entity.color = '#8B4513'; // Brown for mimics
                } else if (selectedItems.length === 0) {
                    entity.color = '#6b7280'; // Grey for empty chests
                } else {
                    entity.color = '#fbbf24'; // Gold for filled chests
                }
                
                this.entities.push(entity);
                this.render();
                
                modal.remove();
            },
            
            // Library functions
            saveToLibrary(id) {
                const entity = this.getEntity(id);
                if (!entity) return;
                
                const copy = JSON.parse(JSON.stringify(entity));
                delete copy.id;
                delete copy.x;
                delete copy.y;
                delete copy.movement;
                delete copy.actionUsed;
                delete copy.bonusActionUsed;
                delete copy.reactionUsed;
                copy.image = entity.image || '';
                
                if (entity.type === 'player' || entity.type === 'npc') {
                    if (!this.library.players.some(p => p.name === copy.name)) {
                        this.library.players.push(copy);
                    }
                } else if (entity.type === 'monster') {
                    if (!this.library.monsters.some(m => m.name === copy.name)) {
                        this.library.monsters.push(copy);
                    }
                }
                
                this.saveLibrary();
                this.addLog(`${entity.name} saved to library`, 'info');
                this.populateLibrarySidebar();
            },
            
            saveCurrentEntity() {
                if (!this.selectedEntity) {
                    alert('Select an entity first!');
                    return;
                }
                this.saveToLibrary(this.selectedEntity.id);
            },
            
            addFromLibrary(name, category) {
                const x = 300 + Math.random() * 200;
                const y = 200 + Math.random() * 200;
                
                let entity;
                if (category === 'monster' || category === 'player') {
                    entity = this.createEntity(category, name, x, y);
                } else if (category === 'item' || category === 'equipment') {
                    entity = this.createEntity('item', name, x, y);
                }
                
                if (entity) {
                    // Set image from library
                    const libItem = [...this.library.monsters, ...this.library.items, ...this.library.equipment, ...this.library.players, ...this.library.spells].find(i => i.name === name);
                    if (libItem && libItem.image) {
                        entity.image = libItem.image;
                    }
                    this.entities.push(entity);
                    this.updateTurnOrder();
                    this.render();
                    switchTab({target: document.querySelector('.tab.active')}, 'combat');
                }
            },
            
            // Background functions
            saveBackground() {
                const url = document.getElementById('newBgUrl').value;
                if (url && !this.savedBackgrounds.includes(url)) {
                    this.savedBackgrounds.push(url);
                    localStorage.setItem('dndBackgrounds', JSON.stringify(this.savedBackgrounds));
                    this.updateBackgroundList();
                    document.getElementById('newBgUrl').value = '';
                }
            },
            
            removeBackground(url) {
                const index = this.savedBackgrounds.indexOf(url);
                if (index > -1) {
                    this.savedBackgrounds.splice(index, 1);
                    localStorage.setItem('dndBackgrounds', JSON.stringify(this.savedBackgrounds));
                    this.updateBackgroundList();
                }
            },
            
            loadBackground(url) {
                document.getElementById('bgUrl').value = url;
                this.changeBackground();
            },
            
            updateBackgroundList() {
                const list = document.getElementById('backgroundList');
                if (!list) return;
                list.innerHTML = '';
                this.savedBackgrounds.forEach(url => {
                    const card = document.createElement('div');
                    card.className = 'background-card';
                    card.style.backgroundImage = `url(${url})`;
                    card.onclick = () => this.loadBackground(url);
                    card.innerHTML = `
                        <div class="background-overlay">
                            <span>Use this</span>
                            <button class="background-delete-btn" onclick="event.stopPropagation(); game.removeBackground('${url}')">Delete</button>
                        </div>
                    `;
                    list.appendChild(card);
                });
            },
            
            loadSavedBackgrounds() {
                const saved = localStorage.getItem('dndBackgrounds');
                if (saved) {
                    this.savedBackgrounds = JSON.parse(saved);
                    this.updateBackgroundList();
                }
            },
            
            // Settings
            toggleGrid() {
                this.showGrid = !this.showGrid;
                const btn = document.getElementById('gridToggle');
                const grid = document.getElementById('gridOverlay');
                
                btn.classList.toggle('active', this.showGrid);
                grid.style.display = this.showGrid ? 'block' : 'none';
            },
            
            toggleTurnEnforcement() {
                this.enforceTurns = !this.enforceTurns;
                const btn = document.getElementById('turnToggle');
                btn.classList.toggle('active', this.enforceTurns);
                this.addLog(`Turn enforcement ${this.enforceTurns ? 'enabled' : 'disabled'}`, 'info');
            },
            
            toggleMovementRange() {
                this.showMovementRange = !this.showMovementRange;
                const btn = document.getElementById('movementToggle');
                btn.classList.toggle('active', this.showMovementRange);
                this.render();
            },
            
            changeBackground() {
                const url = document.getElementById('bgUrl').value;
                this.backgroundUrl = url;
                const board = document.getElementById('gameBoard');
                if (url) {
                    board.style.backgroundImage = `url(${url})`;
                }
            },
            
            // Combat log
            addLog(message, type = 'info') {
                const log = document.getElementById('combatLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = message;
                
                log.insertBefore(entry, log.firstChild);
                if (log.children.length > 15) {
                    log.removeChild(log.lastChild);
                }
            },
            
            // Animations
            createFloatingText(text, x, y, color) {
                const elem = document.createElement('div');
                elem.className = 'floating-text';
                elem.style.left = `${x}px`;
                elem.style.top = `${y}px`;
                elem.style.color = color;
                elem.textContent = text;
                
                document.getElementById('boardCanvas').appendChild(elem);
                setTimeout(() => elem.remove(), 1500);
            },
            
            createArrowAnimation(x1, y1, x2, y2) {
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const distance = Math.hypot(x2 - x1, y2 - y1);
                
                const arrow = document.createElement('div');
                arrow.className = 'arrow-animation';
                arrow.style.left = `${x1}px`;
                arrow.style.top = `${y1}px`;
                arrow.style.transform = `rotate(${angle}rad)`;
                arrow.innerHTML = `<div class="arrow-line" style="width: ${distance}px"></div>`;
                
                document.getElementById('boardCanvas').appendChild(arrow);
                setTimeout(() => arrow.remove(), 500);
            },
            
            createSpellAnimation(x1, y1, x2, y2, school) {
                const colors = {
                    evocation: '#ff4444',
                    abjuration: '#4444ff',
                    conjuration: '#44ff44',
                    divination: '#ffffff',
                    enchantment: '#ff44ff',
                    illusion: '#ff44ff',
                    necromancy: '#444444',
                    transmutation: '#ffff44'
                };
                
                const effect = document.createElement('div');
                effect.className = 'spell-effect';
                effect.style.left = `${x2 - 50}px`;
                effect.style.top = `${y2 - 50}px`;
                effect.innerHTML = `<div class="magic-circle" style="border-color: ${colors[school] || '#8b5cf6'}"></div>`;
                
                document.getElementById('boardCanvas').appendChild(effect);
                setTimeout(() => effect.remove(), 1000);
            },
            
            // Visual Effects
            applyVisualEffect(target, visualEffect) {
                if (visualEffect && visualEffect.url) {
                    const effectEntity = this.createEntity('effect', 'Visual Effect', target.x, target.y);
                    effectEntity.url = visualEffect.url;
                    effectEntity.loop = visualEffect.loop;
                    effectEntity.playOnce = !visualEffect.loop;
                    this.entities.push(effectEntity);
                    this.render();
                }
            },
            
            // Save/Load
            saveGameState() {
                const state = {
                    entities: this.entities.map(e => ({...e, image: e.image || ''})),
                    currentTurn: this.currentTurn,
                    turnOrder: this.turnOrder,
                    roundNumber: this.roundNumber,
                    nextId: this.nextId,
                    editMode: this.editMode,
                    backgroundUrl: this.backgroundUrl
                };
                
                localStorage.setItem('dndGameState', JSON.stringify(state));
                this.addLog('Game saved!', 'info');
            },
            
            loadGameState() {
                const saved = localStorage.getItem('dndGameState');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        this.entities = state.entities || [];
                        this.currentTurn = state.currentTurn || 0;
                        this.turnOrder = state.turnOrder || [];
                        this.roundNumber = state.roundNumber || 1;
                        this.nextId = state.nextId || 1;
                        this.editMode = state.editMode || false;
                        this.backgroundUrl = state.backgroundUrl || '';
                        const bgInput = document.getElementById('bgUrl');
                        if (bgInput) bgInput.value = this.backgroundUrl;
                        this.changeBackground();
                        this.entities.forEach(e => {
                            if (state.entities.find(se => se.id === e.id)) {
                                e.image = state.entities.find(se => se.id === e.id).image || '';
                            }
                        });
                        this.render();
                        this.updateTurnOrder();
                        const editBtn = document.getElementById('editToggle');
                        if (editBtn) editBtn.classList.toggle('active', this.editMode);
                        this.addLog('Game loaded!', 'info');
                    } catch (e) {
                        console.error('Failed to load game state:', e);
                    }
                }
            },
            
            clearBoard() {
                if (confirm('Clear all entities from the board?')) {
                    this.entities = [];
                    this.selectedEntity = null;
                    this.currentTurn = 0;
                    this.turnOrder = [];
                    this.roundNumber = 1;
                    this.render();
                    this.updateTurnOrder();
                    this.addLog('Board cleared', 'info');
                }
            },
            
            // Import/Export
            exportLibrary() {
                const data = JSON.stringify(this.library, null, 2);
                const exportField = document.getElementById('exportData');
                if (exportField) exportField.value = data;
            },
            
            importLibrary() {
                try {
                    const importField = document.getElementById('importData');
                    if (!importField) return;
                    
                    const data = JSON.parse(importField.value);
                    
                    // Merge libraries
                    ['monsters', 'spells', 'items', 'equipment', 'players'].forEach(key => {
                        if (data[key] && Array.isArray(data[key])) {
                            data[key].forEach(newItem => {
                                if (!this.library[key].some(item => item.name === newItem.name)) {
                                    this.library[key].push(newItem);
                                }
                            });
                        }
                    });
                    
                    this.saveLibrary();
                    this.populateLibrarySidebar();
                    alert('Library imported successfully!');
                } catch (e) {
                    alert('Invalid JSON data!');
                }
            },
            
            saveLibrary() {
                localStorage.setItem('dndLibrary', JSON.stringify(this.library));
            },
            
            loadLibrary() {
                const saved = localStorage.getItem('dndLibrary');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        // Merge with existing library
                        Object.keys(data).forEach(key => {
                            if (Array.isArray(data[key])) {
                                data[key].forEach(item => {
                                    if (!this.library[key].some(existing => existing.name === item.name)) {
                                        this.library[key].push(item);
                                    }
                                });
                            }
                        });
                    } catch (e) {
                        console.error('Failed to load library:', e);
                    }
                }
            },
            
            // Setup quick add buttons
            setupQuickAdd() {
                const grid = document.getElementById('quickAddGrid');
                if (!grid) return;
                
                this.quickSlots.forEach((slot, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'quick-add-btn';
                    btn.textContent = slot ? slot.name : `Slot ${index + 1}`;
                    btn.onclick = () => {
                        if (slot) {
                            const type = slot.type || (slot.class ? 'player' : 'monster');
                            const entity = this.createEntity(type, slot.name, 300 + Math.random() * 200, 200 + Math.random() * 200);
                            if (slot.image) entity.image = slot.image;
                            this.entities.push(entity);
                            this.updateTurnOrder();
                            this.render();
                        }
                    };
                    grid.appendChild(btn);
                });
            },
            
            customizeQuickSlots() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                let html = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                        <h2>‚öôÔ∏è Customize Quick Slots</h2>
                        
                        <div class="item-list">
                            ${this.quickSlots.map((slot, i) => `
                                <div class="item-card">
                                    <strong>Slot ${i+1}:</strong> ${slot ? slot.name : 'Empty'}<br>
                                    <select onchange="game.setQuickSlot(${i}, this.value)">
                                        <option value="">Empty</option>
                                        ${[...this.library.monsters, ...this.library.players].map(item => `<option value="${item.name}" ${slot && slot.name === item.name ? 'selected' : ''}>${item.name}</option>`).join('')}
                                    </select>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                modal.innerHTML = html;
                document.body.appendChild(modal);
            },
            
            setQuickSlot(index, name) {
                if (name) {
                    const item = [...this.library.monsters, ...this.library.players].find(i => i.name === name);
                    if (item) {
                        this.quickSlots[index] = item;
                    }
                } else {
                    this.quickSlots[index] = null;
                }
                this.saveQuickSlots();
                this.setupQuickAdd();
            },
            
            saveQuickSlots() {
                localStorage.setItem('dndQuickSlots', JSON.stringify(this.quickSlots));
            },
            
            loadQuickSlots() {
                const saved = localStorage.getItem('dndQuickSlots');
                if (saved) {
                    this.quickSlots = JSON.parse(saved);
                } else {
                    this.quickSlots = Array(6).fill(null);
                }
            },
            
            // Enhanced character sheet functions
            updateCharacterList() {
                const list = document.getElementById('characterList');
                if (!list) return;
                
                list.innerHTML = '';
                
                this.entities.filter(e => e.type === 'player' || e.type === 'npc').forEach(character => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    
                    const typeIcon = character.type === 'npc' ? 'ü§ñ' : 'üë§';
                    const hpPercent = (character.hp / character.maxHp) * 100;
                    
                    card.innerHTML = `
                        <div class="character-card-header">
                            <div class="character-card-avatar">
                                ${character.image ? `<img src="${character.image}" alt="${character.name}">` : typeIcon}
                            </div>
                            <div class="character-card-info">
                                <h4>${character.name}</h4>
                                <p>Level ${character.level} ${character.race} ${character.class}</p>
                            </div>
                        </div>
                        <div class="character-card-stats">
                            <div class="character-card-stat">
                                <div class="character-card-stat-value">${character.hp}/${character.maxHp}</div>
                                <div class="character-card-stat-label">Hit Points</div>
                            </div>
                            <div class="character-card-stat">
                                <div class="character-card-stat-value">${this.calculateAC(character)}</div>
                                <div class="character-card-stat-label">Armor Class</div>
                            </div>
                            <div class="character-card-stat">
                                <div class="character-card-stat-value">${this.getAbilityModifier(character.dex) >= 0 ? '+' : ''}${this.getAbilityModifier(character.dex)}</div>
                                <div class="character-card-stat-label">Initiative</div>
                            </div>
                        </div>
                    `;
                    card.onclick = () => this.showCharacterSheet(character);
                    list.appendChild(card);
                });
            },
            
            showCharacterSheet(character) {
                const content = document.getElementById('sheetContent');
                if (!content) return;
                
                content.style.display = 'block';
                
                const typeIcon = character.type === 'npc' ? 'ü§ñ' : 'üë§';
                const hpPercent = (character.hp / character.maxHp) * 100;
                const hpClass = hpPercent > 75 ? 'healthy' : hpPercent > 25 ? 'wounded' : '';
                
                let html = `
                    <div class="sheet-header">
                        <div class="sheet-avatar">
                            ${character.image ? `<img src="${character.image}" alt="${character.name}">` : typeIcon}
                        </div>
                        <div class="sheet-basic-info">
                            <h2>${character.name}</h2>
                            <p>Level ${character.level} ${character.race} ${character.class}</p>
                        </div>
                    </div>
                    
                    <div class="sheet-tabs">
                        <button class="sheet-tab active" onclick="game.switchSheetTab(event, 'stats')">Stats</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'combat')">Combat</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'spells')">Spells</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'equipment')">Equipment</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'notes')">Notes</button>
                    </div>
                    
                    <div id="sheet-stats" class="sheet-tab-content active">
                        ${this.renderStatsTab(character)}
                    </div>
                    
                    <div id="sheet-combat" class="sheet-tab-content">
                        ${this.renderCombatTab(character)}
                    </div>
                    
                    <div id="sheet-spells" class="sheet-tab-content">
                        ${this.renderSpellsTab(character)}
                    </div>
                    
                    <div id="sheet-equipment" class="sheet-tab-content">
                        ${this.renderEquipmentTab(character)}
                    </div>
                    
                    <div id="sheet-notes" class="sheet-tab-content">
                        ${this.renderNotesTab(character)}
                    </div>
                `;
                
                content.innerHTML = html;
            },
            
            switchSheetTab(event, tabName) {
                // Remove active class from all tabs and content
                document.querySelectorAll('.sheet-tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.sheet-tab-content').forEach(content => content.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                event.target.classList.add('active');
                document.getElementById(`sheet-${tabName}`).classList.add('active');
            },
            
            renderStatsTab(character) {
                const hpPercent = (character.hp / character.maxHp) * 100;
                const hpClass = hpPercent > 75 ? 'healthy' : hpPercent > 25 ? 'wounded' : '';
                
                return `
                    <div class="core-stats">
                        <div class="stat-card stat-card-large">
                            <h3>Hit Points</h3>
                            <div class="hp-display">
                                <div class="hp-bar-fill ${hpClass}" style="width: ${hpPercent}%"></div>
                                <div class="hp-text">
                                    <input type="number" value="${character.hp}" onchange="game.updateCharacterStat(${character.id}, 'hp', this.value)" class="editable-field" style="width: 40px; background: transparent; border: none; color: white; text-align: center;">
                                    / 
                                    <input type="number" value="${character.maxHp}" onchange="game.updateCharacterStat(${character.id}, 'maxHp', this.value)" class="editable-field" style="width: 40px; background: transparent; border: none; color: white; text-align: center;">
                                </div>
                            </div>
                            <div class="stat-card-subtitle">Current / Maximum</div>
                        </div>
                        
                        <div class="stat-card stat-card-large">
                            <h3>Armor Class</h3>
                            <div class="stat-card-value">${this.calculateAC(character)}</div>
                            <div class="stat-card-subtitle">Total AC</div>
                        </div>
                        
                        <div class="stat-card stat-card-large">
                            <h3>Initiative</h3>
                            <div class="stat-card-value">${this.getAbilityModifier(character.dex) >= 0 ? '+' : ''}${this.getAbilityModifier(character.dex)}</div>
                            <div class="stat-card-subtitle">Dex Modifier</div>
                        </div>
                    </div>
                    
                    <h3 style="color: #fbbf24; margin-bottom: 20px;">Ability Scores</h3>
                    <div class="ability-scores">
                        ${['str', 'dex', 'con', 'int', 'wis', 'cha'].map(ability => {
                            const score = character[ability];
                            const modifier = this.getAbilityModifier(score);
                            return `
                                <div class="ability-score">
                                    <div class="ability-score-name">${ability.toUpperCase()}</div>
                                    <div class="ability-score-value">
                                        <input type="number" value="${score}" onchange="game.updateCharacterStat(${character.id}, '${ability}', this.value)" class="editable-field" style="width: 60px;">
                                    </div>
                                    <div class="ability-score-modifier">${modifier >= 0 ? '+' : ''}${modifier}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <div class="skills-section">
                        <div class="skill-category">
                            <h4>Saving Throws</h4>
                            <div class="skill-list">
                                ${['str', 'dex', 'con', 'int', 'wis', 'cha'].map(ability => {
                                    const modifier = this.getAbilityModifier(character[ability]);
                                    const saveBonus = modifier + (character.savingThrows[ability] || 0);
                                    const isProficient = character.savingThrows[ability] > 0;
                                    return `
                                        <div class="skill-item ${isProficient ? 'proficient' : ''}">
                                            <div class="skill-name">
                                                <div class="proficiency-indicator ${isProficient ? 'filled' : ''}"></div>
                                                ${ability.charAt(0).toUpperCase() + ability.slice(1)}
                                            </div>
                                            <div class="skill-bonus">${saveBonus >= 0 ? '+' : ''}${saveBonus}</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                        
                        <div class="skill-category">
                            <h4>Skills</h4>
                            <div class="skill-list">
                                ${Object.entries(this.skillsList).map(([skill, ability]) => {
                                    const abilityMod = this.getAbilityModifier(character[ability]);
                                    const skillBonus = character.skills[skill] || abilityMod;
                                    const isProficient = character.skills[skill] && character.skills[skill] > abilityMod;
                                    const skillName = skill.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                                    return `
                                        <div class="skill-item ${isProficient ? 'proficient' : ''}">
                                            <div class="skill-name">
                                                <div class="proficiency-indicator ${isProficient ? 'filled' : ''}"></div>
                                                ${skillName}
                                            </div>
                                            <div class="skill-bonus">${skillBonus >= 0 ? '+' : ''}${skillBonus}</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
            },
            
            renderCombatTab(character) {
                return `
                    <div class="combat-stats">
                        <div class="stat-card">
                            <h3>Speed</h3>
                            <div class="stat-card-value">
                                <input type="number" value="${character.speed}" onchange="game.updateCharacterStat(${character.id}, 'speed', this.value)" class="editable-field" style="width: 60px;">
                            </div>
                            <div class="stat-card-subtitle">feet</div>
                        </div>
                        
                        <div class="stat-card">
                            <h3>Prof Bonus</h3>
                            <div class="stat-card-value">+${character.proficiencyBonus}</div>
                            <div class="stat-card-subtitle">Proficiency</div>
                        </div>
                        
                        <div class="stat-card">
                            <h3>Hit Dice</h3>
                            <div class="stat-card-value">${character.hitDiceRemaining}${character.hitDice}</div>
                            <div class="stat-card-subtitle">Remaining</div>
                        </div>
                        
                        <div class="stat-card">
                            <h3>Level</h3>
                            <div class="stat-card-value">
                                <input type="number" value="${character.level}" onchange="game.updateCharacterStat(${character.id}, 'level', this.value)" class="editable-field" style="width: 60px;">
                            </div>
                            <div class="stat-card-subtitle">Character Level</div>
                        </div>
                    </div>
                    
                    <div class="attacks-section">
                        <h4>‚öîÔ∏è Attacks & Weapons</h4>
                        ${character.attacks.length > 0 ? `
                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 15px; padding: 10px; border-bottom: 2px solid #374151; margin-bottom: 15px; font-weight: 600; color: #9ca3af; font-size: 12px; text-transform: uppercase;">
                                <div>Weapon</div>
                                <div style="text-align: center;">Attack Bonus</div>
                                <div style="text-align: center;">Damage</div>
                                <div style="text-align: center;">Range</div>
                            </div>
                            ${character.attacks.map(attack => `
                                <div class="attack-item">
                                    <div class="attack-name">${attack.name}</div>
                                    <div class="attack-stat">
                                        <div class="attack-stat-value">+${attack.toHit || 0}</div>
                                    </div>
                                    <div class="attack-stat">
                                        <div class="attack-stat-value">${attack.damage}</div>
                                        <div style="font-size: 10px; color: #6b7280;">${attack.damageType}</div>
                                    </div>
                                    <div class="attack-stat">
                                        <div class="attack-stat-value">${attack.range || 5}ft</div>
                                    </div>
                                </div>
                            `).join('')}
                        ` : '<p style="color: #9ca3af; text-align: center; padding: 20px;">No attacks configured</p>'}
                    </div>
                    
                    ${character.conditions.length > 0 ? `
                        <div class="attacks-section">
                            <h4>üîÆ Active Conditions</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                                ${character.conditions.map(condition => `
                                    <span style="background: rgba(139, 92, 246, 0.2); color: #8b5cf6; padding: 5px 12px; border-radius: 20px; font-size: 12px; font-weight: 600;">
                                        ${condition}${character.conditionTurns && character.conditionTurns[condition] ? ` (${character.conditionTurns[condition]})` : ''}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                `;
            },
            
            renderSpellsTab(character) {
                const hasSpells = character.spells && character.spells.length > 0;
                const hasSpellSlots = Object.values(character.spellSlots || {}).some(slots => slots > 0);
                
                if (!hasSpells && !hasSpellSlots) {
                    return '<p style="color: #9ca3af; text-align: center; padding: 40px;">This character does not have spellcasting abilities.</p>';
                }
                
                return `
                    ${hasSpellSlots ? `
                        <h4 style="color: #8b5cf6; margin-bottom: 20px;">Spell Slots</h4>
                        <div class="spell-slots">
                            ${[1,2,3,4,5,6,7,8,9].map(level => {
                                const total = character.spellSlots[level] || 0;
                                const used = character.spellSlotsUsed[level] || 0;
                                if (total === 0) return '';
                                return `
                                    <div class="spell-slot-level">
                                        <h5>Level ${level}</h5>
                                        <div class="spell-slot-tracker">${used}/${total}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : ''}
                    
                    ${hasSpells ? `
                        <h4 style="color: #8b5cf6; margin-bottom: 20px;">Known Spells</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                            ${character.spells.map(spell => `
                                <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; border-radius: 8px; padding: 15px;">
                                    <h5 style="color: #8b5cf6; margin: 0 0 8px 0;">${spell.name}</h5>
                                    <p style="color: #9ca3af; font-size: 12px; margin: 0 0 8px 0;">Level ${spell.level} ${spell.school}</p>
                                    <p style="color: #e0e0e0; font-size: 13px; margin: 0;">${spell.description}</p>
                                    ${spell.damage ? `<p style="color: #ef4444; font-size: 12px; margin: 5px 0 0 0;">Damage: ${spell.damage} ${spell.damageType}</p>` : ''}
                                    ${spell.healing ? `<p style="color: #10b981; font-size: 12px; margin: 5px 0 0 0;">Healing: ${spell.healing}</p>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            },
            
            renderEquipmentTab(character) {
                const equipmentSlots = [
                    {key: 'armor', name: 'Armor'},
                    {key: 'mainHand', name: 'Main Hand'},
                    {key: 'offHand', name: 'Off Hand'},
                    {key: 'helmet', name: 'Helmet'},
                    {key: 'boots', name: 'Boots'},
                    {key: 'gloves', name: 'Gloves'},
                    {key: 'amulet', name: 'Amulet'},
                    {key: 'cloak', name: 'Cloak'},
                    {key: 'ring1', name: 'Ring 1'},
                    {key: 'ring2', name: 'Ring 2'}
                ];
                
                return `
                    <h4 style="color: #10b981; margin-bottom: 20px;">Equipment Slots</h4>
                    <div class="equipment-slots">
                        ${equipmentSlots.map(slot => {
                            const item = character.equipment[slot.key];
                            return `
                                <div class="equipment-slot ${item ? 'filled' : ''}">
                                    <div class="equipment-slot-name">${slot.name}</div>
                                    <div class="equipment-item">
                                        ${item ? item.name : 'Empty'}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    ${character.inventory && character.inventory.length > 0 ? `
                        <h4 style="color: #f59e0b; margin: 30px 0 20px 0;">Inventory</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                            ${character.inventory.map(item => `
                                <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid #f59e0b; border-radius: 8px; padding: 15px;">
                                    <h5 style="color: #f59e0b; margin: 0 0 5px 0;">${item.name}</h5>
                                    ${item.description ? `<p style="color: #9ca3af; font-size: 12px; margin: 0;">${item.description}</p>` : ''}
                                    ${item.damage ? `<p style="color: #ef4444; font-size: 11px; margin: 5px 0 0 0;">Damage: ${item.damage}</p>` : ''}
                                    ${item.ac ? `<p style="color: #3b82f6; font-size: 11px; margin: 5px 0 0 0;">AC: ${item.ac}</p>` : ''}
                                    ${item.healing ? `<p style="color: #10b981; font-size: 11px; margin: 5px 0 0 0;">Healing: ${item.healing}</p>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    ` : '<p style="color: #9ca3af; text-align: center; padding: 20px;">No items in inventory</p>'}
                `;
            },
            
            renderNotesTab(character) {
                return `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                        <div>
                            <h4 style="color: #fbbf24; margin-bottom: 15px;">Character Details</h4>
                            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #374151; border-radius: 8px; padding: 20px;">
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Character Name</label>
                                    <input type="text" value="${character.name}" onchange="game.updateCharacterStat(${character.id}, 'name', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Race</label>
                                    <input type="text" value="${character.race}" onchange="game.updateCharacterStat(${character.id}, 'race', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Class</label>
                                    <input type="text" value="${character.class}" onchange="game.updateCharacterStat(${character.id}, 'class', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                                <div>
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Character Image URL</label>
                                    <input type="text" value="${character.image || ''}" onchange="game.updateCharacterStat(${character.id}, 'image', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 style="color: #fbbf24; margin-bottom: 15px;">Notes & Roleplay</h4>
                            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #374151; border-radius: 8px; padding: 20px;">
                                <textarea placeholder="Character backstory, personality traits, ideals, bonds, flaws..." style="width: 100%; height: 200px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white; padding: 12px; resize: vertical;" onchange="game.updateCharacterStat(${character.id}, 'notes', this.value)">${character.notes || ''}</textarea>
                            </div>
                        </div>
                    </div>
                `;
            },
            
            updateCharacterStat(characterId, property, value) {
                const character = this.getEntity(characterId);
                if (!character) return;
                
                const numericProps = ['hp', 'maxHp', 'ac', 'speed', 'str', 'dex', 'con', 'int', 'wis', 'cha', 'tempHp', 'level'];
                
                if (numericProps.includes(property)) {
                    character[property] = parseInt(value) || 0;
                } else {
                    character[property] = value;
                }
                
                // Recalculate AC if ability scores change
                if (['str', 'dex'].includes(property)) {
                    character.ac = this.calculateAC(character);
                }
                
                // Update the board representation
                this.render();
                
                // Update the character list if it's visible
                if (document.getElementById('characters-tab').classList.contains('active')) {
                    this.updateCharacterList();
                }
            },
            
            // Base Action Implementations
            performShove(attacker, target) {
                const attackRoll = this.rollDice('1d20') + this.getAbilityModifier(attacker.str) + attacker.proficiencyBonus;
                const defenseRoll = this.rollDice('1d20') + Math.max(this.getAbilityModifier(target.str), this.getAbilityModifier(target.dex));
                
                if (attackRoll >= defenseRoll) {
                    const choice = confirm('Choose effect: OK for Push, Cancel for Prone');
                    if (choice) {
                        // Push 5ft away
                        const dx = target.x - attacker.x;
                        const dy = target.y - attacker.y;
                        const dist = Math.hypot(dx, dy);
                        const pushX = target.x + (dx / dist) * 25; // 5ft = 25 pixels?
                        const pushY = target.y + (dy / dist) * 25;
                        target.x = pushX;
                        target.y = pushY;
                        this.addLog(`${attacker.name} shoves ${target.name} back 5ft!`, 'info');
                    } else {
                        this.addCondition(target, 'prone');
                        this.addLog(`${attacker.name} shoves ${target.name} prone!`, 'info');
                    }
                } else {
                    this.addLog(`${attacker.name} fails to shove ${target.name}!`, 'info');
                }
                attacker.actionUsed = true;
                this.render();
            },
            
            performHide(entity) {
                const roll = this.rollDice('1d20') + this.getAbilityModifier(entity.dex) + (entity.skills.stealth || 0);
                this.addLog(`${entity.name} attempts to hide (Stealth: ${roll})`, 'info');
                // Would need DM to note the roll for perception checks
                entity.actionUsed = true;
            },
            
            performDisengage(entity) {
                // Flag for no opportunity attacks, but need to implement opportunity attacks first
                this.addLog(`${entity.name} disengages!`, 'info');
                entity.actionUsed = true;
            },
            
            performDash(entity) {
                entity.movement += entity.speed;
                this.addLog(`${entity.name} dashes! Extra ${entity.speed}ft movement.`, 'info');
                entity.actionUsed = true;
                this.render();
            },
            
            performHelp(helper, target) {
                // Give advantage to target's next ability check or attack
                if (!target.advantages) target.advantages = {};
                target.advantages['nextRoll'] = true;
                this.addLog(`${helper.name} helps ${target.name}! Advantage on next roll.`, 'info');
                helper.actionUsed = true;
            },
            
            performReady(entity) {
                // Would need to set up trigger and reaction
                this.addLog(`${entity.name} readies an action!`, 'info');
                entity.actionUsed = true;
            },
        };
        
        // Global tab switchingfunction
        function switchTab(event, tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            if (tabName === 'characters') game.updateCharacterList();
            if (tabName === 'backgrounds') game.updateBackgroundList();
        }
        
        // Initialize the game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
    </script>
</body>
</html>