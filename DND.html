<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DND 5e Complete System - Professional Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        :root {
            --primary-hue: 262;
            --background-hue: 240;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

            body::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                opacity: 0.2;
                z-index: -1;
                pointer-events: none;
            }

        /* Tab System */
        .tab-container {
            display: flex;
            background: linear-gradient(180deg, hsla(var(--background-hue), 20%, 14%, 0.9) 0%, hsla(var(--background-hue), 33%, 8%, 0.9) 100%);
            border-bottom: 2px solid hsl(var(--background-hue), 20%, 20%);
            padding: 0 20px;
            height: 50px;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #9ca3af;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

            .tab:hover {
                color: #e0e0e0;
                background: rgba(255, 255, 255, 0.05);
            }

            .tab.active {
                color: #fbbf24;
                border-bottom-color: #fbbf24;
                background: rgba(251, 191, 36, 0.1);
            }

        .tab-content {
            display: none;
            height: calc(100vh - 50px);
            overflow: hidden;
            background: transparent;
        }

            .tab-content.active {
                display: block;
            }

        /* Combat Board Layout */
        .combat-container {
            display: flex;
            height: 100%;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: linear-gradient(180deg, hsla(var(--background-hue), 20%, 14%, 0.9) 0%, hsla(var(--background-hue), 33%, 6%, 0.9) 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid hsl(var(--background-hue), 20%, 20%);
        }

            .sidebar h2 {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 20px;
                font-size: 20px;
                color: #fbbf24;
            }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #6b7280;
            margin-bottom: 12px;
            font-weight: 700;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, hsl(var(--primary-hue), 83%, 58%), hsl(var(--primary-hue), 83%, 53%));
            color: white;
        }

            .btn-primary:hover {
                background: linear-gradient(135deg, hsl(var(--primary-hue), 83%, 53%), hsl(var(--primary-hue), 83%, 48%));
                transform: translateY(-2px);
            }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Quick Add Grid */
        .quick-add-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .quick-add-btn {
            padding: 8px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: #93bbfc;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            position: relative;
        }

            .quick-add-btn:hover {
                background: rgba(59, 130, 246, 0.2);
                transform: scale(1.05);
            }

            .quick-add-btn.customizable {
                background: rgba(251, 191, 36, 0.1);
                border: 1px solid rgba(251, 191, 36, 0.3);
                color: #fbbf24;
            }

                .quick-add-btn.customizable:hover {
                    background: rgba(251, 191, 36, 0.2);
                }

            .quick-add-btn .remove-quick {
                position: absolute;
                top: -5px;
                right: -5px;
                background: #ef4444;
                color: white;
                border: none;
                border-radius: 50%;
                width: 16px;
                height: 16px;
                font-size: 10px;
                cursor: pointer;
                display: none;
            }

            .quick-add-btn:hover .remove-quick {
                display: block;
            }

        /* Dice Roll Grid */
        .dice-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .dice-btn {
            padding: 8px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 6px;
            color: #fbbf24;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

            .dice-btn:hover {
                background: rgba(251, 191, 36, 0.2);
                transform: scale(1.05);
            }

        /* Turn Order */
        .turn-order {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .turn-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            font-size: 13px;
            background: rgba(55, 65, 81, 0.3);
            justify-content: space-between;
        }

            .turn-item.active {
                background: linear-gradient(135deg, #10b981, #059669);
            }

        .turn-actions {
            font-size: 10px;
            opacity: 0.8;
        }

        /* Settings */
        .toggle-btn {
            background: #374151;
            position: relative;
            padding-left: 50px;
        }

            .toggle-btn.active {
                background: linear-gradient(135deg, hsl(var(--primary-hue), 83%, 58%), hsl(var(--primary-hue), 83%, 53%));
            }

        .toggle-switch {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 35px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

            .toggle-switch::after {
                content: '';
                position: absolute;
                width: 16px;
                height: 16px;
                background: white;
                border-radius: 50%;
                top: 2px;
                left: 2px;
                transition: all 0.3s;
            }

        .toggle-btn.active .toggle-switch::after {
            left: 17px;
        }

        .input-field {
            width: 100%;
            padding: 8px 12px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 13px;
            margin-bottom: 8px;
        }

        /* Sound Settings */
        .sound-input {
            width: 100%;
            padding: 6px 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            margin-bottom: 4px;
        }

        /* Background Music Controls */
        .music-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .music-btn {
            padding: 6px 12px;
            background: hsla(var(--primary-hue), 83%, 58%, 0.2);
            border: 1px solid hsla(var(--primary-hue), 83%, 58%, 0.5);
            border-radius: 6px;
            color: hsl(var(--primary-hue), 83%, 58%);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

            .music-btn:hover {
                background: hsla(var(--primary-hue), 83%, 58%, 0.3);
            }

            .music-btn.active {
                background: hsla(var(--primary-hue), 83%, 58%, 0.4);
            }

        /* Combat Log */
        .combat-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 6px 10px;
            margin-bottom: 4px;
            background: rgba(55, 65, 81, 0.3);
            border-radius: 4px;
            font-size: 12px;
            border-left: 3px solid #4b5563;
        }

            .log-entry.damage {
                border-left-color: #ef4444;
            }

            .log-entry.heal {
                border-left-color: #10b981;
            }

            .log-entry.info {
                border-left-color: #3b82f6;
            }

            .log-entry.death {
                border-left-color: #dc2626;
            }

            .log-entry.save {
                border-left-color: #fbbf24;
            }

        /* Game Board */
        .game-board {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, hsla(var(--background-hue), 20%, 14%, 0.8) 0%, hsla(var(--background-hue), 33%, 8%, 0.8) 100%);
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .board-container {
            position: absolute;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .board-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /* Drawing Canvas */
        .drawing-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

            .drawing-canvas.drawing-mode {
                pointer-events: auto;
            }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
        }

        /* Drag Arrow */
        .drag-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 25;
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            transform-origin: left center;
        }

        .persistent-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 25;
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            animation: fadeOut 1s ease-out 0.5s forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }

        /* Entity Styles */
        .entity {
            position: absolute;
            width: 70px;
            height: 70px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            user-select: none;
        }

            .entity:hover {
                transform: scale(1.1);
                z-index: 20;
            }

            .entity.selected {
                z-index: 30;
            }

            .entity.dead {
                opacity: 0.4;
                filter: grayscale(100%);
            }

            .entity.unconscious {
                opacity: 0.6;
                filter: grayscale(50%);
            }

            .entity.valid-target {
                animation: pulse 1s infinite;
            }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.5));
            }

            50% {
                transform: scale(1.08);
                filter: drop-shadow(0 0 20px rgba(251, 191, 36, 0.8));
            }
        }

        .entity.hidden {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .entity-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border: 3px solid;
        }

        .entity.selected .entity-circle {
            box-shadow: 0 0 0 4px rgba(251, 191, 36, 0.4);
        }

        .entity-image {
            width: 74%;
            height: 74%;
            border-radius: 50%;
            object-fit: cover;
        }

        .entity-content {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* HP Bar */
        .hp-bar {
            position: absolute;
            bottom: -4px;
            left: 10%;
            width: 80%;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            overflow: visible;
        }

        .hp-adjust-btn {
            position: absolute;
            top: -6px;
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            transition: all 0.2s;
        }

            .hp-adjust-btn:hover {
                transform: scale(1.1);
            }

        .hp-minus {
            left: -25px;
            background: #ef4444;
        }

            .hp-minus:hover {
                background: #dc2626;
            }

        .hp-plus {
            right: -25px;
            background: #10b981;
        }

            .hp-plus:hover {
                background: #059669;
            }

        .hp-fill {
            height: 100%;
            transition: all 0.5s;
            border-radius: 3px;
        }

            .hp-fill.high {
                background: linear-gradient(to right, #10b981, #34d399);
            }

            .hp-fill.medium {
                background: linear-gradient(to right, #f59e0b, #fbbf24);
            }

            .hp-fill.low {
                background: linear-gradient(to right, #dc2626, #ef4444);
            }

        /* Entity Name Label */
        .entity-name {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: 600;
        }

        /* Conditions Badge */
        .conditions-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: hsla(var(--primary-hue), 83%, 58%, 0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
        }

        /* Status Effect Indicators */
        .status-indicator {
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #374151;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 16px;
            min-width: 20px;
            text-align: center;
            z-index: 25;
        }

            .status-indicator.death {
                color: #dc2626;
            }

            .status-indicator.unconscious {
                color: #f59e0b;
            }

            .status-indicator.condition {
                color: hsl(var(--primary-hue), 83%, 58%);
                font-size: 12px;
            }

        /* Death Saves Indicator */
        .death-saves-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            display: flex;
            gap: 2px;
        }

        .death-save-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

            .death-save-dot.success {
                background: #10b981;
            }

            .death-save-dot.failure {
                background: #ef4444;
            }

        /* Action Menu */
        .action-menu {
            position: absolute;
            top: 80px;
            left: 0;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 14px;
            min-width: 280px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1000;
        }

            .action-menu.pushed-left {
                left: -300px;
            }

        .action-section {
            margin-bottom: 12px;
        }

        .action-section-title {
            font-size: 10px;
            text-transform: uppercase;
            color: #6b7280;
            margin-bottom: 6px;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            text-align: left;
            padding: 7px 10px;
            background: rgba(55, 65, 81, 0.3);
            border: 1px solid transparent;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
        }

            .action-btn:hover {
                background: rgba(55, 65, 81, 0.5);
                border-color: hsla(var(--primary-hue), 83%, 58%, 0.3);
            }

            .action-btn.disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

        .spell-slot-info {
            font-size: 10px;
            color: #9ca3af;
            margin-left: auto;
        }

        /* Details Panel */
        .details-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 18px;
            min-width: 320px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 500;
        }

        .stat-input {
            background: #374151;
            border: 1px solid #4b5563;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-size: 13px;
            width: 60px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(55, 65, 81, 0.5);
        }

        .stat-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .stat-box {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px;
        }

        .stat-label {
            font-size: 10px;
            color: #9ca3af;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #fbbf24;
        }

        .stat-mod {
            font-size: 12px;
            color: #6b7280;
        }

        /* Close Button */
        .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: transparent;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 4px;
            font-size: 18px;
        }

            .close-btn:hover {
                color: #ef4444;
            }

        /* Targeting Indicator */
        .targeting-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
            z-index: 1000;
        }

        .targeting-text {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            color: white;
        }

        .cancel-btn {
            display: block;
            margin: 0 auto;
            font-size: 12px;
            color: #fca5a5;
            text-decoration: underline;
            cursor: pointer;
            background: none;
            border: none;
        }

        /* Manager Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 30px;
            min-width: 500px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

            .modal h2 {
                color: #fbbf24;
                margin-bottom: 20px;
            }

        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .item-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

            .item-card:hover {
                background: rgba(0, 0, 0, 0.5);
                border-color: hsl(var(--primary-hue), 83%, 58%);
            }

            .item-card.selected {
                background: hsla(var(--primary-hue), 83%, 58%, 0.2);
                border-color: hsl(var(--primary-hue), 83%, 58%);
            }

        /* Enhanced Character Sheet */
        .character-sheet {
            padding: 20px;
            height: 100%;
            overflow-y: auto;
            background: hsla(var(--background-hue), 33%, 6%, 0.85);
        }

        .character-list {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .character-card {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
            position: relative;
        }

            .character-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
                border-color: hsl(var(--primary-hue), 83%, 58%);
            }

        .character-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .character-card-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, hsl(var(--primary-hue), 83%, 58%), hsl(var(--primary-hue), 83%, 53%));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
        }

            .character-card-avatar img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 50%;
            }

        .character-card-info h4 {
            color: #fbbf24;
            margin: 0;
            font-size: 16px;
        }

        .character-card-info p {
            color: #9ca3af;
            margin: 2px 0;
            font-size: 12px;
        }

        .character-card-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #374151;
        }

        .character-card-stat {
            text-align: center;
        }

        .character-card-stat-value {
            font-size: 14px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .character-card-stat-label {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
        }

        .sheet-content {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 0;
            margin-top: 20px;
        }

        /* Character Sheet Header */
        .sheet-header {
            padding: 30px;
            border-bottom: 1px solid #374151;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .sheet-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, hsl(var(--primary-hue), 83%, 58%), hsl(var(--primary-hue), 83%, 53%));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: white;
            overflow: hidden;
        }

            .sheet-avatar img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 50%;
            }

        .sheet-basic-info h2 {
            color: #fbbf24;
            margin: 0 0 10px 0;
            font-size: 28px;
        }

        .sheet-basic-info p {
            color: #9ca3af;
            margin: 0;
            font-size: 16px;
        }

        /* Character Sheet Tabs */
        .sheet-tabs {
            display: flex;
            background: #1a1a2e;
            border-bottom: 1px solid #374151;
        }

        .sheet-tab {
            padding: 15px 25px;
            background: transparent;
            border: none;
            color: #9ca3af;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

            .sheet-tab:hover {
                color: #e0e0e0;
                background: rgba(255, 255, 255, 0.05);
            }

            .sheet-tab.active {
                color: #fbbf24;
                border-bottom-color: #fbbf24;
                background: rgba(251, 191, 36, 0.1);
            }

        .sheet-tab-content {
            display: none;
            padding: 30px;
        }

            .sheet-tab-content.active {
                display: block;
            }

        /* Core Stats Section */
        .core-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        .stat-card-large {
            background: rgba(251, 191, 36, 0.1);
            border-color: #fbbf24;
        }

        .stat-card h3 {
            color: #fbbf24;
            margin: 0 0 10px 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card-value {
            font-size: 32px;
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 5px;
        }

        .stat-card-subtitle {
            font-size: 12px;
            color: #9ca3af;
        }

        /* HP Bar */
        .hp-display {
            position: relative;
            background: #1f2937;
            border: 2px solid #374151;
            border-radius: 8px;
            height: 40px;
            overflow: hidden;
        }

        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #dc2626);
            transition: width 0.3s ease;
            position: relative;
        }

            .hp-bar-fill.healthy {
                background: linear-gradient(90deg, #10b981, #059669);
            }

            .hp-bar-fill.wounded {
                background: linear-gradient(90deg, #f59e0b, #d97706);
            }

        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 2;
        }

        /* Ability Scores */
        .ability-scores {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .ability-score {
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #374151;
            border-radius: 12px;
            padding: 15px 10px;
            transition: all 0.3s;
        }

            .ability-score:hover {
                border-color: hsl(var(--primary-hue), 83%, 58%);
                transform: translateY(-2px);
            }

        .ability-score-name {
            font-size: 12px;
            color: #9ca3af;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .ability-score-value {
            font-size: 24px;
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 5px;
        }

        .ability-score-modifier {
            font-size: 14px;
            color: #fbbf24;
            font-weight: 600;
        }

        /* Skills Section */
        .skills-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .skill-category h4 {
            color: #fbbf24;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #374151;
            padding-bottom: 8px;
        }

        .skill-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .skill-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid #374151;
            border-radius: 8px;
            transition: all 0.3s;
        }

            .skill-item:hover {
                background: rgba(0, 0, 0, 0.4);
                border-color: hsl(var(--primary-hue), 83%, 58%);
            }

            .skill-item.proficient {
                border-color: #10b981;
                background: rgba(16, 185, 129, 0.1);
            }

        .skill-name {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #e0e0e0;
            font-weight: 500;
        }

        .proficiency-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #6b7280;
            background: transparent;
        }

            .proficiency-indicator.filled {
                background: #10b981;
                border-color: #10b981;
            }

        .skill-bonus {
            color: #fbbf24;
            font-weight: 600;
            font-size: 14px;
        }

        /* Combat Section */
        .combat-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .attacks-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 20px;
        }

            .attacks-section h4 {
                color: #ef4444;
                margin-bottom: 15px;
                font-size: 18px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

        .attack-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid #374151;
            border-radius: 8px;
            margin-bottom: 10px;
            align-items: center;
        }

        .attack-name {
            color: #e0e0e0;
            font-weight: 600;
        }

        .attack-stat {
            text-align: center;
            color: #9ca3af;
            font-size: 14px;
        }

        .attack-stat-value {
            color: #fbbf24;
            font-weight: 600;
        }

        /* Spells Section */
        .spell-slots {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 10px;
            margin-bottom: 30px;
        }

        .spell-slot-level {
            text-align: center;
            background: hsla(var(--primary-hue), 83%, 58%, 0.1);
            border: 1px solid hsl(var(--primary-hue), 83%, 58%);
            border-radius: 8px;
            padding: 10px;
        }

            .spell-slot-level h5 {
                color: hsl(var(--primary-hue), 83%, 58%);
                margin: 0 0 5px 0;
                font-size: 12px;
            }

        .spell-slot-tracker {
            color: #e0e0e0;
            font-weight: 600;
        }

        /* Equipment Section */
        .equipment-slots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .equipment-slot {
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed #374151;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
        }

            .equipment-slot.filled {
                border-style: solid;
                border-color: #10b981;
                background: rgba(16, 185, 129, 0.1);
            }

        .equipment-slot-name {
            color: #9ca3af;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .equipment-item {
            color: #e0e0e0;
            font-weight: 600;
        }

        /* Editable Fields */
        .editable-field {
            background: transparent;
            border: 1px solid transparent;
            color: inherit;
            font-size: inherit;
            font-weight: inherit;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.3s;
            text-align: center;
            width: 100%;
        }

            .editable-field:hover {
                background: rgba(255, 255, 255, 0.05);
                border-color: #374151;
            }

            .editable-field:focus {
                outline: none;
                background: #1f2937;
                border-color: #fbbf24;
                box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
            }

        /* Backgrounds Tab */
        .backgrounds-container {
            padding: 20px;
            height: 100%;
            overflow-y: auto;
            background: hsla(var(--background-hue), 33%, 6%, 0.85);
        }

        .background-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .background-card {
            width: 200px;
            height: 150px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            border: 2px solid #374151;
        }

            .background-card:hover {
                border-color: hsl(var(--primary-hue), 83%, 58%);
            }

        .background-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .background-delete-btn {
            background: #ef4444;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

            .background-delete-btn:hover {
                background: #dc2626;
            }

        /* Import/Export */
        .textarea-large {
            width: 100%;
            height: 200px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
        }

        /* Movement Range Indicator */
        .movement-range {
            position: absolute;
            border: 2px dashed rgba(59, 130, 246, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }

        /* Animations */
        .floating-text {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            animation: floatUp 1.5s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 1;
            }

            100% {
                transform: translateY(-60px) scale(1.2);
                opacity: 0;
            }
        }

        .arrow-animation {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }

        .arrow-line {
            height: 3px;
            background: linear-gradient(to right, transparent, #fbbf24, #f59e0b);
            animation: shootArrow 0.5s ease-out;
            position: relative;
        }

        @keyframes shootArrow {
            0% {
                width: 0;
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.2;
            }
        }

        /* Targeting Arrow */
        .targeting-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }

        .targeting-line {
            height: 3px;
            background: linear-gradient(to right, transparent, #dc2626, transparent);
            position: relative;
        }

        /* Spell Effect Animation */
        .spell-effect {
            position: absolute;
            pointer-events: none;
            z-index: 600;
        }

        @keyframes magicPulse {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }

            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .magic-circle {
            width: 100px;
            height: 100px;
            border: 3px solid;
            border-radius: 50%;
            animation: magicPulse 1s ease-out;
        }

        /* Roll Result Display */
        .roll-result {
            position: fixed;
            top: 60px;
            right: 20px;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1500;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .roll-result h3 {
            color: #fbbf24;
            margin-bottom: 10px;
        }

        .roll-breakdown {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 5px;
        }

        /* Expandable Library Sidebar */
        .library-sidebar-toggle {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: linear-gradient(135deg, hsl(var(--primary-hue), 83%, 58%), hsl(var(--primary-hue), 83%, 53%));
            color: white;
            border: none;
            padding: 12px 8px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            cursor: pointer;
            border-radius: 8px 0 0 8px;
            font-size: 12px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
        }

            .library-sidebar-toggle:hover {
                background: linear-gradient(135deg, hsl(var(--primary-hue), 83%, 53%), hsl(var(--primary-hue), 83%, 48%));
                transform: translateY(-50%) translateX(-5px);
            }

        .expandable-library-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: linear-gradient(180deg, hsl(var(--background-hue), 20%, 14%) 0%, hsl(var(--background-hue), 33%, 6%) 100%);
            border-left: 2px solid hsl(var(--background-hue), 20%, 20%);
            transition: right 0.3s ease-out;
            z-index: 999;
            display: flex;
            flex-direction: column;
        }

            .expandable-library-sidebar.open {
                right: 0;
            }

        .expandable-library-header {
            padding: 20px;
            border-bottom: 1px solid hsl(var(--background-hue), 20%, 20%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .expandable-library-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

            .expandable-library-content .search-bar {
                margin-bottom: 15px;
            }

            .expandable-library-content .content-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .expandable-library-content .content-card {
                background: linear-gradient(135deg, #1f2937, #111827);
                border: 1px solid #374151;
                border-radius: 8px;
                padding: 12px;
                cursor: pointer;
                transition: all 0.3s;
            }

                .expandable-library-content .content-card:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
                    border-color: hsl(var(--primary-hue), 83%, 58%);
                }

        .expandable-library-filters {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

            .expandable-library-filters .btn-small {
                padding: 4px 8px;
                font-size: 10px;
                margin: 0;
            }

        /* Search Bar */
        .search-bar {
            width: 100%;
            padding: 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            margin-bottom: 15px;
        }
        /* Enhanced Creation Modal Styles */
        .creation-modal {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 30px;
            min-width: 400px;
            max-width: 600px;
            position: relative;
        }

            .creation-modal h2 {
                color: #fbbf24;
                margin-bottom: 25px;
                text-align: center;
            }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-weight: 600;
            font-size: 14px;
        }

        .form-select {
            width: 100%;
            padding: 12px 16px;
            background: #1f2937;
            border: 2px solid #374151;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

            .form-select:focus {
                outline: none;
                border-color: #fbbf24;
                box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.1);
            }

        .custom-input {
            width: 100%;
            padding: 12px 16px;
            background: #1f2937;
            border: 2px solid #374151;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            margin-top: 10px;
            display: none;
            transition: all 0.3s;
        }

            .custom-input.show {
                display: block;
            }

            .custom-input:focus {
                outline: none;
                border-color: #fbbf24;
                box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.1);
            }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

            .modal-buttons .btn {
                min-width: 120px;
                margin-bottom: 0;
            }

        /* Advanced Options Dropdown */
        .advanced-toggle {
            background: hsla(var(--primary-hue), 83%, 58%, 0.2);
            border: 1px solid hsl(var(--primary-hue), 83%, 58%);
            color: hsl(var(--primary-hue), 83%, 58%);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

            .advanced-toggle:hover {
                background: hsla(var(--primary-hue), 83%, 58%, 0.3);
            }

        .advanced-options {
            display: none;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
        }

            .advanced-options.show {
                display: block;
            }

        .advanced-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }

        .advanced-input {
            width: 100%;
            padding: 8px 12px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 13px;
        }

        /* NPC Token Styling */
        .entity.npc .entity-circle {
            border-color: #f59e0b !important;
            background: #f59e0b !important;
        }
        /* Visual Effects System */
        .visual-effect {
            position: absolute;
            pointer-events: none;
            z-index: 8;
        }

            .visual-effect.decoration {
                z-index: 2;
            }

            .visual-effect img {
                max-width: 100%;
                max-height: 100%;
            }

            .visual-effect.loop img {
                animation: none;
            }

            .visual-effect.once img {
                animation: playOnce forwards;
            }

        @keyframes playOnce {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }
        /* Quick Slot Assignment Modal */
        .quick-slot-modal {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 20px;
            min-width: 400px;
            max-width: 600px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .quick-slot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .quick-slot-option {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }

            .quick-slot-option:hover {
                background: rgba(59, 130, 246, 0.2);
                transform: scale(1.05);
            }

            .quick-slot-option.selected {
                background: rgba(251, 191, 36, 0.2);
                border-color: #fbbf24;
            }
        /* Action Display */
        .action-display {
            position: fixed;
            top: 60px;
            right: 20px;
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 2px solid;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1500;
            animation: slideIn 0.3s ease-out;
            min-width: 250px;
        }

            .action-display.roll {
                border-color: #fbbf24;
            }

            .action-display.damage {
                border-color: #ef4444;
            }

            .action-display.heal {
                border-color: #10b981;
            }

            .action-display.info {
                border-color: #3b82f6;
            }

            .action-display.spell {
                border-color: hsl(var(--primary-hue), 83%, 58%);
            }

            .action-display h3 {
                margin-bottom: 10px;
                font-size: 14px;
            }

            .action-display.roll h3 {
                color: #fbbf24;
            }

            .action-display.damage h3 {
                color: #ef4444;
            }

            .action-display.heal h3 {
                color: #10b981;
            }

            .action-display.info h3 {
                color: #3b82f6;
            }

            .action-display.spell h3 {
                color: hsl(var(--primary-hue), 83%, 58%);
            }

        .action-breakdown {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 5px;
        }
        /* Enhanced Item Details Panel */
        .item-property-group {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border: 1px solid #374151;
        }

            .item-property-group h4 {
                color: #fbbf24;
                margin-bottom: 10px;
                font-size: 14px;
            }

        .property-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .property-label {
            color: #9ca3af;
            font-size: 12px;
            font-weight: 600;
        }

        .property-input {
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            font-size: 12px;
            width: 150px;
        }

        .sound-field {
            width: 100%;
            padding: 6px 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            margin-top: 5px;
        }

        .effect-field {
            width: 100%;
            padding: 6px 10px;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <!-- Tab Navigation -->
    <div class="tab-container">
        <button class="tab active" onclick="switchTab(event, 'combat')">⚔️ Combat Board</button>
        <button class="tab" onclick="switchTab(event, 'characters')">👤 Character Sheets</button>
        <button class="tab" onclick="switchTab(event, 'backgrounds')">🖼️ Backgrounds</button>
        <button class="tab" onclick="switchTab(event, 'media')">🎵 Saved Media</button>
        <button class="tab" onclick="switchTab(event, 'import-export')">📁 Import/Export</button>
        <button class="tab" onclick="switchTab(event, 'customization')">🎨 Customization</button>
        <button class="tab" onclick="openConversationManager()">💬 Conversation Manager</button>
    </div>
  
    <!-- Combat Board Tab -->
    <div id="combat-tab" class="tab-content active">
        <div class="combat-container">
            <!-- Sidebar -->
            <div class="sidebar">
                <h2><img src="" id="combatHeaderLogo" style="max-width: 400px; max-height: 160px; display: none;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"><span id="combatHeaderText" style="display: block;">⚔️ Combat Control</span></h2>

                <!-- Quick Add Section -->
                <div class="section">
                    <div class="section-title">Quick Add</div>
                    <button class="btn btn-primary" onclick="game.addPlayerCharacter()">
                        🛡️ Add Player Character
                    </button>
                    <button class="btn btn-primary" onclick="game.addNPC()">
                        🤖 Add NPC
                    </button>
                    <button class="btn btn-primary" onclick="game.addMonster()">
                        👹 Add Monster
                    </button>
                    <button class="btn btn-primary" onclick="game.addItem()">
                        📦 Add Item
                    </button>
                    <button class="btn btn-primary" onclick="game.addChest()">
                        🗃️ Add Chest
                    </button>
                    <button class="btn btn-primary" onclick="game.addVisualEffect()">
                        ✨ Add Visual Effect
                    </button>
                    <div class="section-title" style="margin-top: 15px;">Quick Slots</div>
                    <div class="quick-add-grid" id="quickAddGrid"></div>
                    <button class="btn btn-warning btn-small" onclick="game.customizeQuickSlots()">
                        ⚙️ Customize Quick Slots
                    </button>
                </div>

                <!-- Dice Rolls Section -->
                <div class="section">
                    <div class="section-title">Dice Rolls</div>
                    <div class="dice-grid">
                        <button class="dice-btn" onclick="game.rollDice('1d20')">d20</button>
                        <button class="dice-btn" onclick="game.rollDice('1d4')">1d4</button>
                        <button class="dice-btn" onclick="game.rollDice('1d6')">1d6</button>
                        <button class="dice-btn" onclick="game.rollDice('1d8')">1d8</button>
                        <button class="dice-btn" onclick="game.rollDice('1d10')">1d10</button>
                        <button class="dice-btn" onclick="game.rollDice('1d12')">1d12</button>
                        <button class="dice-btn" onclick="game.rollDice('2d6')">2d6</button>
                        <button class="dice-btn" onclick="game.rollDice('1d20+5')">d20+5</button>
                        <button class="dice-btn" onclick="game.rollDice('1d20-1')">d20-1</button>
                    </div>
                </div>

                <!-- Turn Order Section -->
                <div class="section">
                    <div class="section-title">Turn Order</div>
                    <div class="turn-order" id="turnOrder"></div>
                    <button class="btn btn-success" onclick="game.nextTurn()">▶️ Next Turn</button>
                    <button class="btn btn-warning" onclick="game.endTurn()">⏸️ End Current Turn</button>
                    <button class="btn btn-danger" onclick="game.rollInitiative()">🎲 Roll Initiative</button>
                </div>
                <!-- Rests Section -->
                <div class="section">
                    <div class="section-title">Rests</div>
                    <button class="btn btn-primary" onclick="game.shortRest()">Short Rest</button>
                    <button class="btn btn-primary" onclick="game.longRest()">Long Rest</button>
                </div>

                <!-- Settings Section -->
                <div class="section">
                    <div class="section-title">Settings</div>
                    <button class="btn toggle-btn active" id="gridToggle" onclick="game.toggleGrid()">
                        <div class="toggle-switch"></div>
                        Show Grid
                    </button>
                    <button class="btn toggle-btn" id="turnToggle" onclick="game.toggleTurnEnforcement()">
                        <div class="toggle-switch"></div>
                        Enforce Turns
                    </button>
                    <button class="btn toggle-btn" id="movementToggle" onclick="game.toggleMovementRange()">
                        <div class="toggle-switch"></div>
                        Show Movement Range
                    </button>
                    <button class="btn toggle-btn" id="editToggle" onclick="game.toggleEditMode()">
                        <div class="toggle-switch"></div>
                        Edit Mode
                    </button>
                    <button class="btn toggle-btn" id="drawToggle" onclick="game.toggleDrawMode()">
                        <div class="toggle-switch"></div>
                        Draw Mode
                    </button>
                    <input type="text" class="input-field" id="bgUrl" placeholder="Background Image URL" onchange="game.changeBackground()">

                    <div class="section-title">Drawing Tools</div>
                    <button class="btn btn-danger" id="eraseToggle" onclick="game.toggleEraseMode()">
                        🧽 Erase Mode
                    </button>
                    <button class="btn btn-warning" onclick="game.clearDrawing()">
                        🗑️ Clear Drawing
                    </button>

                    <div class="section-title">Background Music</div>
                    <input type="file" id="backgroundMusicFile" accept="audio/mp3,audio/mp4,video/mp4" onchange="game.setBackgroundMusicFromFile(this.files[0])">
                    <input type="text" class="sound-input" id="backgroundMusic" placeholder="Background Music URL or File" onchange="game.setBackgroundMusic(this.value)">
                    <div class="music-controls">
                        <button class="music-btn" id="playBtn" onclick="game.playBackgroundMusic()">▶️ Play</button>
                        <button class="music-btn" id="pauseBtn" onclick="game.pauseBackgroundMusic()">⏸️ Pause</button>
                        <button class="music-btn" id="bgmModeBtn" onclick="game.toggleBGMMode()">Mode: Loop</button>
                    </div>
                </div>
                
                <div style="margin-top: 10px;">
                    <label style="color: #9ca3af; font-size: 12px; display: block; margin-bottom: 5px;">Volume</label>
                    <input type="range" min="0" max="100" value="30" id="bgmVolume" oninput="game.setVolume(this.value)" style="width: 100%;">
                    <div style="text-align: center; color: #9ca3af; font-size: 11px; margin-top: 3px;"><span id="volumeDisplay">30</span>%</div>
                </div>

                <!-- Combat Log Section -->
                <div class="section">
                    <div class="section-title">Combat Log</div>
                    <div class="combat-log" id="combatLog">
                        <div class="log-entry info">Ready for combat...</div>
                    </div>
                </div>

                <!-- Game Controls -->
                <div class="section">
                    <div class="section-title">Game Controls</div>
                    <button class="btn btn-primary" onclick="game.saveGameState()">💾 Save Game</button>
                    <button class="btn btn-primary" onclick="game.loadGameState()">📂 Load Game</button>
                    <button class="btn btn-danger" onclick="game.clearBoard()">🗑️ Clear Board</button>
                    <button class="btn btn-primary" onclick="game.resetView()">🔍 Reset View</button>
                </div>
            </div>
          
            <!-- Game Board -->
            <div class="game-board" id="gameBoard">
                <div class="board-container" id="boardContainer">
                    <svg class="grid-overlay" id="gridOverlay">
                        <defs>
                            <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                                <path d="M 50 0 L 0 0 0 50" fill="none" stroke="white" stroke-width="1"/>
                            </pattern>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#grid)"/>
                    </svg>
                    <canvas class="drawing-canvas" id="drawingCanvas"></canvas>
                    <div class="board-canvas" id="boardCanvas"></div>
                </div>
            </div>
        </div>
    </div>
  
    <!-- Expandable Library Sidebar -->
    <button class="library-sidebar-toggle" id="libraryToggle" onclick="game.toggleLibrarySidebar()">
        📚 Library
    </button>
  
    <div class="expandable-library-sidebar" id="expandableLibrarySidebar">
        <div class="expandable-library-header">
            <h3 style="color: #fbbf24; margin: 0;">📚 Content Library</h3>
            <button class="close-btn" onclick="game.toggleLibrarySidebar()" style="position: static;">✕</button>
        </div>
        <div class="expandable-library-content">
            <input type="text" class="search-bar" id="sidebarLibrarySearch" placeholder="Search library..." onkeyup="game.searchSidebarLibrary(this.value)">
          
            <div class="expandable-library-filters">
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('all')">All</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('player')">Players</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('monster')">Monsters</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('spell')">Spells</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('item')">Items</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('equipment')">Equipment</button>
                <button class="btn btn-small" onclick="game.filterSidebarLibrary('sfx')">SFX</button>
            </div>
          
            <div class="section-title">Content Management</div>
            <button class="btn btn-primary" onclick="game.showMonsterEditor()">Create Monster</button>
            <button class="btn btn-primary" onclick="game.showSpellEditor()">Create Spell</button>
            <button class="btn btn-primary" onclick="game.showItemEditor()">Create Item</button>
            <button class="btn btn-primary" onclick="game.showEquipmentEditor()">Create Equipment</button>
            <button class="btn btn-primary" onclick="game.showSFXEditor()">Upload SFX</button>
          
            <button class="btn btn-primary" style="margin-top: 15px;" onclick="game.saveCurrentEntity()">
                💾 Save Selected Entity
            </button>
          
            <div class="content-grid" id="sidebarLibraryGrid"></div>
        </div>
    </div>
  
    <!-- Character Sheets Tab -->
    <div id="characters-tab" class="tab-content">
        <div class="character-sheet">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">👤 Character Sheets</h2>
            <div class="character-list" id="characterList"></div>
            <div style="margin-top: 20px; text-align: center;">
                <input type="file" id="pdfImport" accept="application/pdf" onchange="game.importCharacterPDF(this.files[0])" style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('pdfImport').click()">
                    Import D&D Beyond PDF
                </button>
            </div>
            <div class="sheet-content" id="sheetContent" style="display: none;"></div>
        </div>
    </div>
  
    <!-- Backgrounds Tab -->
    <div id="backgrounds-tab" class="tab-content">
        <div class="backgrounds-container">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">🖼️ Saved Backgrounds</h2>
            <input type="text" class="input-field" id="newBgUrl" placeholder="New Background URL">
            <button class="btn btn-primary" onclick="game.saveBackground()">Save Background</button>
            <div class="background-list" id="backgroundList"></div>
        </div>
    </div>
  
    <!-- Saved Media Tab -->
    <div id="media-tab" class="tab-content">
        <div style="padding: 20px; height: 100%; overflow-y: auto; background: hsl(var(--background-hue), 33%, 6%);">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">🎵 Saved Media</h2>
          
            <div class="section">
                <div class="section-title">SFX</div>
                <input type="text" class="input-field" id="newSfxUrl" placeholder="SFX URL">
                <button class="btn btn-primary" onclick="game.saveMedia(document.getElementById('newSfxUrl').value, 'sfx')">Save SFX URL</button>
                <input type="file" accept="audio/*" onchange="game.saveMediaFromFile(this.files[0], 'sfx')">
                <div class="item-list" id="sfxList"></div>
            </div>
          
            <div class="section">
                <div class="section-title">VFX</div>
                <input type="text" class="input-field" id="newVfxUrl" placeholder="VFX URL (image/GIF)">
                <button class="btn btn-primary" onclick="game.saveMedia(document.getElementById('newVfxUrl').value, 'vfx')">Save VFX URL</button>
                <input type="file" accept="image/*" onchange="game.saveMediaFromFile(this.files[0], 'vfx')">
                <div class="item-list" id="vfxList"></div>
            </div>
          
            <div class="section">
                <div class="section-title">BGM</div>
                <input type="text" class="input-field" id="newBgmUrl" placeholder="BGM URL">
                <button class="btn btn-primary" onclick="game.saveMedia(document.getElementById('newBgmUrl').value, 'bgm')">Save BGM URL</button>
                <input type="file" accept="audio/*,video/mp4" onchange="game.saveMediaFromFile(this.files[0], 'bgm')">
                <div class="item-list" id="bgmList"></div>
            </div>
        </div>
    </div>
  
    <!-- Import/Export Tab -->
    <div id="import-export-tab" class="tab-content">
        <div style="padding: 40px;">
            <h2 style="color: #fbbf24; margin-bottom: 30px;">📁 Import/Export Content</h2>
          
            <div style="margin-bottom: 30px;">
                <h3 style="margin-bottom: 15px;">Export Library</h3>
                <button class="btn btn-primary" onclick="game.exportLibrary()">Export to JSON</button>
                <textarea class="textarea-large" id="exportData" readonly placeholder="Exported data will appear here..."></textarea>
            </div>
          
            <div>
                <h3 style="margin-bottom: 15px;">Import Library</h3>
                <textarea class="textarea-large" id="importData" placeholder="Paste JSON data here..."></textarea>
                <button class="btn btn-success" onclick="game.importLibrary()">Import from JSON</button>
            </div>
        </div>
    </div>

    <!-- Customization Tab -->
    <div id="customization-tab" class="tab-content">
        <div style="padding: 20px; height: 100%; overflow-y: auto; background: hsla(var(--background-hue), 33%, 6%, 0.85);">
            <h2 style="color: #fbbf24; margin-bottom: 20px;">🎨 UI Customization</h2>

            <div class="section">
                <div class="section-title">UI Hue Shift</div>
                <input type="range" min="0" max="360" value="262" id="hueSlider" oninput="game.setUIHue(this.value)" style="width: 100%;">
                <p style="text-align: center; color: #9ca3af; margin-top: 10px;">Current hue: <span id="currentHue">262</span>° (Default Purple)</p>
            </div>

            <div class="section">
                <div class="section-title">Background Hue Shift</div>
                <input type="range" min="0" max="360" value="240" id="backgroundHueSlider" oninput="game.setBackgroundHue(this.value)" style="width: 100%;">
                <p style="text-align: center; color: #9ca3af; margin-top: 10px;">Current background hue: <span id="currentBackgroundHue">240</span>° (Default Blue)</p>
            </div>

            <div class="section">
                <div class="section-title">Combat Header Logo</div>
                <input type="text" class="input-field" id="headerLogoUrl" placeholder="Logo image URL (transparent PNG recommended)" onchange="game.setHeaderLogo(this.value)">
                <input type="file" accept="image/*" id="headerLogoFile" onchange="game.uploadHeaderLogo(this.files[0])" style="width: 100%; margin-top: 10px;">
                <button class="btn btn-danger btn-small" onclick="game.clearHeaderLogo()" style="margin-top: 10px;">Clear Logo</button>
            </div>

            <div class="section">
                <div class="section-title">UI Background Image</div>
                <input type="text" class="input-field" id="uiBackgroundUrl" placeholder="Background image URL" onchange="game.setUIBackground(this.value)">
                <input type="file" accept="image/*" id="uiBackgroundFile" onchange="game.uploadUIBackground(this.files[0])" style="width: 100%; margin-top: 10px;">

                <div class="section-title" style="margin-top: 15px;">Background Opacity</div>
                <input type="range" min="0" max="100" value="20" id="bgOpacitySlider" oninput="game.setUIBackgroundOpacity(this.value)" style="width: 100%;">
                <p style="text-align: center; color: #9ca3af; margin-top: 10px;">Current opacity: <span id="currentBgOpacity">20</span>%</p>
            </div>

            <div class="section">
                <div class="section-title">UI Font</div>
                <div id="fontDropdownContainer"></div>
                <div style="margin-top: 10px;">
                    <input type="file" accept=".otf,.ttf" id="customFontUpload" onchange="game.uploadCustomFont(this.files[0])" style="width: 100%;">
                </div>
            </div>
        </div>
    </div>
  
    <script>
        // Complete DND 5e Game System - Professional Edition
        const game = {
            // Core Game State
            entities: [],
            selectedEntity: null,
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            lastPanX: 0,
            lastPanY: 0,
            currentTurn: 0,
            turnOrder: [],
            showGrid: true,
            showMovementRange: false,
            enforceTurns: false,
            editMode: false,
            drawMode: false,
            eraseMode: false,
            targetingMode: null,
            draggingEntity: null,
            dragStartPos: null,
            nextId: 1,
            gameNotes: '',
            diceRollHistory: [],
            roundNumber: 1,
            dragArrow: null,
            persistentArrow: null,
            backgroundUrl: '',
            savedBackgrounds: [],
            sounds: {
                heal: '',
                attack: '',
                spell: '',
                open: ''
            },
            backgroundMusic: {
                url: '',
                audio: null,
                isPlaying: false,
                mode: 'loop',
                currentIndex: 0,
                audios: []
            },
          
            // Drawing
            isDrawing: false,
            lastDrawX: 0,
            lastDrawY: 0,
            drawingCanvas: null,
            drawingCtx: null,
          
            // Library Sidebar
            librarySidebarOpen: false,
          
            // Quick Slots System
            quickSlots: [],
          
            // Visual Effects
            visualEffects: [],
          
            // Action Economy State
            currentTurnActions: {
                movement: 0,
                action: false,
                bonusAction: false,
                reaction: true
            },
          
            // Enhanced D&D 5e Classes and Races Lists
            classList: [
                'Artificer', 'Barbarian', 'Bard', 'Cleric', 'Druid', 'Fighter',
                'Monk', 'Paladin', 'Ranger', 'Rogue', 'Sorcerer', 'Warlock', 'Wizard',
                'Blood Hunter', 'Mystic', 'Custom'
            ],
          
            raceList: [
                'Aarakocra', 'Aasimar', 'Bugbear', 'Centaur', 'Changeling', 'Dragonborn',
                'Dwarf', 'Elf', 'Bugbear', 'Firbolg', 'Genasi', 'Githyanki', 'Githzerai', 'Gnome',
                'Goblin', 'Goliath', 'Half-Elf', 'Halfling', 'Half-Orc', 'Hobgoblin',
                'Human', 'Kalashtar', 'Kenku', 'Kobold', 'Lizardfolk', 'Loxodon',
                'Minotaur', 'Orc', 'Shifter', 'Simic Hybrid', 'Tabaxi', 'Tiefling',
                'Tortle', 'Triton', 'Vedalken', 'Warforged', 'Yuan-ti Pureblood', 'Custom'
            ],
          
            // Base Combat Actions
            baseCombatActions: [
                {
                    name: 'Unarmed Strike',
                    type: 'attack',
                    actionType: 'action',
                    toHit: 0,
                    damage: '1',
                    damageType: 'bludgeoning',
                    range: 5,
                    description: 'Make an unarmed attack using Strength',
                    soundEffect: ''
                },
                {
                    name: 'Shove',
                    type: 'special',
                    actionType: 'action',
                    description: 'Shove a creature prone or push it 5 feet away',
                    effect: 'shove',
                    soundEffect: ''
                },
                {
                    name: 'Grapple',
                    type: 'special',
                    actionType: 'action',
                    description: 'Attempt to grapple a creature',
                    effect: 'grapple',
                    soundEffect: ''
                },
                {
                    name: 'Hide',
                    type: 'skill',
                    actionType: 'action',
                    description: 'Make a Dexterity (Stealth) check to hide',
                    skill: 'stealth',
                    soundEffect: ''
                },
                {
                    name: 'Dash',
                    type: 'movement',
                    actionType: 'action',
                    description: 'Double your movement speed this turn',
                    effect: 'dash',
                    soundEffect: ''
                },
                {
                    name: 'Disengage',
                    type: 'movement',
                    actionType: 'action',
                    description: 'Move without provoking opportunity attacks',
                    effect: 'disengage',
                    soundEffect: ''
                },
                {
                    name: 'Dodge',
                    type: 'defense',
                    actionType: 'action',
                    description: 'Focus on avoiding attacks',
                    effect: 'dodge',
                    soundEffect: ''
                },
                {
                    name: 'Help',
                    type: 'support',
                    actionType: 'action',
                    description: 'Help an ally with their next ability check or attack',
                    effect: 'help',
                    soundEffect: ''
                },
                {
                    name: 'Ready',
                    type: 'special',
                    actionType: 'action',
                    description: 'Prepare an action to trigger on a condition',
                    effect: 'ready',
                    soundEffect: ''
                },
                {
                    name: 'Search',
                    type: 'skill',
                    actionType: 'action',
                    description: 'Make a Wisdom (Perception) or Intelligence (Investigation) check',
                    skill: 'perception',
                    soundEffect: ''
                }
            ],
          
            // Comprehensive Content Library
            library: {
                monsters: [
                    {
                        name: 'Goblin',
                        type: 'monster',
                        hp: 7, maxHp: 7, maxHp: 7, ac: 15, speed: 30,
                        str: 8, dex: 14, con: 10, int: 10, wis: 8, cha: 8,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Scimitar', toHit: 4, damage: '1d6+2', damageType: 'slashing', range: 5, soundEffect: '', visualEffect: ''}],
                        abilities: [{name: 'Nimble Escape', description: 'Disengage or Hide as bonus action', actionType: 'bonus', soundEffect: '', visualEffect: ''}],
                        skills: {stealth: 6},
                        savingThrows: {str: -1, dex: 2, con: 0, int: 0, wis: -1, cha: -1},
                        color: '#4a7c59',
                        cr: 0.25,
                        description: 'Small green-skinned humanoid, sneaky and aggressive.',
                        image: '',
                        soundEffect: '',
                        visualEffect: '',
                        baseActions: [
                            {
                                name: 'Unarmed Strike',
                                type: 'attack',
                                actionType: 'action',
                                toHit: 0,
                                damage: '1',
                                damageType: 'bludgeoning',
                                range: 5,
                                description: 'Make an unarmed attack using Strength',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Shove',
                                type: 'special',
                                actionType: 'action',
                                description: 'Shove a creature prone or push it 5 feet away',
                                effect: 'shove',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Grapple',
                                type: 'special',
                                actionType: 'action',
                                description: 'Attempt to grapple a creature',
                                effect: 'grapple',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Hide',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Dexterity (Stealth) check to hide',
                                skill: 'stealth',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dash',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Double your movement speed this turn',
                                effect: 'dash',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Disengage',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Move without provoking opportunity attacks',
                                effect: 'disengage',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dodge',
                                type: 'defense',
                                actionType: 'action',
                                description: 'Focus on avoiding attacks',
                                effect: 'dodge',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Help',
                                type: 'support',
                                actionType: 'action',
                                description: 'Help an ally with their next ability check or attack',
                                effect: 'help',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Ready',
                                type: 'special',
                                actionType: 'action',
                                description: 'Prepare an action to trigger on a condition',
                                effect: 'ready',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Search',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Wisdom (Perception) or Intelligence (Investigation) check',
                                skill: 'perception',
                                soundEffect: '',
                                visualEffect: ''
                            }
                        ]
                    },
                    {
                        name: 'Orc',
                        type: 'monster',
                        hp: 15, maxHp: 15, ac: 13, speed: 30,
                        str: 16, dex: 12, con: 16, int: 7, wis: 11, cha: 10,
                        proficiencyBonus: 2,
                        attacks: [{name: 'Greataxe', toHit: 5, damage: '1d12+3', damageType: 'slashing', range: 5, soundEffect: '', visualEffect: ''}],
                        abilities: [{name: 'Aggressive', description: 'Bonus action to move up to speed toward enemy', actionType: 'bonus', soundEffect: '', visualEffect: ''}],
                        skills: {intimidation: 2},
                        savingThrows: {str: 3, dex: 1, con: 3, int: -2, wis: 0, cha: 0},
                        color: '#8b4513',
                        cr: 0.5,
                        description: 'Savage humanoid warrior with gray skin and tusks.',
                        image: '',
                        soundEffect: '',
                        visualEffect: '',
                        baseActions: [
                            {
                                name: 'Unarmed Strike',
                                type: 'attack',
                                actionType: 'action',
                                toHit: 0,
                                damage: '1',
                                damageType: 'bludgeoning',
                                range: 5,
                                description: 'Make an unarmed attack using Strength',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Shove',
                                type: 'special',
                                actionType: 'action',
                                description: 'Shove a creature prone or push it 5 feet away',
                                effect: 'shove',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Grapple',
                                type: 'special',
                                actionType: 'action',
                                description: 'Attempt to grapple a creature',
                                effect: 'grapple',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Hide',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Dexterity (Stealth) check to hide',
                                skill: 'stealth',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dash',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Double your movement speed this turn',
                                effect: 'dash',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Disengage',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Move without provoking opportunity attacks',
                                effect: 'disengage',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dodge',
                                type: 'defense',
                                actionType: 'action',
                                description: 'Focus on avoiding attacks',
                                effect: 'dodge',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Help',
                                type: 'support',
                                actionType: 'action',
                                description: 'Help an ally with their next ability check or attack',
                                effect: 'help',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Ready',
                                type: 'special',
                                actionType: 'action',
                                description: 'Prepare an action to trigger on a condition',
                                effect: 'ready',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Search',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Wisdom (Perception) or Intelligence (Investigation) check',
                                skill: 'perception',
                                soundEffect: '',
                                visualEffect: ''
                            }
                        ]
                    },
                    {
                        name: 'Mimic',
                        type: 'monster',
                        hp: 58, maxHp: 58, ac: 12, speed: 15,
                        str: 17, dex: 12, con: 15, int: 5, wis: 13, cha: 8,
                        proficiencyBonus: 2,
                        attacks: [
                            {name: 'Pseudopod', toHit: 5, damage: '1d8+3', damageType: 'bludgeoning', range: 5, soundEffect: '', visualEffect: ''},
                            {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing', range: 5, special: 'Grapples target (escape DC 13)', soundEffect: '', visualEffect: ''}
                        ],
                        abilities: [
                            {name: 'Shapechanger', description: 'Can polymorph into object', actionType: 'action', soundEffect: '', visualEffect: ''},
                            {name: 'Adhesive', description: 'Adheres to anything that touches it', actionType: 'passive', soundEffect: '', visualEffect: ''}
                        ],
                        skills: {stealth: 5},
                        savingThrows: {str: 3, dex: 1, con: 2, int: -3, wis: 1, cha: -1},
                        color: '#8B4513',
                        cr: 2,
                        isMimic: true,
                        description: 'Shapeshifting predator that mimics objects.',
                        image: '',
                        soundEffect: '',
                        visualEffect: '',
                        baseActions: [
                            {
                                name: 'Unarmed Strike',
                                type: 'attack',
                                actionType: 'action',
                                toHit: 0,
                                damage: '1',
                                damageType: 'bludgeoning',
                                range: 5,
                                description: 'Make an unarmed attack using Strength',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Shove',
                                type: 'special',
                                actionType: 'action',
                                description: 'Shove a creature prone or push it 5 feet away',
                                effect: 'shove',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Grapple',
                                type: 'special',
                                actionType: 'action',
                                description: 'Attempt to grapple a creature',
                                effect: 'grapple',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Hide',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Dexterity (Stealth) check to hide',
                                skill: 'stealth',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dash',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Double your movement speed this turn',
                                effect: 'dash',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Disengage',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Move without provoking opportunity attacks',
                                effect: 'disengage',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dodge',
                                type: 'defense',
                                actionType: 'action',
                                description: 'Focus on avoiding attacks',
                                effect: 'dodge',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Help',
                                type: 'support',
                                actionType: 'action',
                                description: 'Help an ally with their next ability check or attack',
                                effect: 'help',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Ready',
                                type: 'special',
                                actionType: 'action',
                                description: 'Prepare an action to trigger on a condition',
                                effect: 'ready',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Search',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Wisdom (Perception) or Intelligence (Investigation) check',
                                skill: 'perception',
                                soundEffect: '',
                                visualEffect: ''
                            }
                        ]
                    }
                ],
                spells: [
                    {
                        name: 'Fireball',
                        type: 'spell',
                        level: 3,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 150,
                        components: 'V, S, M',
                        duration: 'instantaneous',
                        damage: '8d6',
                        damageType: 'fire',
                        savingThrow: 'dexterity',
                        saveDC: 15,
                        aoe: '20-foot radius sphere',
                        description: 'Each creature in a 20-foot-radius sphere must make a Dexterity saving throw. Takes 8d6 fire damage on failed save, half on success.',
                        higherLevel: 'Additional 1d6 damage per spell slot above 3rd',
                        image: '',
                        soundEffect: '',
                        visualEffect: '',
                        visualPattern: 'onEntity'
                    },
                    {
                        name: 'Cure Wounds',
                        type: 'spell',
                        level: 1,
                        school: 'evocation',
                        castingTime: 'action',
                        range: 'touch',
                        components: 'V, S',
                        duration: 'instantaneous',
                        healing: '1d8+3',
                        description: 'A creature you touch regains 1d8 + spellcasting modifier hit points.',
                        higherLevel: 'Additional 1d8 healing per spell slot above 1st',
                        image: '',
                        soundEffect: '',
                        visualEffect: '',
                        visualPattern: 'onEntity'
                    }
                ],
                items: [
                    {
                        name: 'Healing Potion',
                        type: 'potion',
                        rarity: 'common',
                        healing: '2d4+2',
                        value: 50,
                        weight: 0.5,
                        description: 'Regain 2d4+2 hit points when consumed.',
                        consumable: true,
                        image: '',
                        soundEffect: '',
                        visualEffect: ''
                    },
                    {
                        name: 'Chest',
                        type: 'container',
                        inventory: [],
                        isMimic: false,
                        value: 0,
                        weight: 25,
                        description: 'A wooden chest that can hold items.',
                        image: '',
                        soundEffect: '',
                        visualEffect: ''
                    }
                ],
                equipment: [
                    {
                        name: 'Leather Armor',
                        type: 'armor',
                        armorType: 'light',
                        ac: 11,
                        maxDexBonus: null,
                        stealthDisadvantage: false,
                        weight: 10,
                        value: 10,
                        equipSlot: 'armor',
                        description: 'Light armor. AC = 11 + Dex modifier.',
                        image: '',
                        soundEffect: '',
                        visualEffect: ''
                    },
                    {
                        name: 'Longsword',
                        type: 'weapon',
                        weaponType: 'martial',
                        damage: '1d8',
                        damageType: 'slashing',
                        properties: ['versatile (1d10)'],
                        value: 15,
                        weight: 3,
                        equipSlot: 'mainHand',
                        attackBonus: 0,
                        damageBonus: 0,
                        description: 'Versatile martial weapon.',
                        image: '',
                        soundEffect: '',
                        visualEffect: ''
                    }
                ],
                players: [
                    {
                        name: 'Fighter',
                        type: 'player',
                        hp: 10, maxHp: 10, ac: 10, speed: 30,
                        str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10,
                        proficiencyBonus: 2,
                        attacks: [],
                        abilities: [],
                        skills: {},
                        savingThrows: {str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0},
                        color: '#3b82f6',
                        description: 'Standard fighter template.',
                        image: '',
                        soundEffect: '',
                        visualEffect: '',
                        baseActions: [
                            {
                                name: 'Unarmed Strike',
                                type: 'attack',
                                actionType: 'action',
                                toHit: 0,
                                damage: '1',
                                damageType: 'bludgeoning',
                                range: 5,
                                description: 'Make an unarmed attack using Strength',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Shove',
                                type: 'special',
                                actionType: 'action',
                                description: 'Shove a creature prone or push it 5 feet away',
                                effect: 'shove',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Grapple',
                                type: 'special',
                                actionType: 'action',
                                description: 'Attempt to grapple a creature',
                                effect: 'grapple',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Hide',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Dexterity (Stealth) check to hide',
                                skill: 'stealth',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dash',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Double your movement speed this turn',
                                effect: 'dash',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Disengage',
                                type: 'movement',
                                actionType: 'action',
                                description: 'Move without provoking opportunity attacks',
                                effect: 'disengage',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Dodge',
                                type: 'defense',
                                actionType: 'action',
                                description: 'Focus on avoiding attacks',
                                effect: 'dodge',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Help',
                                type: 'support',
                                actionType: 'action',
                                description: 'Help an ally with their next ability check or attack',
                                effect: 'help',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Ready',
                                type: 'special',
                                actionType: 'action',
                                description: 'Prepare an action to trigger on a condition',
                                effect: 'ready',
                                soundEffect: '',
                                visualEffect: ''
                            },
                            {
                                name: 'Search',
                                type: 'skill',
                                actionType: 'action',
                                description: 'Make a Wisdom (Perception) or Intelligence (Investigation) check',
                                skill: 'perception',
                                soundEffect: '',
                                visualEffect: ''
                            }
                        ]
                    }
                ],
                sfx: [],
                vfx: [],
                bgm: []
            },
          
            // Skills list for D&D 5e
            skillsList: {
                acrobatics: 'dex',
                animalHandling: 'wis',
                arcana: 'int',
                athletics: 'str',
                deception: 'cha',
                history: 'int',
                insight: 'wis',
                intimidation: 'cha',
                investigation: 'int',
                medicine: 'wis',
                nature: 'int',
                perception: 'wis',
                performance: 'cha',
                persuasion: 'cha',
                religion: 'int',
                sleightOfHand: 'dex',
                stealth: 'dex',
                survival: 'wis'
            },
          
            // All D&D 5e Conditions
            conditions: {
                blinded: {
                    description: 'Cannot see. Auto-fail sight checks. Disadvantage on attacks. Advantage on attacks against.',
                    effects: {attackDisadvantage: true, defenseAdvantage: true}
                },
                charmed: {
                    description: 'Cannot attack charmer. Charmer has advantage on social checks.',
                    effects: {}
                },
                deafened: {
                    description: 'Cannot hear. Auto-fail hearing checks.',
                    effects: {}
                },
                exhaustion: {
                    description: 'Multiple levels with cumulative effects.',
                    levels: [
                        'Disadvantage on ability checks',
                        'Speed halved',
                        'Disadvantage on attacks and saves',
                        'HP maximum halved',
                        'Speed reduced to 0',
                        'Death'
                    ]
                },
                frightened: {
                    description: 'Disadvantage on ability checks and attacks while source in sight. Cannot willingly move closer.',
                    effects: {attackDisadvantage: true}
                },
                grappled: {
                    description: 'Speed becomes 0. Ends if grappler incapacitated.',
                    effects: {speed: 0}
                },
                incapacitated: {
                    description: 'Cannot take actions or reactions.',
                    effects: {noActions: true, noReactions: true}
                },
                invisible: {
                    description: 'Cannot be seen. Advantage on attacks. Disadvantage on attacks against.',
                    effects: {attackAdvantage: true, defenseDisadvantage: true}
                },
                paralyzed: {
                    description: 'Incapacitated, cannot move or speak. Auto-fail Str and Dex saves. Attacks have advantage. Attacks within 5ft are crits.',
                    effects: {noActions: true, noReactions: true, speed: 0, attackDisadvantage: true, defenseAdvantage: true, autoFailSaves: ['str', 'dex']}
                },
                petrified: {
                    description: 'Transformed to stone. Incapacitated. Resistance to all damage. Immune to poison and disease.',
                    effects: {noActions: true, noReactions: true, speed: 0, damageResistance: 'all', immunities: ['poison', 'disease']}
                },
                poisoned: {
                    description: 'Disadvantage on attack rolls and ability checks.',
                    effects: {attackDisadvantage: true, checkDisadvantage: true}
                },
                prone: {
                    description: 'Disadvantage on attacks. Attacks within 5ft have advantage, beyond have disadvantage. Half movement to stand.',
                    effects: {attackDisadvantage: true, meleeDefenseAdvantage: true, rangedDefenseDisadvantage: true}
                },
                restrained: {
                    description: 'Speed 0. Disadvantage on attacks and Dex saves. Advantage on attacks against.',
                    effects: {speed: 0, attackDisadvantage: true, defenseAdvantage: true, saveDisadvantage: ['dex']}
                },
                stunned: {
                    description: 'Incapacitated, cannot move, speak falteringly. Auto-fail Str and Dex saves. Attacks have advantage.',
                    effects: {noActions: true, noReactions: true, speed: 0, defenseAdvantage: true, autoFailSaves: ['str', 'dex']}
                },
                unconscious: {
                    description: 'Incapacitated, cannot move or speak, unaware. Drop items, fall prone. Auto-fail Str and Dex saves. Attacks have advantage. Hits within 5ft are crits.',
                    effects: {noActions: true, noReactions: true, speed: 0, prone: true, defenseAdvantage: true, autoFailSaves: ['str', 'dex'], meleeCritical: true}
                },
                hidden: {
                    description: 'Hidden from view.',
                    effects: {}
                }
            },
          
            // Initialize the game
            init() {
                this.loadGameState();
                this.loadLibrary();
                this.loadSounds();
                this.loadSavedBackgrounds();
                this.loadQuickSlots();
                this.setupDrawingCanvas();
                this.setupEventListeners();
                this.setupQuickAdd();
                this.populateLibrarySidebar();
                this.render();
                this.updateTurnOrder();
                this.loadCustomFonts();
              
                // Add starting entities if none exist
                if (this.entities.length === 0) {
                    this.entities.push(this.createEntity('player', 'Fighter', 200, 300));
                    this.entities.push(this.createEntity('monster', 'Goblin', 500, 300));
                    this.render();
                }

                // Load customization settings
                const savedHue = localStorage.getItem('dndUIHue');
                if (savedHue) {
                    this.setUIHue(savedHue);
                }
                const savedBackgroundHue = localStorage.getItem('dndBackgroundHue');
                if (savedBackgroundHue) {
                    this.setBackgroundHue(savedBackgroundHue);
                }
                const savedFont = localStorage.getItem('dndUIFont');
                if (savedFont) {
                    this.setUIFont(savedFont);
                }
                const savedUIBg = localStorage.getItem('dndUIBackground');
                if (savedUIBg) {
                    this.setUIBackground(savedUIBg);
                    const input = document.getElementById('uiBackgroundUrl');
                    if (input) input.value = savedUIBg;
                }

                const savedOpacity = localStorage.getItem('dndUIBackgroundOpacity');
                if (savedOpacity) {
                    this.setUIBackgroundOpacity(savedOpacity);
                    const slider = document.getElementById('bgOpacitySlider');
                    if (slider) slider.value = savedOpacity;
                }
                const savedLogo = localStorage.getItem('dndHeaderLogo');
                if (savedLogo) {
                    setTimeout(() => this.setHeaderLogo(savedLogo), 100);
                }
            },
            // Quick Slots Management
            loadQuickSlots() {
                const saved = localStorage.getItem('dndQuickSlots');
                if (saved) {
                    this.quickSlots = JSON.parse(saved);
                } else {
                    // Default quick slots
                    this.quickSlots = [
                        {name: 'Goblin', type: 'monster'},
                        {name: 'Orc', type: 'monster'},
                        {name: 'Healing Potion', type: 'item'},
                        {name: 'Chest', type: 'item'}
                    ];
                }
            },
            saveQuickSlots() {
                localStorage.setItem('dndQuickSlots', JSON.stringify(this.quickSlots));
            },
            customizeQuickSlots() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="quick-slot-modal">
                        <h2>⚙️ Customize Quick Slots</h2>
                        <p>Select up to 8 items from your library to appear as quick-add buttons:</p>
                      
                        <div class="quick-slot-grid">
                            ${[...this.library.monsters, ...this.library.players, ...this.library.items, ...this.library.equipment].map(item => `
                                <div class="quick-slot-option ${this.quickSlots.some(q => q.name === item.name) ? 'selected' : ''}"
                                     onclick="game.toggleQuickSlot('${item.name}', '${item.type || (item.class ? 'player' : 'monster')}', this)">
                                    <div style="font-weight: bold;">${item.name}</div>
                                    <div style="font-size: 10px; color: #9ca3af;">${item.type || (item.class ? 'Player' : 'Monster')}</div>
                                </div>
                            `).join('')}
                        </div>
                      
                        <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn btn-danger" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.saveQuickSlotsAndClose()">Save Changes</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
            toggleQuickSlot(name, type, element) {
                const existing = this.quickSlots.findIndex(q => q.name === name);
                if (existing > -1) {
                    this.quickSlots.splice(existing, 1);
                    element.classList.remove('selected');
                } else {
                    if (this.quickSlots.length < 8) {
                        this.quickSlots.push({name, type});
                        element.classList.add('selected');
                    } else {
                        alert('Maximum 8 quick slots allowed!');
                    }
                }
            },
            saveQuickSlotsAndClose() {
                this.saveQuickSlots();
                this.setupQuickAdd();
                document.querySelector('.modal-overlay').remove();
            },
            // Visual Effects System
            addVisualEffect() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="creation-modal">
                        <h2>✨ Add Visual Effect</h2>
                        <div class="form-group">
                            <label class="form-label">Effect Name:</label>
                            <input type="text" id="effectName" placeholder="e.g., Magic Circle" class="custom-input show">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Image/GIF URL:</label>
                            <input type="text" id="effectUrl" placeholder="https://..." class="custom-input show">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Width (pixels):</label>
                            <input type="number" id="effectWidth" value="100" class="custom-input show">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Height (pixels):</label>
                            <input type="number" id="effectHeight" value="100" class="custom-input show">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Play Mode:</label>
                            <select id="effectMode" class="form-select">
                                <option value="decoration">Decoration (stays on field)</option>
                                <option value="once">Play Once (auto-remove)</option>
                                <option value="loop">Loop Continuously</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Duration (seconds, for 'once' mode):</label>
                            <input type="number" id="effectDuration" value="3" class="custom-input show">
                        </div>
                      
                        <div class="modal-buttons">
                            <button class="btn btn-danger" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createVisualEffectFromModal()">Add Effect</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
            createVisualEffectFromModal() {
                const modal = document.querySelector('.modal-overlay');
                const name = modal.querySelector('#effectName').value || 'Visual Effect';
                const url = modal.querySelector('#effectUrl').value;
                const width = parseInt(modal.querySelector('#effectWidth').value) || 100;
                const height = parseInt(modal.querySelector('#effectHeight').value) || 100;
                const mode = modal.querySelector('#effectMode').value;
                const duration = parseInt(modal.querySelector('#effectDuration').value) || 3;
                if (!url) {
                    alert('Please provide an image/GIF URL');
                    return;
                }
                const effect = {
                    id: this.nextId++,
                    name: name,
                    type: 'visualEffect',
                    x: 400 + Math.random() * 200,
                    y: 300 + Math.random() * 200,
                    url: url,
                    width: width,
                    height: height,
                    mode: mode,
                    duration: duration,
                    startTime: Date.now()
                };
                this.visualEffects.push(effect);
                this.entities.push(effect);
                this.render();
                modal.remove();
            },
            placeVFXOnBoard(url, name) {
                const effect = {
                    id: this.nextId++,
                    name: name || 'VFX',
                    type: 'visualEffect',
                    x: 400 + Math.random() * 200,
                    y: 300 + Math.random() * 200,
                    url: url,
                    width: 100,
                    height: 100,
                    mode: 'decoration'
                };
                this.visualEffects.push(effect);
                this.entities.push(effect);
                this.render();
            },
            playVisualEffect(url, x, y, width = 100, height = 100, duration = 3) {
                const effect = document.createElement('div');
                effect.className = 'visual-effect';
                effect.style.left = (x - width/2) + 'px';
                effect.style.top = (y - height/2) + 'px';
                effect.style.width = width + 'px';
                effect.style.height = height + 'px';
                effect.innerHTML = `<img src="${url}" style="width: 100%; height: 100%; object-fit: contain;">`;
              
                document.getElementById('boardCanvas').appendChild(effect);
              
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, duration * 1000);
            },
            // Enhanced Action Display System
            showActionDisplay(type, title, description, details = '') {
                // Remove any existing action displays
                document.querySelectorAll('.action-display').forEach(el => el.remove());
              
                const display = document.createElement('div');
                display.className = `action-display ${type}`;
              
                display.innerHTML = `
                    <h3>${title}</h3>
                    <div style="font-size: 13px; margin-bottom: 5px;">${description}</div>
                    ${details ? `<div class="action-breakdown">${details}</div>` : ''}
                `;
              
                document.body.appendChild(display);
              
                // Auto-remove after 4 seconds
                setTimeout(() => {
                    if (display.parentNode) {
                        display.parentNode.removeChild(display);
                    }
                }, 4000);
            },
          
            // Enhanced Add NPC function (renamed from addNPCToken)
            addNPC() {
                const name = prompt('Enter NPC name:');
                if (!name) return;
              
                // Create modal for class and race selection
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="creation-modal">
                        <h2>🤖 Create NPC</h2>
                        <div class="form-group">
                            <label class="form-label">Class:</label>
                            <select id="npcClassSelect" class="form-select">
                                ${this.classList.map(cls => `<option value="${cls}">${cls}</option>`).join('')}
                            </select>
                            <input type="text" id="npcCustomClass" placeholder="Enter custom class name" class="custom-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Race:</label>
                            <select id="npcRaceSelect" class="form-select">
                                ${this.raceList.map(race => `<option value="${race}">${race}</option>`).join('')}
                            </select>
                            <input type="text" id="npcCustomRace" placeholder="Enter custom race name" class="custom-input">
                        </div>
                      
                        <button class="advanced-toggle" onclick="this.nextElementSibling.classList.toggle('show')">⚙️ Advanced Options</button>
                        <div class="advanced-options">
                            <div class="advanced-grid">
                                <div>
                                    <label class="form-label">Hit Points:</label>
                                    <input type="number" id="npcHP" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Armor Class:</label>
                                    <input type="number" id="npcAC" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Speed:</label>
                                    <input type="number" id="npcSpeed" value="30" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Strength:</label>
                                    <input type="number" id="npcStr" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Dexterity:</label>
                                    <input type="number" id="npcDex" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Constitution:</label>
                                    <input type="number" id="npcCon" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Intelligence:</label>
                                    <input type="number" id="npcInt" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Wisdom:</label>
                                    <input type="number" id="npcWis" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Charisma:</label>
                                    <input type="number" id="npcCha" value="10" class="advanced-input">
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Character Image URL:</label>
                                <input type="text" id="npcImage" placeholder="Image URL" class="advanced-input">
                            </div>
                        </div>
                      
                        <div class="modal-buttons">
                            <button class="btn btn-danger" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createNPCFromModal('${name}')">Create NPC</button>
                        </div>
                    </div>
                `;
              
                // Add event listeners for custom option toggles
                modal.querySelector('#npcClassSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#npcCustomClass');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
              
                modal.querySelector('#npcRaceSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#npcCustomRace');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
              
                document.body.appendChild(modal);
            },
          
            createNPCFromModal(name) {
                const modal = document.querySelector('.modal-overlay');
                const classSelect = modal.querySelector('#npcClassSelect');
                const customClass = modal.querySelector('#npcCustomClass');
                const raceSelect = modal.querySelector('#npcRaceSelect');
                const customRace = modal.querySelector('#npcCustomRace');
              
                const selectedClass = classSelect.value === 'Custom' ? customClass.value || 'Commoner' : classSelect.value;
                const selectedRace = raceSelect.value === 'Custom' ? customRace.value || 'Human' : raceSelect.value;
              
                const entity = this.createEntity('npc', name, 300 + Math.random() * 100, 250 + Math.random() * 100);
                entity.class = selectedClass;
                entity.race = selectedRace;
                entity.color = '#f59e0b'; // Orange color for NPCs
              
                // Apply advanced options if filled
                const hp = parseInt(modal.querySelector('#npcHP').value) || 10;
                const ac = parseInt(modal.querySelector('#npcAC').value) || 10;
                const speed = parseInt(modal.querySelector('#npcSpeed').value) || 30;
                const str = parseInt(modal.querySelector('#npcStr').value) || 10;
                const dex = parseInt(modal.querySelector('#npcDex').value) || 10;
                const con = parseInt(modal.querySelector('#npcCon').value) || 10;
                const int = parseInt(modal.querySelector('#npcInt').value) || 10;
                const wis = parseInt(modal.querySelector('#npcWis').value) || 10;
                const cha = parseInt(modal.querySelector('#npcCha').value) || 10;
                const image = modal.querySelector('#npcImage').value || '';
              
                entity.hp = hp;
                entity.maxHp = hp;
                entity.ac = ac;
                entity.speed = speed;
                entity.str = str;
                entity.dex = dex;
                entity.con = con;
                entity.int = int;
                entity.wis = wis;
                entity.cha = cha;
                entity.image = image;
              
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
              
                modal.remove();
            },
          
            // Library Sidebar Functions
            toggleLibrarySidebar() {
                this.librarySidebarOpen = !this.librarySidebarOpen;
                const sidebar = document.getElementById('expandableLibrarySidebar');
                const toggle = document.getElementById('libraryToggle');
              
                if (this.librarySidebarOpen) {
                    sidebar.classList.add('open');
                    toggle.style.right = '400px';
                    this.populateLibrarySidebar();
                  
                    // Check if action menu or details panel is open and push it left
                    const actionMenus = document.querySelectorAll('.action-menu');
                    actionMenus.forEach(menu => {
                        menu.classList.add('pushed-left');
                    });
                  
                    const detailsPanels = document.querySelectorAll('.details-panel');
                    detailsPanels.forEach(panel => {
                        panel.style.right = '420px';
                    });
                } else {
                    sidebar.classList.remove('open');
                    toggle.style.right = '0px';
                  
                    // Restore action menu and details panel position
                    const actionMenus = document.querySelectorAll('.action-menu');
                    actionMenus.forEach(menu => {
                        menu.classList.remove('pushed-left');
                    });
                  
                    const detailsPanels = document.querySelectorAll('.details-panel');
                    detailsPanels.forEach(panel => {
                        panel.style.right = '20px';
                    });
                }
            },
          
            populateLibrarySidebar() {
                const grid = document.getElementById('sidebarLibraryGrid');
                if (!grid) return;
              
                grid.innerHTML = '';
              
                // Ensure all library arrays exist before mapping
                const monsters = this.library.monsters || [];
                const players = this.library.players || [];
                const spells = this.library.spells || [];
                const items = this.library.items || [];
                const equipment = this.library.equipment || [];
                const sfx = this.library.sfx || [];
              
                const all = [
                    ...monsters.map(m => ({...m, category: 'monster'})),
                    ...players.map(p => ({...p, category: 'player'})),
                    ...spells.map(s => ({...s, category: 'spell'})),
                    ...items.map(i => ({...i, category: 'item'})),
                    ...equipment.map(e => ({...e, category: 'equipment'})),
                    ...sfx.map(s => ({...s, category: 'sfx'}))
                ];
              
                all.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'content-card';
                    card.dataset.type = item.category;
                    card.dataset.name = item.name.toLowerCase();
                  
                    let html = `<h4 style="color: #fbbf24; font-size: 14px; margin-bottom: 8px;">${item.name}</h4>`;
                  
                    if (item.category === 'monster' || item.category === 'player') {
                        html += `<p style="font-size: 11px; color: #9ca3af;">HP: ${item.hp}/${item.maxHp} | AC: ${item.ac}</p>`;
                        if (item.cr) html += `<p style="font-size: 10px; color: #6b7280;">CR: ${item.cr}</p>`;
                        html += `<button class="btn btn-small btn-primary" style="width: 100%; margin-top: 8px; padding: 4px 8px; font-size: 10px;" onclick="game.addFromLibrarySidebar('${item.name}', '${item.category}')">Add to Board</button>`;
                    } else if (item.category === 'spell') {
                        html += `<p style="font-size: 11px; color: #9ca3af;">Level ${item.level} ${item.school}</p>`;
                        if (item.damage) html += `<p style="font-size: 10px; color: #6b7280;">Damage: ${item.damage}</p>`;
                        if (item.healing) html += `<p style="font-size: 10px; color: #6b7280;">Healing: ${item.healing}</p>`;
                        html += `<button class="btn btn-small btn-primary" style="width: 100%; margin-top: 8px; padding: 4px 8px; font-size: 10px;" onclick="game.assignSpellToCharacter('${item.name}')">Assign to Character</button>`;
                    } else if (item.category === 'item' || item.category === 'equipment') {
                        if (item.damage) html += `<p style="font-size: 10px; color: #6b7280;">Damage: ${item.damage}</p>`;
                        if (item.ac) html += `<p style="font-size: 10px; color: #6b7280;">AC: ${item.ac}</p>`;
                        if (item.healing) html += `<p style="font-size: 10px; color: #6b7280;">Healing: ${item.healing}</p>`;
                        html += `<div style="display: flex; gap: 5px; margin-top: 8px;">
                            <button class="btn btn-small btn-primary" style="flex: 1; padding: 4px 8px; font-size: 10px;" onclick="game.addFromLibrarySidebar('${item.name}', '${item.category}')">Add to Board</button>
                            <button class="btn btn-small btn-success" style="flex: 1; padding: 4px 8px; font-size: 10px;" onclick="game.addToInventory('${item.name}', '${item.category}')">Add to Inventory</button>
                        </div>`;
                    } else if (item.category === 'sfx') {
                        html += `<p style="font-size: 11px; color: #9ca3af;">Category: ${item.category}</p>`;
                        html += `<div style="display: flex; gap: 5px; margin-top: 8px;">
                            <button class="btn btn-small btn-primary" style="flex: 1; padding: 4px 8px; font-size: 10px;" onclick="game.previewSFX('${item.url}')">Preview</button>
                            <button class="btn btn-small btn-success" style="flex: 1; padding: 4px 8px; font-size: 10px;" onclick="game.assignSFX('${item.name}')">Assign</button>
                        </div>`;
                    }
                  
                    html += `<div style="display: flex; gap: 5px; margin-top: 8px;">
                        <button class="btn btn-small btn-warning" style="flex: 1; padding: 4px 8px; font-size: 10px;" onclick="game.editLibraryItem('${item.name}', '${item.category}')">Edit</button>
                        <button class="btn btn-small btn-danger" style="flex: 1; padding: 4px 8px; font-size: 10px;" onclick="game.duplicateLibraryItem('${item.name}', '${item.category}')">Duplicate</button>
                        <button class="btn btn-small btn-danger" style="flex: 1; padding: 4px 8px; font-size: 10px;" onclick="game.removeLibraryItem('${item.name}', '${item.category}')">Delete</button>
                    </div>`;
                  
                    card.innerHTML = html;
                    grid.appendChild(card);
                });
            },
          
            addFromLibrarySidebar(name, category) {
                this.addFromLibrary(name, category);
                // Keep sidebar open but switch to combat tab
                switchTab({target: document.querySelector('.tab[onclick*="combat"]')}, 'combat');
            },
          
            assignSpellToCharacter(spellName) {
                const spell = this.library.spells.find(s => s.name === spellName);
                if (!spell) return;
              
                // Show modal to select character
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>Assign Spell: ${spellName}</h2>
                        <div class="item-list">
                            ${this.entities.filter(e => e.type === 'player' || e.type === 'npc').map(e => `
                                <div class="item-card" onclick="game.assignSpellToEntity('${spellName}', ${e.id}); this.closest('.modal-overlay').remove();">
                                    ${e.name}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
          
            addToInventory(itemName, category) {
                const item = category === 'item' ? this.library.items.find(i => i.name === itemName) :
                            category === 'equipment' ? this.library.equipment.find(e => e.name === itemName) : null;
                if (!item) return;
              
                // Show modal to select character
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>Add to Inventory: ${itemName}</h2>
                        <div class="item-list">
                            ${this.entities.filter(e => e.type === 'player' || e.type === 'npc').map(e => `
                                <div class="item-card" onclick="game.assignItemToEntity('${itemName}', '${category}', ${e.id}); this.closest('.modal-overlay').remove();">
                                    ${e.name}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
          
            assignSFX(sfxName) {
                const sfx = this.library.sfx.find(s => s.name === sfxName);
                if (!sfx) return;
              
                // For assignment, perhaps to selected entity or global
                if (this.selectedEntity) {
                    this.selectedEntity.soundEffect = sfx.url;
                    this.addLog(`Assigned SFX ${sfxName} to ${this.selectedEntity.name}`, 'info');
                } else {
                    alert('Select an entity first to assign SFX');
                }
            },
          
            filterSidebarLibrary(filterType) {
                const cards = document.querySelectorAll('#sidebarLibraryGrid .content-card');
                cards.forEach(card => {
                    if (filterType === 'all' || card.dataset.type === filterType) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
          
            searchSidebarLibrary(searchTerm) {
                const cards = document.querySelectorAll('#sidebarLibraryGrid .content-card');
                const term = searchTerm.toLowerCase();
              
                cards.forEach(card => {
                    if (card.dataset.name.includes(term)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            },
          
            // Content Editors
            showMonsterEditor(monster = null) {
                const isEdit = !!monster;
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>${isEdit ? 'Edit' : 'Create'} Monster</h2>
                        <input type="text" id="monsterName" placeholder="Name" value="${monster ? monster.name : ''}">
                        <input type="number" id="monsterHP" placeholder="HP" value="${monster ? monster.hp : ''}">
                        <input type="number" id="monsterAC" placeholder="AC" value="${monster ? monster.ac : ''}">
                        <input type="number" id="monsterSpeed" placeholder="Speed" value="${monster ? monster.speed : ''}">
                        <input type="number" id="monsterStr" placeholder="Strength" value="${monster ? monster.str : ''}">
                        <input type="number" id="monsterDex" placeholder="Dexterity" value="${monster ? monster.dex : ''}">
                        <input type="number" id="monsterCon" placeholder="Constitution" value="${monster ? monster.con : ''}">
                        <input type="number" id="monsterInt" placeholder="Intelligence" value="${monster ? monster.int : ''}">
                        <input type="number" id="monsterWis" placeholder="Wisdom" value="${monster ? monster.wis : ''}">
                        <input type="number" id="monsterCha" placeholder="Charisma" value="${monster ? monster.cha : ''}">
                        <input type="text" id="monsterDescription" placeholder="Description" value="${monster ? monster.description : ''}">
                        <input type="text" id="monsterImage" placeholder="Image URL" value="${monster ? monster.image : ''}">
                        <input type="text" id="monsterSound" placeholder="Sound Effect URL" value="${monster ? monster.soundEffect : ''}">
                        <input type="text" id="monsterVFX" placeholder="Visual Effect URL" value="${monster ? monster.visualEffect : ''}">
                        <button class="btn btn-success" onclick="game.saveMonsterFromEditor(${isEdit ? `'${monster.name}'` : 'null'})">Save</button>
                    </div>
                `;
                document.body.appendChild(modal);
            },
          
            saveMonsterFromEditor(originalName) {
                const modal = document.querySelector('.modal-overlay');
                const monster = {
                    name: modal.querySelector('#monsterName').value,
                    type: 'monster',
                    hp: parseInt(modal.querySelector('#monsterHP').value) || 10,
                    maxHp: parseInt(modal.querySelector('#monsterHP').value) || 10,
                    ac: parseInt(modal.querySelector('#monsterAC').value) || 10,
                    speed: parseInt(modal.querySelector('#monsterSpeed').value) || 30,
                    str: parseInt(modal.querySelector('#monsterStr').value) || 10,
                    dex: parseInt(modal.querySelector('#monsterDex').value) || 10,
                    con: parseInt(modal.querySelector('#monsterCon').value) || 10,
                    int: parseInt(modal.querySelector('#monsterInt').value) || 10,
                    wis: parseInt(modal.querySelector('#monsterWis').value) || 10,
                    cha: parseInt(modal.querySelector('#monsterCha').value) || 10,
                    description: modal.querySelector('#monsterDescription').value,
                    image: modal.querySelector('#monsterImage').value,
                    soundEffect: modal.querySelector('#monsterSound').value,
                    visualEffect: modal.querySelector('#monsterVFX').value,
                    proficiencyBonus: 2,
                    attacks: [],
                    abilities: [],
                    skills: {},
                    savingThrows: {},
                    baseActions: [...this.baseCombatActions]
                };
              
                if (this.validateContent(monster, 'monster')) {
                    if (originalName) {
                        const index = this.library.monsters.findIndex(m => m.name === originalName);
                        if (index > -1) this.library.monsters[index] = monster;
                    } else {
                        this.library.monsters.push(monster);
                    }
                    this.saveLibrary();
                    this.populateLibrarySidebar();
                    modal.remove();
                }
            },
          
            showSpellEditor(spell = null) {
                const isEdit = !!spell;
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>${isEdit ? 'Edit' : 'Create'} Spell</h2>
                        <input type="text" id="spellName" placeholder="Name" value="${spell ? spell.name : ''}">
                        <input type="number" id="spellLevel" placeholder="Level" value="${spell ? spell.level : ''}">
                        <input type="text" id="spellSchool" placeholder="School" value="${spell ? spell.school : ''}">
                        <input type="text" id="spellDamage" placeholder="Damage (e.g., 8d6)" value="${spell ? spell.damage : ''}">
                        <input type="text" id="spellDamageType" placeholder="Damage Type" value="${spell ? spell.damageType : ''}">
                        <input type="text" id="spellHealing" placeholder="Healing (e.g., 1d8+3)" value="${spell ? spell.healing : ''}">
                        <input type="text" id="spellDescription" placeholder="Description" value="${spell ? spell.description : ''}">
                        <input type="text" id="spellSound" placeholder="Sound Effect URL" value="${spell ? spell.soundEffect : ''}">
                        <input type="text" id="spellVFX" placeholder="Visual Effect URL" value="${spell ? spell.visualEffect : ''}">
                        <select id="spellPattern">
                            <option value="onEntity" ${spell && spell.visualPattern === 'onEntity' ? 'selected' : ''}>On Entity</option>
                            <option value="shoot" ${spell && spell.visualPattern === 'shoot' ? 'selected' : ''}>Shoot</option>
                            <option value="aoe" ${spell && spell.visualPattern === 'aoe' ? 'selected' : ''}>Area of Effect</option>
                        </select>
                        <button class="btn btn-success" onclick="game.saveSpellFromEditor(${isEdit ? `'${spell.name}'` : 'null'})">Save</button>
                    </div>
                `;
                document.body.appendChild(modal);
            },
          
            saveSpellFromEditor(originalName) {
                const modal = document.querySelector('.modal-overlay');
                const spell = {
                    name: modal.querySelector('#spellName').value,
                    type: 'spell',
                    level: parseInt(modal.querySelector('#spellLevel').value) || 0,
                    school: modal.querySelector('#spellSchool').value || 'evocation',
                    damage: modal.querySelector('#spellDamage').value,
                    damageType: modal.querySelector('#spellDamageType').value,
                    healing: modal.querySelector('#spellHealing').value,
                    description: modal.querySelector('#spellDescription').value,
                    soundEffect: modal.querySelector('#spellSound').value,
                    visualEffect: modal.querySelector('#spellVFX').value,
                    visualPattern: modal.querySelector('#spellPattern').value
                };
              
                if (this.validateContent(spell, 'spell')) {
                    if (originalName) {
                        const index = this.library.spells.findIndex(s => s.name === originalName);
                        if (index > -1) this.library.spells[index] = spell;
                    } else {
                        this.library.spells.push(spell);
                    }
                    this.saveLibrary();
                    this.populateLibrarySidebar();
                    modal.remove();
                }
            },
          
            showItemEditor(item = null) {
                const isEdit = !!item;
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>${isEdit ? 'Edit' : 'Create'} Item</h2>
                        <input type="text" id="itemName" placeholder="Name" value="${item ? item.name : ''}">
                        <input type="text" id="itemHealing" placeholder="Healing (e.g., 2d4+2)" value="${item ? item.healing : ''}">
                        <input type="text" id="itemDamage" placeholder="Damage (e.g., 1d8)" value="${item ? item.damage : ''}">
                        <input type="text" id="itemRarity" placeholder="Rarity" value="${item ? item.rarity : ''}">
                        <input type="text" id="itemDescription" placeholder="Description" value="${item ? item.description : ''}">
                        <input type="text" id="itemSound" placeholder="Sound Effect URL" value="${item ? item.soundEffect : ''}">
                        <input type="text" id="itemVFX" placeholder="Visual Effect URL" value="${item ? item.visualEffect : ''}">
                        <button class="btn btn-success" onclick="game.saveItemFromEditor(${isEdit ? `'${item.name}'` : 'null'})">Save</button>
                    </div>
                `;
                document.body.appendChild(modal);
            },
          
            saveItemFromEditor(originalName) {
                const modal = document.querySelector('.modal-overlay');
                const item = {
                    name: modal.querySelector('#itemName').value,
                    type: 'item',
                    healing: modal.querySelector('#itemHealing').value,
                    damage: modal.querySelector('#itemDamage').value,
                    rarity: modal.querySelector('#itemRarity').value || 'common',
                    description: modal.querySelector('#itemDescription').value,
                    soundEffect: modal.querySelector('#itemSound').value,
                    visualEffect: modal.querySelector('#itemVFX').value,
                    consumable: true
                };
              
                if (this.validateContent(item, 'item')) {
                    if (originalName) {
                        const index = this.library.items.findIndex(i => i.name === originalName);
                        if (index > -1) this.library.items[index] = item;
                    } else {
                        this.library.items.push(item);
                    }
                    this.saveLibrary();
                    this.populateLibrarySidebar();
                    modal.remove();
                }
            },
          
            showEquipmentEditor(equipment = null) {
                const isEdit = !!equipment;
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>${isEdit ? 'Edit' : 'Create'} Equipment</h2>
                        <input type="text" id="equipName" placeholder="Name" value="${equipment ? equipment.name : ''}">
                        <input type="number" id="equipAC" placeholder="AC Bonus" value="${equipment ? equipment.ac : ''}">
                        <input type="number" id="equipAttackBonus" placeholder="Attack Bonus" value="${equipment ? equipment.attackBonus : ''}">
                        <input type="text" id="equipDescription" placeholder="Description" value="${equipment ? equipment.description : ''}">
                        <input type="text" id="equipSound" placeholder="Sound Effect URL" value="${equipment ? equipment.soundEffect : ''}">
                        <input type="text" id="equipVFX" placeholder="Visual Effect URL" value="${equipment ? equipment.visualEffect : ''}">
                        <button class="btn btn-success" onclick="game.saveEquipmentFromEditor(${isEdit ? `'${equipment.name}'` : 'null'})">Save</button>
                    </div>
                `;
                document.body.appendChild(modal);
            },
          
            saveEquipmentFromEditor(originalName) {
                const modal = document.querySelector('.modal-overlay');
                const equipment = {
                    name: modal.querySelector('#equipName').value,
                    type: 'equipment',
                    ac: parseInt(modal.querySelector('#equipAC').value) || 0,
                    attackBonus: parseInt(modal.querySelector('#equipAttackBonus').value) || 0,
                    description: modal.querySelector('#equipDescription').value,
                    soundEffect: modal.querySelector('#equipSound').value,
                    visualEffect: modal.querySelector('#equipVFX').value
                };
              
                if (this.validateContent(equipment, 'equipment')) {
                    if (originalName) {
                        const index = this.library.equipment.findIndex(e => e.name === originalName);
                        if (index > -1) this.library.equipment[index] = equipment;
                    } else {
                        this.library.equipment.push(equipment);
                    }
                    this.saveLibrary();
                    this.populateLibrarySidebar();
                    modal.remove();
                }
            },
          
            showSFXEditor(sfx = null) {
                const isEdit = !!sfx;
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <h2>${isEdit ? 'Edit' : 'Upload'} SFX</h2>
                        <input type="text" id="sfxName" placeholder="Name" value="${sfx ? sfx.name : ''}">
                        <input type="file" id="sfxFile" accept="audio/mp3">
                        <input type="text" id="sfxCategory" placeholder="Category (e.g., combat)" value="${sfx ? sfx.category : ''}">
                        <button class="btn btn-success" onclick="game.saveSFXFromEditor(${isEdit ? `'${sfx.name}'` : 'null'})">Save</button>
                    </div>
                `;
                document.body.appendChild(modal);
            },
          
            saveSFXFromEditor(originalName) {
                const modal = document.querySelector('.modal-overlay');
                const name = modal.querySelector('#sfxName').value;
                const category = modal.querySelector('#sfxCategory').value;
                const fileInput = modal.querySelector('#sfxFile');
              
                if (fileInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const sfx = {
                            name: name,
                            category: category,
                            url: e.target.result // base64
                        };
                      
                        if (originalName) {
                            const index = this.library.sfx.findIndex(s => s.name === originalName);
                            if (index > -1) this.library.sfx[index] = sfx;
                        } else {
                            this.library.sfx.push(sfx);
                        }
                        this.saveLibrary();
                        this.populateLibrarySidebar();
                        modal.remove();
                    };
                    reader.readAsDataURL(fileInput.files[0]);
                } else if (originalName) {
                    // Update name/category only
                    const index = this.library.sfx.findIndex(s => s.name === originalName);
                    if (index > -1) {
                        this.library.sfx[index].name = name;
                        this.library.sfx[index].category = category;
                        this.saveLibrary();
                        this.populateLibrarySidebar();
                        modal.remove();
                    }
                }
            },
          
            previewSFX(url) {
                const audio = new Audio(url);
                audio.play();
            },
          
            editLibraryItem(name, category) {
                const item = this.library[category + 's'].find(i => i.name === name);
                if (!item) return;
              
                switch (category) {
                    case 'monster':
                    case 'player':
                        this.showMonsterEditor(item);
                        break;
                    case 'spell':
                        this.showSpellEditor(item);
                        break;
                    case 'item':
                        this.showItemEditor(item);
                        break;
                    case 'equipment':
                        this.showEquipmentEditor(item);
                        break;
                    case 'sfx':
                        this.showSFXEditor(item);
                        break;
                }
            },
          
            duplicateLibraryItem(name, category) {
                const item = this.library[category + 's'].find(i => i.name === name);
                if (item) {
                    const dup = {...item, name: `${item.name} (Copy)`};
                    this.library[category + 's'].push(dup);
                    this.saveLibrary();
                    this.populateLibrarySidebar();
                }
            },
          
            removeLibraryItem(name, category) {
                if (confirm(`Delete ${name}?`)) {
                    const index = this.library[category + 's'].findIndex(i => i.name === name);
                    if (index > -1) {
                        this.library[category + 's'].splice(index, 1);
                        this.saveLibrary();
                        this.populateLibrarySidebar();
                    }
                }
            },
          
            validateContent(content, type) {
                // Basic validation
                if (!content.name) {
                    alert('Name is required');
                    return false;
                }
              
                switch (type) {
                    case 'spell':
                        if (content.level === undefined) {
                            alert('Spell level is required');
                            return false;
                        }
                        break;
                    case 'monster':
                        if (content.hp === undefined || content.ac === undefined) {
                            alert('HP and AC are required for monsters');
                            return false;
                        }
                        break;
                    // Add more validations as needed
                }
                return true;
            },
          
            // Assignment functions
            assignSpellToEntity(spellName, entityId) {
                const entity = this.getEntity(entityId);
                const spell = this.library.spells.find(s => s.name === spellName);
                if (entity && spell) {
                    if (!entity.spells) entity.spells = [];
                    entity.spells.push({...spell});
                    this.addLog(`Assigned ${spellName} to ${entity.name}`, 'info');
                }
            },
          
            assignItemToEntity(itemName, category, entityId) {
                const entity = this.getEntity(entityId);
                const item = category === 'item' ? this.library.items.find(i => i.name === itemName) :
                             this.library.equipment.find(e => e.name === itemName);
                if (entity && item) {
                    if (!entity.inventory) entity.inventory = [];
                    entity.inventory.push({...item});
                    this.addLog(`Added ${itemName} to ${entity.name}'s inventory`, 'info');
                }
            },
          
            // Audio System
            setBackgroundMusicFromFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.setBackgroundMusic(e.target.result);
                };
                reader.readAsDataURL(file);
            },
          
            setBackgroundMusic(url) {
                this.backgroundMusic.url = url;
                this.backgroundMusic.mode = 'loop'
                if (this.backgroundMusic.audio) {
                    this.backgroundMusic.audio.pause();
                    this.backgroundMusic.audio = null;
                }
              
                if (url) {
                    // Create video element for video sources, audio element for audio sources
                    if (url.includes('youtube.com') || url.includes('youtu.be') || url.includes('.mp4') || url.includes('.webm') || url.includes('.ogg') || url.startsWith('data:video')) {
                        this.backgroundMusic.audio = document.createElement('video');
                        this.backgroundMusic.audio.style.display = 'none';
                        document.body.appendChild(this.backgroundMusic.audio);
                    } else {
                        this.backgroundMusic.audio = new Audio();
                    }
                  
                    this.backgroundMusic.audio.src = url;
                    this.backgroundMusic.audio.loop = true;
                    this.backgroundMusic.audio.volume = 0.3; // Set to 30% volume
                }

                const bgmInput = document.getElementById('backgroundMusic');
                if (bgmInput) bgmInput.value = url;
              
                localStorage.setItem('dndBackgroundMusic', url);
            },

            setBackgroundMusicAndPlay(url) {
                this.setBackgroundMusic(url);
                const bgmInput = document.getElementById('backgroundMusic');
                if (bgmInput) {
                    bgmInput.value = url;
                }
                this.playBackgroundMusic();
            },

            setVolume(value) {
                const volume = parseInt(value) / 100;
                if (this.backgroundMusic.audio) {
                    this.backgroundMusic.audio.volume = volume;
                }
                if (this.backgroundMusic.audios) {
                    this.backgroundMusic.audios.forEach(audio => audio.volume = volume);
                }
                const display = document.getElementById('volumeDisplay');
                if (display) display.textContent = value;
                localStorage.setItem('dndBGMVolume', value);
            },

            playBackgroundMusic() {
                if (this.backgroundMusic.mode === 'loop') {
                    if (!this.backgroundMusic.audio && this.backgroundMusic.url) {
                        this.setBackgroundMusic(this.backgroundMusic.url) // recreate if not
                    }
                    if (this.backgroundMusic.audio && !this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.audio.play().then(() => {
                            this.backgroundMusic.isPlaying = true;
                            document.getElementById('playBtn').classList.add('active');
                            document.getElementById('pauseBtn').classList.remove('active');
                        }).catch(e => console.log('Music play failed:', e));
                    }
                } else {
                    if (this.backgroundMusic.audios && this.backgroundMusic.audios.length > 0 && !this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.audios[this.backgroundMusic.currentIndex].play().then(() => {
                            this.backgroundMusic.isPlaying = true;
                            document.getElementById('playBtn').classList.add('active');
                            document.getElementById('pauseBtn').classList.remove('active');
                        }).catch(e => console.log('Music play failed:', e));
                    }
                }
            },
          
            pauseBackgroundMusic() {
                if (this.backgroundMusic.isPlaying) {
                    if (this.backgroundMusic.mode === 'loop') {
                        if (this.backgroundMusic.audio) this.backgroundMusic.audio.pause();
                    } else {
                        if (this.backgroundMusic.audios) this.backgroundMusic.audios[this.backgroundMusic.currentIndex].pause();
                    }
                    this.backgroundMusic.isPlaying = false;
                    document.getElementById('playBtn').classList.remove('active');
                    document.getElementById('pauseBtn').classList.add('active');
                }
            },
            toggleBGMMode() {
                this.backgroundMusic.mode = this.backgroundMusic.mode === 'loop' ? 'playlist' : 'loop'
                document.getElementById('bgmModeBtn').textContent = `Mode: ${this.backgroundMusic.mode.charAt(0).toUpperCase() + this.backgroundMusic.mode.slice(1)}`
                if (this.backgroundMusic.mode === 'playlist') {
                    this.setupBGMPlaylist()
                }
            },
            setupBGMPlaylist() {
                if (this.library.bgm && this.library.bgm.length > 0) {
                    if (this.backgroundMusic.audio) {
                        this.backgroundMusic.audio.pause()
                        this.backgroundMusic.audio = null
                    }
                    this.backgroundMusic.audios = this.library.bgm.map(bgm => {
                        const audio = bgm.url.includes('.mp4') ? document.createElement('video') : new Audio()
                        audio.src = bgm.url
                        audio.volume = 0.3
                        audio.addEventListener('ended', () => {
                            this.backgroundMusic.currentIndex = (this.backgroundMusic.currentIndex + 1) % this.backgroundMusic.audios.length
                            this.backgroundMusic.audios[this.backgroundMusic.currentIndex].play()
                        })
                        return audio
                    })
                    this.backgroundMusic.currentIndex = 0
                } else {
                    alert('No BGM saved for playlist!')
                    this.backgroundMusic.mode = 'loop'
                    document.getElementById('bgmModeBtn').textContent = 'Mode: Loop'
                }
            },
          
            // Setup Drawing Canvas
            setupDrawingCanvas() {
                this.drawingCanvas = document.getElementById('drawingCanvas');
                this.drawingCtx = this.drawingCanvas.getContext('2d');
              
                const resizeCanvas = () => {
                    const board = document.getElementById('gameBoard');
                    this.drawingCanvas.width = board.offsetWidth;
                    this.drawingCanvas.height = board.offsetHeight;
                };
              
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
              
                // Drawing event listeners
                this.drawingCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.drawingCanvas.addEventListener('mousemove', (e) => this.draw(e));
                this.drawingCanvas.addEventListener('mouseup', () => this.stopDrawing());
                this.drawingCanvas.addEventListener('mouseout', () => this.stopDrawing());
            },
          
            // Drawing Functions
            startDrawing(e) {
                if (!this.drawMode) return;
              
                const rect = this.drawingCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
              
                this.isDrawing = true;
                this.lastDrawX = x;
                this.lastDrawY = y;
              
                if (this.eraseMode) {
                    this.drawingCtx.globalCompositeOperation = 'destination-out';
                    this.drawingCtx.lineWidth = 20;
                } else {
                    this.drawingCtx.globalCompositeOperation = 'source-over';
                    this.drawingCtx.strokeStyle = '#fbbf24';
                    this.drawingCtx.lineWidth = 3;
                }
              
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(x, y);
            },
          
            draw(e) {
                if (!this.isDrawing || !this.drawMode) return;
              
                const rect = this.drawingCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
              
                if (this.eraseMode) {
                    this.drawingCtx.globalCompositeOperation = 'destination-out';
                    this.drawingCtx.lineWidth = 20;
                } else {
                    this.drawingCtx.globalCompositeOperation = 'source-over';
                    this.drawingCtx.strokeStyle = '#fbbf24';
                    this.drawingCtx.lineWidth = 3;
                }
              
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(this.lastDrawX, this.lastDrawY);
                this.drawingCtx.lineTo(x, y);
                this.drawingCtx.stroke();
              
                this.lastDrawX = x;
                this.lastDrawY = y;
            },
          
            stopDrawing() {
                this.isDrawing = false;
            },
          
            toggleDrawMode() {
                this.drawMode = !this.drawMode;
                const btn = document.getElementById('drawToggle');
                const canvas = document.getElementById('drawingCanvas');
              
                btn.classList.toggle('active', this.drawMode);
                canvas.classList.toggle('drawing-mode', this.drawMode);
              
                if (this.drawMode) {
                    this.eraseMode = false;
                    document.getElementById('eraseToggle').classList.remove('active');
                }
              
                this.addLog(`Draw mode ${this.drawMode ? 'enabled' : 'disabled'}`, 'info');
            },
          
            toggleEraseMode() {
                this.eraseMode = !this.eraseMode;
                const btn = document.getElementById('eraseToggle');
                btn.classList.toggle('active', this.eraseMode);
              
                if (this.eraseMode && !this.drawMode) {
                    this.toggleDrawMode();
                }
              
                this.addLog(`Erase mode ${this.eraseMode ? 'enabled' : 'disabled'}`, 'info');
            },
          
            clearDrawing() {
                console.log('clearDrawing function called');
                if (confirm('Clear all drawings?')) {
                    const canvas = document.getElementById('drawingCanvas');
                    console.log('Canvas found:', canvas);
                    if (canvas) {
                        console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                        const ctx = canvas.getContext('2d');
                        console.log('Context:', ctx);
                      
                        // Try multiple clearing methods
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'rgba(0,0,0,0)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                      
                        // Reset canvas completely
                        const parent = canvas.parentNode;
                        const newCanvas = document.createElement('canvas');
                        newCanvas.id = 'drawingCanvas';
                        newCanvas.className = canvas.className;
                        newCanvas.width = canvas.width;
                        newCanvas.height = canvas.height;
                      
                        parent.replaceChild(newCanvas, canvas);
                      
                        // Reinitialize drawing on new canvas
                        this.drawingCanvas = newCanvas;
                        this.drawingCtx = newCanvas.getContext('2d');
                      
                        // Re-add event listeners
                        this.drawingCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                        this.drawingCanvas.addEventListener('mousemove', (e) => this.draw(e));
                        this.drawingCanvas.addEventListener('mouseup', () => this.stopDrawing());
                        this.drawingCanvas.addEventListener('mouseout', () => this.stopDrawing());
                      
                        this.addLog('Drawing cleared', 'info');
                        console.log('Drawing cleared successfully');
                    } else {
                        this.addLog('Drawing canvas not found', 'info');
                        console.log('Canvas not found!');
                    }
                }
            },
          
            // Create Entity with full D&D 5e stats
            createEntity(type, name, x, y) {
                const entity = {
                    id: this.nextId++,
                    type: type,
                    name: name,
                    x: x,
                    y: y,
                    scale: 1.0, // Add scale property for token resizing
                    color: type === 'player' ? '#3b82f6' :
                           type === 'npc' ? '#f59e0b' :
                           type === 'monster' ? '#ef4444' : '#fbbf24',
                    image: '',
                    soundEffect: '',
                    visualEffect: ''
                };
              
                // Only add full character attributes for players, monsters, and NPCs
                if (type === 'player' || type === 'monster' || type === 'npc') {
                    Object.assign(entity, {
                        hp: 10,
                        maxHp: 10,
                        tempHp: 0,
                        ac: 10,
                        speed: 30,
                        initiative: 0,
                        str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10,
                        proficiencyBonus: 2,
                        attacks: [],
                        spells: [],
                        spellSlots: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0},
                        spellSlotsUsed: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0},
                        inventory: [],
                        equipment: {
                            armor: null,
                            mainHand: null,
                            offHand: null,
                            helmet: null,
                            boots: null,
                            gloves: null,
                            amulet: null,
                            cloak: null,
                            ring1: null,
                            ring2: null
                        },
                        conditions: [],
                        conditionTurns: {}, // Track turns remaining for conditions
                        savingThrows: {str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0},
                        skills: {},
                        damageResistances: [],
                        damageImmunities: [],
                        damageVulnerabilities: [],
                        conditionImmunities: [],
                        deathSaves: {successes: 0, failures: 0},
                        concentrating: null,
                        movement: 30,
                        actionUsed: false,
                        bonusActionUsed: false,
                        reactionUsed: false,
                        class: type === 'player' || type === 'npc' ? 'Fighter' : 'Monster',
                        race: type === 'player' || type === 'npc' ? 'Human' : 'Humanoid',
                        level: type === 'player' || type === 'npc' ? 1 : 1,
                        hitDice: '1d10',
                        hitDiceRemaining: 1,
                        baseActions: [...this.baseCombatActions], // Add base combat actions
                        inspiration: 0,
                        disengaged: false
                    });
                  
                    if (type === 'player' || type === 'npc') {
                        entity.spellSlots = {1: 2, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0};
                    }
                } else if (type === 'item' || type === 'container') {
                    // Items only have basic properties needed for their function
                    Object.assign(entity, {
                        description: '',
                        value: 0,
                        weight: 0,
                        consumable: false,
                        healing: null,
                        effect: null,
                        spell: null,
                        damage: '',
                        damageType: '',
                        ac: 0,
                        rarity: 'common',
                        soundEffect: '',
                        visualEffect: ''
                    });
                  
                    if (type === 'container') {
                        entity.inventory = [];
                        entity.isMimic = false;
                    }
                } else if (type === 'visualEffect') {
                    // Visual effects have their own properties
                    Object.assign(entity, {
                        url: '',
                        width: 100,
                        height: 100,
                        mode: 'decoration',
                        duration: 3,
                        startTime: Date.now()
                    });
                }
              
                // Apply template if exists
                if (type === 'monster') {
                    const template = this.library.monsters.find(m => m.name === name);
                    if (template) {
                        Object.assign(entity, JSON.parse(JSON.stringify(template)));
                        entity.id = this.nextId - 1;
                        entity.x = x;
                        entity.y = y;
                        entity.scale = 1.0;
                        entity.baseActions = [...this.baseCombatActions];
                        // Ensure monsters have inventories for later loot drops
                        if (!entity.inventory) {
                            entity.inventory = [];
                        }
                    } else {
                        // Add some random loot to custom monsters
                        entity.inventory = [];
                        if (Math.random() < 0.3) { // 30% chance for loot
                            const lootTable = [...this.library.items, ...this.library.equipment];
                            const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                            entity.inventory.push(JSON.parse(JSON.stringify(randomLoot)));
                        }
                    }
                } else if (type === 'item' || type === 'container') {
                    let template = this.library.items.find(i => i.name === name);
                    if (!template) {
                        template = this.library.equipment.find(e => e.name === name);
                    }
                    if (template) {
                        Object.assign(entity, JSON.parse(JSON.stringify(template)));
                        entity.id = this.nextId - 1;
                        entity.x = x;
                        entity.y = y;
                        entity.scale = 1.0;
                        if (type === 'container' && !entity.inventory) {
                            entity.inventory = [];
                        }
                    }
                  
                    // Set container color based on content
                    if (type === 'container') {
                        if (entity.isMimic) {
                            entity.color = '#8B4513'; // Brown for mimics
                        } else if (!entity.inventory || entity.inventory.length === 0) {
                            entity.color = '#6b7280'; // Grey for empty chests
                        } else {
                            entity.color = '#fbbf24'; // Gold for filled chests
                        }
                    }
                }
              
                return entity;
            },
          
            // Get Ability Modifier
            getAbilityModifier(score) {
                return Math.floor((score - 10) / 2);
            },
          
            // Calculate Total AC
            calculateAC(entity) {
                let baseAC = 10;
                let dexMod = this.getAbilityModifier(entity.dex);
              
                if (entity.equipment && entity.equipment.armor) {
                    const armor = entity.equipment.armor;
                    baseAC = armor.ac;
                  
                    if (armor.maxDexBonus !== null && armor.maxDexBonus !== undefined) {
                        dexMod = Math.min(dexMod, armor.maxDexBonus);
                    } else if (armor.maxDexBonus === 0) {
                        dexMod = 0;
                    }
                } else {
                    // Unarmored defense
                    baseAC = 10 + dexMod;
                }
              
                // Add shield
                if (entity.equipment && entity.equipment.offHand && entity.equipment.offHand.type === 'shield') {
                    baseAC += entity.equipment.offHand.ac;
                }
              
                // Add other bonuses
                if (entity.equipment) {
                    Object.values(entity.equipment).forEach(item => {
                        if (item && item.ac && item.type !== 'armor' && item.type !== 'shield') {
                            baseAC += item.ac;
                        }
                    });
                }
              
                return baseAC;
            },
          
            // Roll Initiative
            rollInitiative() {
                this.entities.forEach(entity => {
                    if (entity.type !== 'item' && entity.type !== 'container' && entity.type !== 'visualEffect') {
                        const dexMod = this.getAbilityModifier(entity.dex);
                        const roll = this.rollDice('1d20');
                        entity.initiative = roll + dexMod;
                      
                        // Tiebreaker is dexterity score
                        entity.initiativeTiebreaker = entity.dex;
                    }
                });
              
                this.updateTurnOrder();
                this.currentTurn = 0;
                this.roundNumber = 1;
                this.resetTurnActions();
                this.addLog('🎲 Initiative rolled! Round 1 begins!', 'info');
                this.showActionDisplay('info', 'Initiative Rolled', 'Round 1 begins! Turn order has been set.');
            },

            // Get Entity by ID
            getEntity(id) {
                return this.entities.find(e => e.id === id);
            },

            // Update Entity Property
            updateEntity(id, property, value) {
                const entity = this.getEntity(id);
                if (entity) {
                    // Handle boolean values
                    if (value === 'true' || value === true) value = true;
                    if (value === 'false' || value === false) value = false;

                    entity[property] = value;

                    // Re-render to show changes
                    this.render();

                    // If updating character sheet properties, refresh the sheet
                    if (document.getElementById('characters-tab').classList.contains('active')) {
                        this.showCharacterSheet(entity);
                    }

                    this.addLog(`${entity.name} ${property} updated`, 'info');
                }
            },

            // Adjust HP manually
            adjustHP(id, amount) {
                const entity = this.getEntity(id);
                if (entity) {
                    entity.hp = Math.max(0, Math.min(entity.maxHp, entity.hp + amount));
                    this.render();

                    if (entity.hp === 0 && (entity.type === 'player' || entity.type === 'npc')) {
                        if (!entity.conditions.includes('unconscious')) {
                            this.addCondition(entity, 'unconscious');
                        }
                    }
                }
            },

            // Remove Entity
            removeEntity(id) {
                const entity = this.getEntity(id);
                if (entity && confirm(`Remove ${entity.name}?`)) {
                    this.entities = this.entities.filter(e => e.id !== id);
                    if (this.selectedEntity && this.selectedEntity.id === id) {
                        this.selectedEntity = null;
                    }
                    document.querySelectorAll('.details-panel, .action-menu').forEach(el => el.remove());
                    this.updateTurnOrder();
                    this.render();
                    this.addLog(`${entity.name} removed from board`, 'info');
                }
            },

            // Update Turn Order with proper tiebreaking
            updateTurnOrder() {
                this.turnOrder = this.entities
                    .filter(e => (e.type === 'player' || e.type === 'monster' || e.type === 'npc') && e.hp > 0)
                    .sort((a, b) => {
                        if (b.initiative !== a.initiative) {
                            return b.initiative - a.initiative;
                        }
                        return b.initiativeTiebreaker - a.initiativeTiebreaker;
                    });
              
                const div = document.getElementById('turnOrder');
                if (!div) return;
              
                div.innerHTML = '';
                this.turnOrder.forEach((entity, i) => {
                    const item = document.createElement('div');
                    item.className = `turn-item ${i === this.currentTurn ? 'active' : ''}`;
                    item.innerHTML = `
                        <span style="color: ${entity.color};">${entity.name}</span>
                        <div>
                            <span>Init: ${entity.initiative}</span>
                            <div class="turn-actions">
                                ${i === this.currentTurn ? this.getTurnActionsDisplay(entity) : ''}
                            </div>
                        </div>
                    `;
                    div.appendChild(item);
                });
            },
          
            // Get Turn Actions Display
            getTurnActionsDisplay(entity) {
                if (entity.type !== 'player' && entity.type !== 'monster' && entity.type !== 'npc') return '';
              
                return `
                    ${!entity.actionUsed ? '⚔️' : ''}
                    ${!entity.bonusActionUsed ? '⚡' : ''}
                    ${!entity.reactionUsed ? '🛡️' : ''}
                    ${entity.movement > 0 ? `👣${entity.movement}ft` : ''}
                `;
            },
          
            // Reset Turn Actions
            resetTurnActions() {
                if (this.turnOrder.length === 0) return;
              
                const current = this.turnOrder[this.currentTurn];
                if (current) {
                    current.actionUsed = false;
                    current.bonusActionUsed = false;
                    current.movement = current.speed;
                    current.disengaged = false;
                }
            },
          
            // Next Turn
            nextTurn() {
                if (this.turnOrder.length === 0) return;
              
                // Handle end of turn effects
                const current = this.turnOrder[this.currentTurn];
                if (current) {
                    this.handleEndOfTurn(current);
                }
              
                // Move to next
                this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
              
                // Check for new round
                if (this.currentTurn === 0) {
                    this.roundNumber++;
                    this.addLog(`📜 Round ${this.roundNumber} begins!`, 'info');
                    this.showActionDisplay('info', `Round ${this.roundNumber}`, 'A new round of combat begins!');
                  
                    // Reset reactions for all and update condition durations
                    this.entities.forEach(e => {
                        if (e.type === 'player' || e.type === 'monster' || e.type === 'npc') {
                            e.reactionUsed = false;
                          
                            // Decrement condition turn counters
                            Object.keys(e.conditionTurns).forEach(condition => {
                                e.conditionTurns[condition]--;
                                if (e.conditionTurns[condition] <= 0) {
                                    this.removeCondition(e, condition);
                                    delete e.conditionTurns[condition];
                                }
                            });
                        }
                    });
                }
              
                // Skip dead/unconscious
                while (this.turnOrder[this.currentTurn] &&
                       (this.turnOrder[this.currentTurn].hp <= 0 ||
                        this.turnOrder[this.currentTurn].conditions.includes('unconscious'))) {
                    if (this.turnOrder.every(e => e.hp <= 0 || e.conditions.includes('unconscious'))) {
                        this.addLog('Combat ended - no active combatants!', 'info');
                        this.showActionDisplay('info', 'Combat Ended', 'No active combatants remaining!');
                        return;
                    }
                    this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
                }
              
                const newCurrent = this.turnOrder[this.currentTurn];
                if (newCurrent) {
                    this.resetTurnActions();
                    this.handleStartOfTurn(newCurrent);
                    this.addLog(`➡️ ${newCurrent.name}'s turn begins!`, 'info');
                    this.showActionDisplay('info', 'Turn Start', `${newCurrent.name}'s turn begins!`);
                }
              
                this.updateTurnOrder();
                this.render();
            },
          
            // End Current Turn
            endTurn() {
                this.nextTurn();
            },
          
            // Handle Start of Turn
            handleStartOfTurn(entity) {
                // Regeneration
                if (entity.abilities) {
                    const regen = entity.abilities.find(a => a.name === 'Regeneration');
                    if (regen && entity.hp > 0 && entity.hp < entity.maxHp) {
                        const healing = 10; // Standard troll regen
                        entity.hp = Math.min(entity.maxHp, entity.hp + healing);
                        this.addLog(`${entity.name} regenerates ${healing} HP!`, 'heal');
                        this.createFloatingText(`+${healing}`, entity.x, entity.y - 30, '#00ff00');
                        this.playSound('heal');
                    }
                }
              
                // Death saves
                if (entity.hp === 0 && !entity.conditions.includes('stable')) {
                    this.rollDeathSave(entity);
                }
            },
          
            // Handle End of Turn
            handleEndOfTurn(entity) {
                // Nothing specific yet, but ready for concentration checks, etc.
            },
          
            // Roll Death Save
            rollDeathSave(entity) {
                const roll = this.rollDice('1d20');
              
                if (roll === 1) {
                    entity.deathSaves.failures += 2;
                    this.addLog(`${entity.name} critically fails death save! (${roll})`, 'death');
                    this.showActionDisplay('damage', 'Critical Death Save Failure', `${entity.name} rolled ${roll} - 2 failures added!`);
                } else if (roll === 20) {
                    entity.hp = 1;
                    entity.deathSaves.successes = 0;
                    entity.deathSaves.failures = 0;
                    this.addLog(`${entity.name} critically succeeds death save and regains consciousness with 1 HP!`, 'heal');
                    this.showActionDisplay('heal', 'Critical Death Save Success', `${entity.name} rolled ${roll} - returns to consciousness!`);
                } else if (roll >= 10) {
                    entity.deathSaves.successes++;
                    this.addLog(`${entity.name} succeeds death save (${roll}). Successes: ${entity.deathSaves.successes}/3`, 'save');
                    this.showActionDisplay('info', 'Death Save Success', `${entity.name} rolled ${roll} - ${entity.deathSaves.successes}/3 successes`);
                } else {
                    entity.deathSaves.failures++;
                    this.addLog(`${entity.name} fails death save (${roll}). Failures: ${entity.deathSaves.failures}/3`, 'death');
                    this.showActionDisplay('damage', 'Death Save Failure', `${entity.name} rolled ${roll} - ${entity.deathSaves.failures}/3 failures`);
                }
              
                if (entity.deathSaves.successes >= 3) {
                    entity.conditions.push('stable');
                    entity.deathSaves.successes = 0;
                    entity.deathSaves.failures = 0;
                    this.addLog(`${entity.name} is stabilized!`, 'heal');
                    this.showActionDisplay('heal', 'Stabilized', `${entity.name} is now stable!`);
                } else if (entity.deathSaves.failures >= 3) {
                    entity.conditions.push('dead');
                    this.addLog(`${entity.name} has died!`, 'death');
                    this.showActionDisplay('damage', 'Death', `${entity.name} has died!`);
                }
              
                this.render();
            },
          
            // Perform Attack
            performAttack(attacker, target, attack) {
                if (attacker.id === target.id) {
                    this.addLog('Cannot target self!', 'info');
                    return;
                }
              
                // Check if attacker can act
                if (this.enforceTurns && !this.editMode && this.turnOrder[this.currentTurn]?.id !== attacker.id) {
                    this.addLog('Not your turn!', 'info');
                    return;
                }
              
                if (attacker.actionUsed && !attack.bonusAction) {
                    this.addLog(`${attacker.name} has already used their action!`, 'info');
                    return;
                }
              
                // Roll to hit
                const d20 = this.rollDice('1d20', true);
                const profBonus = attacker.proficiencyBonus || 2;
                const abilityMod = attack.finesse ?
                    Math.max(this.getAbilityModifier(attacker.str), this.getAbilityModifier(attacker.dex)) :
                    this.getAbilityModifier(attack.ranged ? attacker.dex : attacker.str);
              
                let toHitBonus = (attack.toHit !== undefined) ? attack.toHit : abilityMod + profBonus;
              
                // Add equipment bonuses
                if (attacker.equipment && attacker.equipment.mainHand && attacker.equipment.mainHand.attackBonus) {
                    toHitBonus += attacker.equipment.mainHand.attackBonus;
                }
              
                // Check for advantage/disadvantage
                let hasAdvantage = false;
                let hasDisadvantage = false;
              
                if (attacker.conditions.includes('invisible')) hasAdvantage = true;
                if (attacker.conditions.includes('poisoned')) hasDisadvantage = true;
                if (attacker.conditions.includes('frightened')) hasDisadvantage = true;
                if (target.conditions.includes('paralyzed')) hasAdvantage = true;
                if (target.conditions.includes('stunned')) hasAdvantage = true;
                if (target.conditions.includes('unconscious')) hasAdvantage = true;
              
                let roll = d20;
                if (hasAdvantage && !hasDisadvantage) {
                    const second = this.rollDice('1d20', true);
                    roll = Math.max(d20, second);
                    this.showRollResult(`Attack Roll (Advantage)`, `${roll} (${d20}, ${second}) + ${toHitBonus} = ${roll + toHitBonus}`);
                } else if (hasDisadvantage && !hasAdvantage) {
                    const second = this.rollDice('1d20', true);
                    roll = Math.min(d20, second);
                    this.showRollResult(`Attack Roll (Disadvantage)`, `${roll} (${d20}, ${second}) + ${toHitBonus} = ${roll + toHitBonus}`);
                } else {
                    this.showRollResult(`Attack Roll`, `${roll} + ${toHitBonus} = ${roll + toHitBonus}`);
                }
              
                const totalHit = roll + toHitBonus;
                const targetAC = this.calculateAC(target);
              
                if (roll === 1) {
                    this.addLog(`${attacker.name} critically misses ${target.name}!`, 'info');
                    this.createFloatingText('CRITICAL MISS!', target.x, target.y - 30, '#808080');
                    this.showActionDisplay('info', 'Critical Miss', `${attacker.name} rolled a 1 attacking ${target.name}`);
                } else if (roll === 20 || totalHit >= targetAC) {
                    // Calculate damage and get weapon info
                    let damage = this.rollDice(attack.damage);
                    let weaponName = attack.name;
                    let damageType = attack.damageType;

                    // Override with equipped weapon stats
                    if (attacker.equipment && attacker.equipment.mainHand) {
                        const weapon = attacker.equipment.mainHand;
                        weaponName = weapon.name;
                        if (weapon.damageType) damageType = weapon.damageType;
                        if (weapon.damage) damage = this.rollDice(weapon.damage);
                    }

                    if (attack.name === 'Unarmed Strike') {
                        damage += this.getAbilityModifier(attacker.str);
                    }

                    if (roll === 20) {
                        damage *= 2;
                        this.addLog(`💥 ${attacker.name} CRITICALLY HITS ${target.name} with ${weaponName} for ${damage} ${damageType} damage!`, 'damage');
                        this.showActionDisplay('damage', 'Critical Hit!', `${attacker.name} deals ${damage} ${damageType} damage to ${target.name}`, `${weaponName} - Double damage from critical hit!`);
                    } else {
                        this.addLog(`⚔️ ${attacker.name} hits ${target.name} with ${weaponName} for ${damage} ${damageType} damage!`, 'damage');
                        this.showActionDisplay('damage', 'Attack Hit', `${attacker.name} deals ${damage} ${damageType} damage to ${target.name}`, `${weaponName} - Attack roll: ${totalHit} vs AC ${targetAC}`);
                    }
                  
                    // Apply damage
                    this.dealDamage(target, damage, attack.damageType);
                    this.createFloatingText(`-${damage}`, target.x, target.y - 30, '#ff0000');
                  
                    // Special effects
                    if (attack.special) {
                        this.applySpecialAttackEffect(target, attack.special);
                    }
                  
                    // Play sound and visual effects - prioritize equipped weapon's effects
                    let effectSound = attack.soundEffect;
                    let effectVisual = attack.visualEffect;

                    // Check if attacker has an equipped weapon with effects
                    if (attacker.equipment && attacker.equipment.mainHand) {
                        const weapon = attacker.equipment.mainHand;
                        if (weapon.soundEffect) effectSound = weapon.soundEffect;
                        if (weapon.visualEffect) effectVisual = weapon.visualEffect;
                    }

                    if (effectSound) {
                        this.playIndividualSound(effectSound);
                    } else {
                        this.playSound('attack');
                    }

                    if (effectVisual) {
                        this.playVisualEffect(effectVisual, target.x, target.y);
                    }
                } else {
                    this.addLog(`${attacker.name} misses ${target.name}! (${totalHit} vs AC ${targetAC})`, 'info');
                    this.createFloatingText('MISS', target.x, target.y - 30, '#808080');
                    this.showActionDisplay('info', 'Attack Miss', `${attacker.name} misses ${target.name}`, `Attack roll: ${totalHit} vs AC ${targetAC}`);
                }
              
                // Mark action used
                if (!attack.bonusAction) {
                    attacker.actionUsed = true;
                } else {
                    attacker.bonusActionUsed = true;
                }
              
                // Animation
                // Animation - adjust for token center
                const attackerCenterX = attacker.x;
                const attackerCenterY = attacker.y;
                const targetCenterX = target.x;
                const targetCenterY = target.y;

                this.createPersistentArrow(attackerCenterX, attackerCenterY, targetCenterX, targetCenterY);
                setTimeout(() => this.createArrowAnimation(attackerCenterX, attackerCenterY, targetCenterX, targetCenterY), 100);
              
                this.updateTurnOrder();
                this.render();
            },
          
            // Apply Special Attack Effect
            applySpecialAttackEffect(target, special) {
                // Parse special effects like "DC 13 Str save or knocked prone"
                if (special.includes('save')) {
                    const dcMatch = special.match(/DC (\d+)/);
                    const saveMatch = special.match(/(Str|Dex|Con|Int|Wis|Cha)/i);
                  
                    if (dcMatch && saveMatch) {
                        const dc = parseInt(dcMatch[1]);
                        const ability = saveMatch[1].toLowerCase();
                        const mod = this.getAbilityModifier(target[ability]);
                        const roll = this.rollDice('1d20');
                        const total = roll + mod;
                      
                        if (total < dc) {
                            if (special.includes('prone')) {
                                this.addCondition(target, 'prone');
                                this.addLog(` ${target.name} is knocked prone! (Save: ${total} vs DC ${dc})`, 'info');
                                this.showActionDisplay('info', 'Saving Throw Failed', `${target.name} fails save and is knocked prone`, `${total} vs DC ${dc}`);
                            } else if (special.includes('poison')) {
                                const poisonDamage = this.rollDice('2d8');
                                this.dealDamage(target, poisonDamage, 'poison');
                                this.addLog(`${target.name} takes ${poisonDamage} poison damage! (Save: ${total} vs DC ${dc})`, 'damage');
                                this.showActionDisplay('damage', 'Poison Damage', `${target.name} takes ${poisonDamage} poison damage`, `Failed save: ${total} vs DC ${dc}`);
                            }
                        } else {
                            this.addLog(`${target.name} resists the effect! (Save: ${total} vs DC ${dc})`, 'info');
                            this.showActionDisplay('info', 'Saving Throw Success', `${target.name} resists the effect`, `${total} vs DC ${dc}`);
                        }
                    }
                }
            },
          
            // Deal Damage (with resistances/immunities/vulnerabilities)
            dealDamage(target, amount, damageType) {
                let finalDamage = amount;
              
                // Check immunities
                if (target.damageImmunities && target.damageImmunities.includes(damageType)) {
                    this.addLog(`${target.name} is immune to ${damageType} damage!`, 'info');
                    this.showActionDisplay('info', 'Damage Immunity', `${target.name} takes no damage from ${damageType}`);
                    return;
                }
              
                // Check resistances
                if (target.damageResistances && target.damageResistances.includes(damageType)) {
                    finalDamage = Math.floor(finalDamage / 2);
                    this.addLog(`${target.name} resists ${damageType} damage!`, 'info');
                    this.showActionDisplay('info', 'Damage Resistance', `${target.name} takes half damage from ${damageType}`, `${amount} reduced to ${finalDamage}`);
                }
              
                // Check vulnerabilities
                if (target.damageVulnerabilities && target.damageVulnerabilities.includes(damageType)) {
                    finalDamage = finalDamage * 2;
                    this.addLog(`${target.name} is vulnerable to ${damageType} damage!`, 'info');
                    this.showActionDisplay('damage', 'Damage Vulnerability', `${target.name} takes double damage from ${damageType}`, `${amount} increased to ${finalDamage}`);
                }
              
                // Apply to temp HP first
                if (target.tempHp > 0) {
                    const tempDamage = Math.min(target.tempHp, finalDamage);
                    target.tempHp -= tempDamage;
                    finalDamage -= tempDamage;
                }
              
                // Then regular HP
                target.hp = Math.max(0, target.hp - finalDamage);
              
                // Check for death/unconscious
                if (target.hp === 0) {
                    if (target.type === 'player' || target.type === 'npc') {
                        if (!target.conditions.includes('unconscious')) {
                            this.addCondition(target, 'unconscious');
                            this.addLog(`${target.name} falls unconscious!`, 'death');
                            this.showActionDisplay('damage', 'Unconscious', `${target.name} falls unconscious at 0 HP`);
                        }
                    } else if (target.type === 'monster') {
                        this.addCondition(target, 'dead');
                        this.addLog(`${target.name} is defeated!`, 'death');
                        this.showActionDisplay('damage', 'Defeated', `${target.name} is defeated!`);
                      
                        // Drop inventory items when monster dies
                        if (Math.random() < 0.3) { // 30% chance for loot if no inventory
                            const lootTable = [...this.library.items, ...this.library.equipment];
                            const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                            target.inventory.push(JSON.parse(JSON.stringify(randomLoot)));
                        }
                        if (target.inventory && target.inventory.length > 0) {
                            target.inventory.forEach((item, index) => {
                                const angle = (index / target.inventory.length) * Math.PI * 2;
                                const distance = 60 + (index * 15); // Spread items around the dead monster
                                const newX = target.x + Math.cos(angle) * distance;
                                const newY = target.y + Math.sin(angle) * distance;
                              
                                const newItem = this.createEntity('item', item.name, newX, newY);
                                Object.assign(newItem, item);
                                newItem.id = this.nextId++;
                                newItem.x = newX;
                                newItem.y = newY;
                                this.entities.push(newItem);
                            });
                            this.addLog(`${target.name} drops ${target.inventory.length} items!`, 'info');
                            this.showActionDisplay('info', 'Loot Dropped', `${target.name} drops ${target.inventory.length} items`);
                        }
                    }
                }
                if ((target.type === 'player' || target.type === 'npc') && target.soundEffect) {
                    this.playIndividualSound(target.soundEffect)
                }
            },
          
            // Cast Spell
            castSpell(caster, target, spell, spellLevel = null, pos = null) {
                if (caster.id === target?.id && spell.name !== 'Shield' && spell.name !== 'Misty Step') {
                    this.addLog('Cannot target self with this spell!', 'info');
                    return;
                }
              
                // Check spell slots
                const actualLevel = spellLevel || spell.level;
                if (spell.level > 0) {
                    if (!caster.spellSlots || caster.spellSlots[actualLevel] <= caster.spellSlotsUsed[actualLevel]) {
                        this.addLog(`${caster.name} has no level ${actualLevel} spell slots remaining!`, 'info');
                        return;
                    }
                }
              
                // Check action economy
                if (spell.castingTime === 'action' && caster.actionUsed) {
                    this.addLog(`${caster.name} has already used their action!`, 'info');
                    return;
                } else if (spell.castingTime === 'bonus action' && caster.bonusActionUsed) {
                    this.addLog(`${caster.name} has already used their bonus action!`, 'info');
                    return;
                } else if (spell.castingTime === 'reaction' && caster.reactionUsed) {
                    this.addLog(`${caster.name} has already used their reaction!`, 'info');
                    return;
                }
              
                // Cast the spell
                this.addLog(`✨ ${caster.name} casts ${spell.name}${actualLevel > spell.level ? ` at level ${actualLevel}` : ''}!`, 'info');
                this.showActionDisplay('spell', 'Spell Cast', `${caster.name} casts ${spell.name}`, actualLevel > spell.level ? `Upcast to level ${actualLevel}` : '');
              
                // Play sound and visual effects
                if (spell.soundEffect) {
                    this.playIndividualSound(spell.soundEffect);
                } else {
                    this.playSound('spell');
                }
              
                if (spell.visualEffect) {
                    let vfxX = target ? target.x : pos?.x || caster.x;
                    let vfxY = target ? target.y : pos?.y || caster.y;
                    if (spell.visualPattern === 'shoot') {
                        this.createSpellAnimation(caster.x + 35, caster.y + 35, vfxX + 35, vfxY + 35, spell.school);
                    } else if (spell.visualPattern === 'aoe') {
                        this.playVisualEffect(spell.visualEffect, vfxX, vfxY);
                    } else {
                        this.playVisualEffect(spell.visualEffect, vfxX, vfxY);
                    }
                }
              
                // Use spell slot
                if (spell.level > 0) {
                    caster.spellSlotsUsed[actualLevel]++;
                }
              
                // Handle concentration
                if (spell.concentration) {
                    if (caster.concentrating) {
                        this.addLog(`${caster.name} loses concentration on ${caster.concentrating}`, 'info');
                    }
                    caster.concentrating = spell.name;
                }
              
                // Apply spell effects
                if (spell.damage) {
                    let damage = this.rollDice(spell.damage);
                  
                    // Higher level casting
                    if (actualLevel > spell.level && spell.higherLevel) {
                        const extraLevels = actualLevel - spell.level;
                        const extraDamage = this.rollDice(`${extraLevels}d6`);
                        damage += extraDamage;
                    }
                  
                    if (spell.savingThrow) {
                        const saveMod = this.getAbilityModifier(target[spell.savingThrow.substr(0, 3)]);
                        const saveRoll = this.rollDice('1d20');
                        const saveTotal = saveRoll + saveMod;
                      
                        if (saveTotal >= spell.saveDC) {
                            damage = Math.floor(damage / 2);
                            this.addLog(`${target.name} saves! (${saveTotal} vs DC ${spell.saveDC}) Half damage.`, 'save');
                            this.showActionDisplay('info', 'Saving Throw Success', `${target.name} takes half damage`, `${saveTotal} vs DC ${spell.saveDC}`);
                        } else {
                            this.addLog(`${target.name} fails save! (${saveTotal} vs DC ${spell.saveDC})`, 'save');
                            this.showActionDisplay('damage', 'Saving Throw Failed', `${target.name} takes full damage`, `${saveTotal} vs DC ${spell.saveDC}`);
                        }
                    }
                  
                    this.dealDamage(target, damage, spell.damageType);
                    this.createFloatingText(`-${damage}`, target.x, target.y - 30, '#ff00ff');
                } else if (spell.healing) {
                    let healing = this.rollDice(spell.healing.replace('mod', '3'));
                  
                    // Higher level casting
                    if (actualLevel > spell.level && spell.higherLevel) {
                        const extraLevels = actualLevel - spell.level;
                        const extraHealing = this.rollDice(`${extraLevels}d8`);
                        healing += extraHealing;
                    }
                  
                    target.hp = Math.min(target.maxHp, target.hp + healing);
                    this.addLog(`${target.name} heals ${healing} HP!`, 'heal');
                    this.createFloatingText(`+${healing}`, target.x, target.y - 30, '#00ff00');
                    this.showActionDisplay('heal', 'Healing', `${target.name} regains ${healing} HP`, `Current HP: ${target.hp}/${target.maxHp}`);
                    this.playSound('heal');
                } else if (spell.effect) {
                    this.applySpellEffect(caster, target, spell.effect, spell);
                }
              
                // Mark action used
                if (spell.castingTime === 'action') caster.actionUsed = true;
                else if (spell.castingTime === 'bonus action') caster.bonusActionUsed = true;
                else if (spell.castingTime === 'reaction') caster.reactionUsed = true;
              
                // Animation
                this.createPersistentArrow(caster.x + 35, caster.y + 35, target.x + 35, target.y + 35);
                setTimeout(() => this.createSpellAnimation(caster.x + 35, caster.y + 35, target.x + 35, target.y + 35, spell.school), 100);
              
                this.updateTurnOrder();
                this.render();
            },
          
            // Apply Spell Effect
            applySpellEffect(caster, target, effect, spell) {
                switch (effect.type) {
                    case 'condition':
                        if (spell.savingThrow) {
                            const saveMod = this.getAbilityModifier(target[spell.savingThrow.substr(0, 3)]);
                            const saveRoll = this.rollDice('1d20');
                            const saveTotal = saveRoll + saveMod;
                          
                            if (saveTotal >= spell.saveDC) {
                                this.addLog(`${target.name} resists! (${saveTotal} vs DC ${spell.saveDC})`, 'save');
                                this.showActionDisplay('info', 'Condition Resisted', `${target.name} resists ${effect.condition}`, `${saveTotal} vs DC ${spell.saveDC}`);
                                return;
                            }
                        }
                        this.addCondition(target, effect.condition);
                        this.showActionDisplay('info', 'Condition Applied', `${target.name} is now ${effect.condition}`);
                        break;
                      
                    case 'ac_bonus':
                        target.ac += effect.value;
                        this.addLog(`${target.name} gains +${effect.value} AC!`, 'info');
                        this.showActionDisplay('info', 'AC Bonus', `${target.name} gains +${effect.value} AC`);
                        break;
                      
                    case 'ac_set':
                        const dexMod = this.getAbilityModifier(target.dex);
                        target.ac = effect.value + dexMod;
                        this.addLog(`${target.name}'s AC is now ${target.ac}!`, 'info');
                        this.showActionDisplay('info', 'AC Changed', `${target.name}'s AC is now ${target.ac}`);
                        break;
                      
                    case 'buff':
                        this.addLog(`${target.name} is buffed: ${effect.effects.join(', ')}`, 'info');
                        this.showActionDisplay('info', 'Buff Applied', `${target.name} gains ${effect.effects.join(', ')}`);
                        // Store buff for later reference
                        if (!target.buffs) target.buffs = [];
                        target.buffs.push({name: spell.name, effects: effect.effects});
                        break;
                      
                    case 'debuff':
                        this.addLog(`${target.name} is debuffed: ${effect.effects.join(', ')}`, 'info');
                        this.showActionDisplay('info', 'Debuff Applied', `${target.name} suffers ${effect.effects.join(', ')}`);
                        if (!target.debuffs) target.debuffs = [];
                        target.debuffs.push({name: spell.name, effects: effect.effects});
                        break;
                      
                    case 'teleport':
                        // Move caster
                        const angle = Math.random() * Math.PI * 2;
                        caster.x += Math.cos(angle) * effect.distance * 5; // 5 pixels per foot
                        caster.y += Math.sin(angle) * effect.distance * 5;
                        this.addLog(`${caster.name} teleports!`, 'info');
                        this.showActionDisplay('info', 'Teleport', `${caster.name} teleports ${effect.distance} feet`);
                        break;
                      
                    case 'sleep':
                        const hpPool = this.rollDice(effect.hitpoints);
                        this.addLog(`Sleep affects ${hpPool} HP worth of creatures`, 'info');
                        this.showActionDisplay('spell', 'Sleep Effect', `Affects ${hpPool} HP worth of creatures`);
                        // Would need to implement area selection for full effect
                        break;
                }
            },
          
            // Add Condition
            addCondition(entity, condition, turns = null) {
                if (!entity.conditions.includes(condition)) {
                    // Remove conflicting conditions
                    if (condition === 'unconscious') {
                        entity.hp = 0;
                    }
                  
                    entity.conditions.push(condition);
                  
                    // Track turns if specified
                    if (turns && turns > 0) {
                        if (!entity.conditionTurns) entity.conditionTurns = {};
                        entity.conditionTurns[condition] = turns;
                    }
                  
                    this.addLog(`${entity.name} is now ${condition}!`, 'info');
                    this.showActionDisplay('info', 'Condition Added', `${entity.name} is now ${condition}`);
                  
                    // Apply condition effects
                    const conditionData = this.conditions[condition];
                    if (conditionData && conditionData.effects) {
                        if (conditionData.effects.speed === 0) {
                            entity.movement = 0;
                        }
                    }
                }
                this.render();
            },
          
            // Remove Condition
            removeCondition(entity, condition) {
                const idx = entity.conditions.indexOf(condition);
                if (idx > -1) {
                    entity.conditions.splice(idx, 1);
                    if (entity.conditionTurns && entity.conditionTurns[condition]) {
                        delete entity.conditionTurns[condition];
                    }
                    this.addLog(`${entity.name} is no longer ${condition}!`, 'info');
                    this.showActionDisplay('info', 'Condition Removed', `${entity.name} is no longer ${condition}`);
                  
                    // Restore normal state
                    if (condition === 'unconscious' && entity.hp === 0) {
                        entity.hp = 1;
                    }
                }
                this.render();
            },
          
            // Enhanced Play Individual Sound function
            playIndividualSound(url) {
                if (url) {
                    const audio = new Audio(url);
                    audio.play().catch(e => console.log('Sound play failed:', e));
                }
            },
          
            // Roll Dice with display
            rollDice(formula, silent = false) {
                if (!formula) return 0;
              
                // Handle pure numbers
                if (!isNaN(formula)) return parseInt(formula);
              
                const match = formula.match(/(\d+)d(\d+)([+-]\d+)?/);
                if (!match) return parseInt(formula) || 0;
              
                const [, num, sides, mod] = match;
                const rolls = [];
                let total = 0;
              
                for (let i = 0; i < parseInt(num); i++) {
                    const roll = Math.floor(Math.random() * parseInt(sides)) + 1;
                    rolls.push(roll);
                    total += roll;
                }
              
                if (mod) total += parseInt(mod);
                total = Math.max(0, total);
              
                // Log the roll
                if (!silent) {
                    this.diceRollHistory.push({
                        formula,
                        rolls,
                        modifier: mod ? parseInt(mod) : 0,
                        total
                    });
                  
                    if (this.diceRollHistory.length > 20) {
                        this.diceRollHistory.shift();
                    }
                    this.showRollResult(`Roll: ${formula}`, `Total: ${total} (${rolls.join(', ')}${mod ? ` ${mod}` : ''})`);
                }
              
                return total;
            },
          
            // Show Roll Result
            showRollResult(title, breakdown) {
                this.showActionDisplay('roll', title, breakdown);
            },
          
            // Play Sound
            playSound(type) {
                const url = this.sounds[type];
                if (url) {
                    const audio = new Audio(url);
                    audio.play().catch(e => console.log('Sound play failed:', e));
                }
            },

            // Play Visual Effect
            playVisualEffect(url, x, y, width = 100, height = 100, duration = 2) {
                if (!url) return;

                console.log('Playing VFX:', url, 'at position', x, y);

                const effect = document.createElement('div');
                effect.className = 'spell-effect';
                effect.style.left = `${x - width / 2}px`;
                effect.style.top = `${y - height / 2}px`;
                effect.style.width = `${width}px`;
                effect.style.height = `${height}px`;
                effect.style.position = 'absolute';
                effect.style.pointerEvents = 'none';
                effect.style.zIndex = '1000';
                effect.innerHTML = `<img src="${url}" style="width: 100%; height: 100%; object-fit: contain;">`;

                document.getElementById('boardCanvas').appendChild(effect);

                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, duration * 1000);
            },
          
            // Set Sound
            setSound(type, url) {
                this.sounds[type] = url;
                localStorage.setItem('dndSounds', JSON.stringify(this.sounds));
            },
          
            // Load Sounds
            loadSounds() {
                const saved = localStorage.getItem('dndSounds');
                if (saved) {
                    this.sounds = JSON.parse(saved);
                    Object.keys(this.sounds).forEach(type => {
                        const element = document.getElementById(`sound${type.charAt(0).toUpperCase() + type.slice(1)}`);
                        if (element) {
                            element.value = this.sounds[type];
                        }
                    });
                }
              
                // Load background music
                const savedMusic = localStorage.getItem('dndBackgroundMusic');
                if (savedMusic) {
                    const musicInput = document.getElementById('backgroundMusic');
                    if (musicInput) musicInput.value = savedMusic;
                    this.setBackgroundMusic(savedMusic);
                }
            },
          
            // Equipment Management
            equipItem(entity, item) {
                if (!item || !item.equipSlot) return;
              
                const slot = item.equipSlot;
                const currentItem = entity.equipment[slot];
              
                // Unequip current item
                if (currentItem) {
                    this.unequipItem(entity, currentItem);
                }
              
                // Equip new item
                entity.equipment[slot] = item;
              
                // Apply effects
                if (item.attackBonus) {
                    entity.attacks.forEach(attack => {
                        attack.toHit = (attack.toHit || 0) + item.attackBonus;
                    });
                }
              
                if (item.damageBonus) {
                    entity.attacks.forEach(attack => {
                        const current = parseInt(attack.damage.match(/[+-]\d+$/)?.[0] || '0');
                        attack.damage = attack.damage.replace(/[+-]\d+$/, '') +
                                      (current + item.damageBonus >= 0 ? '+' : '') +
                                      (current + item.damageBonus);
                    });
                }
              
                if (item.effect) {
                    this.applyEquipmentEffect(entity, item.effect, true);
                }
              
                // Remove from inventory
                const idx = entity.inventory.findIndex(i => i === item);
                if (idx > -1) entity.inventory.splice(idx, 1);
              
                // Recalculate AC
                entity.ac = this.calculateAC(entity);
              
                this.addLog(`${entity.name} equips ${item.name}`, 'info');
                this.showActionDisplay('info', 'Item Equipped', `${entity.name} equips ${item.name}`);
                this.render();
            },
          
            unequipItem(entity, item) {
                if (!item || !item.equipSlot) return;
              
                const slot = item.equipSlot;
                entity.equipment[slot] = null;
              
                // Reverse effects
                if (item.attackBonus) {
                    entity.attacks.forEach(attack => {
                        attack.toHit = (attack.toHit || 0) - item.attackBonus;
                    });
                }
              
                if (item.damageBonus) {
                    entity.attacks.forEach(attack => {
                        const current = parseInt(attack.damage.match(/[+-]\d+$/)?.[0] || '0');
                        const newBonus = current - item.damageBonus;
                        attack.damage = attack.damage.replace(/[+-]\d+$/, '') +
                                      (newBonus !== 0 ? (newBonus >= 0 ? '+' : '') + newBonus : '');
                    });
                }
              
                if (item.effect) {
                    this.applyEquipmentEffect(entity, item.effect, false);
                }
              
                // Add to inventory
                entity.inventory.push(item);
              
                // Recalculate AC
                entity.ac = this.calculateAC(entity);
              
                this.addLog(`${entity.name} unequips ${item.name}`, 'info');
                this.showActionDisplay('info', 'Item Unequipped', `${entity.name} unequips ${item.name}`);
                this.render();
            },
          
            // Apply Equipment Effect
            applyEquipmentEffect(entity, effect, apply) {
                const multiplier = apply ? 1 : -1;
              
                switch (effect.type) {
                    case 'ability_score':
                        if (apply) {
                            entity[`original_${effect.ability}`] = entity[effect.ability];
                            entity[effect.ability] = effect.value;
                        } else {
                            entity[effect.ability] = entity[`original_${effect.ability}`] || entity[effect.ability];
                        }
                        break;
                      
                    case 'speed':
                        entity.speed += effect.bonus * multiplier;
                        entity.movement = entity.speed;
                        break;
                      
                    case 'advantage':
                        // Track for later use in rolls
                        if (!entity.advantages) entity.advantages = {};
                        entity.advantages[effect.skill] = apply;
                        break;
                }
            },
          
            // Use Item
            useItem(user, item, target = null) {
                if (user.id === target.id && !item.healing) {
                    this.addLog('Cannot target self with this item!', 'info');
                    return;
                }
              
                target = target || user;
              
                if (item.healing) {
                    const healing = this.rollDice(item.healing);
                    target.hp = Math.min(target.maxHp, target.hp + healing);
                    this.addLog(`${user.name} uses ${item.name} on ${target.name}, healing ${healing} HP!`, 'heal');
                    this.createFloatingText(`+${healing}`, target.x, target.y - 30, '#00ff00');
                    this.showActionDisplay('heal', 'Item Used', `${target.name} heals ${healing} HP from ${item.name}`, `Current HP: ${target.hp}/${target.maxHp}`);
                  
                    // Play individual sound effect or fallback
                    if (item.soundEffect) {
                        this.playIndividualSound(item.soundEffect);
                    } else {
                        this.playSound('heal');
                    }
                  
                    // Play visual effect
                    if (item.visualEffect) {
                        this.playVisualEffect(item.visualEffect, target.x, target.y);
                    }
                } else if (item.effect) {
                    this.applyItemEffect(target, item.effect);
                    this.addLog(`${user.name} uses ${item.name} on ${target.name}!`, 'info');
                    this.showActionDisplay('info', 'Item Used', `${user.name} uses ${item.name} on ${target.name}`);
                  
                    if (item.soundEffect) {
                        this.playIndividualSound(item.soundEffect);
                    }
                  
                    if (item.visualEffect) {
                        this.playVisualEffect(item.visualEffect, target.x, target.y);
                    }
                } else if (item.spell) {
                    // Scroll
                    const spell = this.library.spells.find(s => s.name === item.spell);
                    if (spell) {
                        this.castSpell(user, target, spell);
                    }
                }
              
                // Remove if consumable
                if (item.consumable) {
                    const idx = user.inventory.findIndex(i => i === item);
                    if (idx > -1) user.inventory.splice(idx, 1);
                }
              
                this.render();
            },
          
            // Apply Item Effect
            applyItemEffect(target, effect) {
                switch (effect.type) {
                    case 'condition':
                        this.addCondition(target, effect.condition);
                        if (effect.duration) {
                            // Track for later removal
                            setTimeout(() => this.removeCondition(target, effect.condition), effect.duration * 60000);
                        }
                        break;
                      
                    case 'buff':
                        if (!target.buffs) target.buffs = [];
                        target.buffs.push({effects: effect.effects, duration: effect.duration});
                        break;
                      
                    case 'advantage':
                        if (!target.advantages) target.advantages = {};
                        effect.saves.forEach(save => {
                            target.advantages[save] = true;
                        });
                        if (effect.duration) {
                            setTimeout(() => {
                                effect.saves.forEach(save => {
                                    target.advantages[save] = false;
                                });
                            }, effect.duration * 60000);
                        }
                        break;
                }
            },
          
            // Render entities and board
            render() {
                const canvas = document.getElementById('boardCanvas');
                if (!canvas) return;

                canvas.innerHTML = '';

                // Apply zoom and pan transform to container
                const container = document.getElementById('boardContainer');
                if (container) {
                    container.style.transform = `scale(${this.zoom}) translate(${this.panX}px, ${this.panY}px)`;
                    container.style.transformOrigin = '0 0';
                }
              
                // Draw movement range for current turn
                if (this.showMovementRange && this.turnOrder.length > 0 && !this.editMode) {
                    const current = this.turnOrder[this.currentTurn];
                    if (current && current.movement > 0) {
                        const range = document.createElement('div');
                        range.className = 'movement-range';
                        const radius = current.movement * 5; // 5 pixels per foot
                        range.style.width = radius * 2 + 'px';
                        range.style.height = radius * 2 + 'px';
                        range.style.left = (current.x - radius) + 'px';
                        range.style.top = (current.y - radius) + 'px';
                        canvas.appendChild(range);
                    }
                }
              
                // Render entities
                this.entities.forEach(entity => {
                    if (entity.type === 'visualEffect') {
                        this.renderVisualEffect(entity, canvas);
                        return;
                    }
                  
                    const elem = document.createElement('div');
                    elem.className = 'entity';
                    elem.dataset.id = entity.id;
                  
                    // Add type-specific classes
                    if (entity.type === 'npc') {
                        elem.classList.add('npc');
                    }
                  
                    // Add condition classes
                    if (entity.conditions && entity.conditions.includes('dead')) {
                        elem.classList.add('dead');
                    } else if (entity.conditions && entity.conditions.includes('unconscious')) {
                        elem.classList.add('unconscious');
                    } else if (entity.conditions && entity.conditions.includes('hidden')) {
                        elem.classList.add('hidden');
                    }
                  
                    if (this.selectedEntity && this.selectedEntity.id === entity.id) {
                        elem.classList.add('selected');
                    }
                  
                    if (this.targetingMode && entity.id !== this.targetingMode.source.id) {
                        elem.classList.add('valid-target');
                    }
                  
                    // Apply scaling
                    const scale = entity.scale || 1.0;
                    const size = 70 * scale;
                    elem.style.width = size + 'px';
                    elem.style.height = size + 'px';
                    elem.style.left = (entity.x - size/2) + 'px';
                    elem.style.top = (entity.y - size/2) + 'px';
                  
                    const borderColor = entity.type === 'player' ? '#60a5fa' :
                                      entity.type === 'npc' ? '#f59e0b' :
                                      entity.type === 'monster' ? '#ef4444' : '#fbbf24';
                  
                    let content = '';
                    if (entity.image) {
                        content = `<img src="${entity.image}" class="entity-image" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                         <span class="entity-content" style="display:none;">${entity.name[0]}</span>`;
                    } else {
                        content = `<span class="entity-content">${entity.name[0]}</span>`;
                    }
                  
                    let hpBar = '';
                    if (entity.type !== 'item' && entity.type !== 'container') {
                        const hpPercent = entity.hp / entity.maxHp * 100;
                        const hpClass = hpPercent > 75 ? 'high' : hpPercent > 25 ? 'medium' : 'low';
                        hpBar = `
        <div class="hp-bar">
            <div class="hp-fill ${hpClass}" style="width: ${hpPercent}%"></div>
            ${this.editMode ? `
            <button class="hp-adjust-btn hp-minus" onclick="event.stopPropagation(); game.adjustHP(${entity.id}, -1)">−</button>
            <button class="hp-adjust-btn hp-plus" onclick="event.stopPropagation(); game.adjustHP(${entity.id}, 1)">+</button>
            ` : ''}
        </div>
    `;
                    }
                  
                    let deathSaves = '';
                    if (entity.hp === 0 && (entity.type === 'player' || entity.type === 'npc') && (!entity.conditions || !entity.conditions.includes('dead'))) {
                        deathSaves = '<div class="death-saves-indicator">';
                        for (let i = 0; i < 3; i++) {
                            deathSaves += `<div class="death-save-dot ${i < entity.deathSaves.successes ? 'success' : ''}"></div>`;
                        }
                        for (let i = 0; i < 3; i++) {
                            deathSaves += `<div class="death-save-dot ${i < entity.deathSaves.failures ? 'failure' : ''}"></div>`;
                        }
                        deathSaves += '</div>';
                    }
                  
                    let conditionsBadge = '';
                    if (entity.conditions && entity.conditions.length > 0 && !entity.conditions.includes('dead')) {
                        conditionsBadge = `<div class="conditions-badge">${entity.conditions.length}</div>`;
                    }
                  
                    // Status Effect Indicators
                    let statusIndicator = '';
                    if (entity.conditions && entity.conditions.length > 0) {
                        if (entity.conditions.includes('dead')) {
                            statusIndicator = '<div class="status-indicator death">💀</div>';
                        } else if (entity.conditions.includes('unconscious') || entity.conditions.includes('prone')) {
                            statusIndicator = '<div class="status-indicator unconscious">❌</div>';
                        } else {
                            // Show number of active conditions with turns remaining
                            const conditionsWithTurns = entity.conditions.filter(c =>
                                entity.conditionTurns && entity.conditionTurns[c] > 0
                            );
                            if (conditionsWithTurns.length > 0) {
                                const maxTurns = Math.max(...conditionsWithTurns.map(c => entity.conditionTurns[c]));
                                statusIndicator = `<div class="status-indicator condition">${maxTurns}</div>`;
                            }
                        }
                    }
                  
                    let nameDisplay = entity.name;
                    if (entity.type === 'player' || entity.type === 'monster' || entity.type === 'npc') {
                        nameDisplay += ` (${entity.hp}/${entity.maxHp})`;
                    } else if (entity.type === 'container') {
                        if (!entity.inventory || entity.inventory.length === 0) {
                            nameDisplay = 'Empty Chest';
                        } else {
                            nameDisplay += ` (${entity.inventory.length} items)`;
                        }
                    } else if (entity.type === 'item') {
                        // Items just show their name, no additional info
                        nameDisplay = entity.name;
                        if (entity.rarity && entity.rarity !== 'common') {
                            nameDisplay += ` (${entity.rarity})`;
                        }
                    }
                  
                    elem.innerHTML = `
                        <div class="entity-circle" style="background: ${entity.color}; border-color: ${borderColor};">
                            ${content}
                            ${hpBar}
                            <div class="entity-name">${nameDisplay}</div>
                            ${deathSaves}
                            ${conditionsBadge}
                            ${statusIndicator}
                        </div>
                    `;
                  
                    elem.addEventListener('click', () => this.selectEntity(entity));
                    elem.draggable = true;
                    elem.addEventListener('dragstart', (e) => this.handleDragStart(e, entity));
                    elem.addEventListener('dragend', (e) => this.handleDragEnd(e, entity));
                  
                    // Add wheel event for token resizing in edit mode
                    elem.addEventListener('wheel', (e) => {
                        if (this.editMode && this.selectedEntity && this.selectedEntity.id === entity.id) {
                            e.preventDefault();
                            const scaleChange = e.deltaY > 0 ? -0.1 : 0.1;
                            entity.scale = Math.max(0.5, Math.min(4.0, (entity.scale || 1.0) + scaleChange));
                            this.render();
                        }
                    });
                  
                    canvas.appendChild(elem);
                });
            },
            renderVisualEffect(effect, canvas) {
                const elem = document.createElement('div');
                elem.className = 'visual-effect';
                elem.dataset.id = effect.id;
              
                if (effect.mode === 'decoration') {
                    elem.classList.add('decoration');
                }
              
                elem.style.left = (effect.x - effect.width/2) + 'px';
                elem.style.top = (effect.y - effect.height/2) + 'px';
                elem.style.width = effect.width + 'px';
                elem.style.height = effect.height + 'px';
              
                if (effect.mode === 'once') {
                    const elapsed = Date.now() - effect.startTime;
                    if (elapsed > effect.duration * 1000) {
                        // Remove effect after duration
                        this.entities = this.entities.filter(e => e.id !== effect.id);
                        return;
                    }
                    elem.innerHTML = `<img src="${effect.url}" style="width: 100%; height: 100%; object-fit: contain;">`;
                } else {
                    elem.innerHTML = `<img src="${effect.url}" style="width: 100%; height: 100%; object-fit: contain;">`;
                }
              
                // Make effects draggable and selectable in edit mode
                if (this.editMode) {
                    elem.style.pointerEvents = 'auto';
                    elem.addEventListener('click', () => this.selectEntity(effect));
                    elem.draggable = true;
                    elem.addEventListener('dragstart', (e) => this.handleDragStart(e, effect));
                    elem.addEventListener('dragend', (e) => this.handleDragEnd(e, effect));

                    // Add wheel event for resizing visual effects
                    elem.addEventListener('wheel', (e) => {
                        if (this.editMode && this.selectedEntity && this.selectedEntity.id === effect.id) {
                            e.preventDefault();
                            const sizeChange = e.deltaY > 0 ? -10 : 10;
                            effect.width = Math.max(20, effect.width + sizeChange);
                            effect.height = Math.max(20, effect.height + sizeChange);
                            this.render();
                        }
                    });
                }
              
                canvas.appendChild(elem);
            },
          
            // Toggle Edit Mode
            toggleEditMode() {
                this.editMode = !this.editMode;
                const btn = document.getElementById('editToggle');
                btn.classList.toggle('active', this.editMode);
                this.addLog(`Edit mode ${this.editMode ? 'enabled' : 'disabled'}`, 'info');
                this.render();
            },
          
            // Drag Arrow Functions
            createDragArrow(startX, startY, endX, endY) {
                if (this.dragArrow) {
                    this.dragArrow.remove();
                }
              
                const angle = Math.atan2(endY - startY, endX - startX);
                const distance = Math.hypot(endX - startX, endY - startY);
              
                this.dragArrow = document.createElement('div');
                this.dragArrow.className = 'drag-arrow';
                this.dragArrow.style.left = `${startX}px`;
                this.dragArrow.style.top = `${startY}px`;
                this.dragArrow.style.width = `${distance}px`;
                this.dragArrow.style.transform = `rotate(${angle}rad)`;
              
                document.getElementById('boardCanvas').appendChild(this.dragArrow);
            },
          
            removeDragArrow() {
                if (this.dragArrow) {
                    this.dragArrow.remove();
                    this.dragArrow = null;
                }
            },
          
            createPersistentArrow(startX, startY, endX, endY) {
                if (this.persistentArrow) {
                    this.persistentArrow.remove();
                }
              
                const angle = Math.atan2(endY - startY, endX - startX);
                const distance = Math.hypot(endX - startX, endY - startY);
              
                this.persistentArrow = document.createElement('div');
                this.persistentArrow.className = 'persistent-arrow';
                this.persistentArrow.style.left = `${startX}px`;
                this.persistentArrow.style.top = `${startY}px`;
                this.persistentArrow.style.width = `${distance}px`;
                this.persistentArrow.style.transform = `rotate(${angle}rad)`;
              
                document.getElementById('boardCanvas').appendChild(this.persistentArrow);
            },
          
            removePersistentArrow() {
                if (this.persistentArrow) {
                    this.persistentArrow.remove();
                    this.persistentArrow = null;
                }
            },
          
            // Drag handling
            handleDragStart(e, entity) {
                this.draggingEntity = entity;
                this.dragStartPos = {x: entity.x, y: entity.y};
                e.dataTransfer.effectAllowed = 'move';
              
                // Start tracking mouse for drag arrow
                document.addEventListener('mousemove', this.updateDragArrow.bind(this));
            },
          
            updateDragArrow(e) {
                if (!this.draggingEntity || !this.dragStartPos) return;
              
                const rect = document.getElementById('gameBoard').getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
              
                this.createDragArrow(this.dragStartPos.x, this.dragStartPos.y, mouseX, mouseY);
            },
          
            handleDragEnd(e, entity) {
                this.removeDragArrow();
                document.removeEventListener('mousemove', this.updateDragArrow.bind(this));
              
                this.draggingEntity = null;
                this.dragStartPos = null;
            },
          
            // Enhanced Token Interaction System (Fixed inventory drag issue)
            handleTokenInteraction(draggingEntity, target, dropX, dropY) {
                let actionPerformed = false;
              
                // Item dragged onto Player/NPC - Add to inventory (NEW FIX)
                if (draggingEntity.type === 'item' && (target.type === 'player' || target.type === 'npc')) {
                    if (!target.inventory) target.inventory = [];
                    target.inventory.push({...draggingEntity});
                    this.removeEntity(draggingEntity.id);
                    this.addLog(`${target.name} picks up ${draggingEntity.name}!`, 'info');
                    this.showActionDisplay('info', 'Item Collected', `${target.name} picks up ${draggingEntity.name}`);
                    actionPerformed = true;
                }
              
                // Player Token Interactions
                else if (draggingEntity.type === 'player' || draggingEntity.type === 'npc') {
                  
                    // Token placed on Item - Add to inventory
                    if (target.type === 'item') {
                        if (!draggingEntity.inventory) draggingEntity.inventory = [];
                        draggingEntity.inventory.push({...target});
                        this.removeEntity(target.id);
                        this.addLog(`${draggingEntity.name} picks up ${target.name}!`, 'info');
                        this.showActionDisplay('info', 'Item Collected', `${draggingEntity.name} picks up ${target.name}`);
                        actionPerformed = true;
                    }
                  
                    // Token placed on Enemy - Attack
                    else if (target.type === 'monster' ||
                            (target.type === 'player' && draggingEntity.type === 'npc') ||
                            (target.type === 'npc' && draggingEntity.type === 'player')) {
                        if (draggingEntity.attacks && draggingEntity.attacks.length > 0) {
                            this.performAttack(draggingEntity, target, draggingEntity.attacks[0]);
                            actionPerformed = true;
                        } else {
                            // Create basic unarmed attack if no weapons
                            const unarmedAttack = {
                                name: 'Unarmed Strike',
                                toHit: this.getAbilityModifier(draggingEntity.str) + draggingEntity.proficiencyBonus,
                                damage: '1+' + this.getAbilityModifier(draggingEntity.str),
                                damageType: 'bludgeoning',
                                range: 5,
                                soundEffect: ''
                            };
                            this.performAttack(draggingEntity, target, unarmedAttack);
                            actionPerformed = true;
                        }
                    }
                  
                    // Token placed on Chest - Open and spill contents
                    else if (target.type === 'container') {
                        if (target.isMimic || (target.name === 'Mimic')) {
                            // Reveal mimic and attack
                            target.name = 'Mimic';
                            target.type = 'monster';
                            const mimicTemplate = this.library.monsters.find(m => m.name === 'Mimic');
                            if (mimicTemplate) {
                                // Store the original inventory before applying template
                                const originalInventory = target.inventory || [];
                                Object.assign(target, JSON.parse(JSON.stringify(mimicTemplate)));
                                target.id = target.id; // Keep original ID
                                target.x = target.x; // Keep position
                                target.y = target.y;
                                target.inventory = originalInventory; // Restore chest inventory for when mimic dies
                            }
                            this.addLog(`${target.name} reveals itself as a Mimic!`, 'info');
                            this.showActionDisplay('damage', 'Mimic Revealed!', `${target.name} was actually a Mimic!`);
                            const mimicAttack = target.attacks[0] || {name: 'Bite', toHit: 5, damage: '1d8+3', damageType: 'piercing', soundEffect: ''};
                            this.performAttack(target, draggingEntity, mimicAttack);
                            this.playSound('attack');
                        } else {
                            // Spill chest contents around the chest
                            if (target.inventory && target.inventory.length > 0) {
                                target.inventory.forEach((item, index) => {
                                    const angle = (index / target.inventory.length) * Math.PI * 2;
                                    const distance = 80 + (index * 20); // Spread items in a circle
                                    const newX = target.x + Math.cos(angle) * distance;
                                    const newY = target.y + Math.sin(angle) * distance;
                                  
                                    const newItem = this.createEntity('item', item.name, newX, newY);
                                    Object.assign(newItem, item);
                                    newItem.id = this.nextId++;
                                    newItem.x = newX;
                                    newItem.y = newY;
                                    this.entities.push(newItem);
                                });
                                this.addLog(`${draggingEntity.name} opens the chest! ${target.inventory.length} items spill out.`, 'info');
                                this.showActionDisplay('info', 'Chest Opened', `${target.inventory.length} items spill from the chest`);
                                target.inventory = []; // Empty the chest
                              
                                // Update chest color to grey since it's now empty
                                target.color = '#6b7280';
                            } else {
                                this.addLog(`${draggingEntity.name} opens the chest. It's empty.`, 'info');
                                this.showActionDisplay('info', 'Empty Chest', 'The chest contains nothing');
                            }
                            this.playSound('open');
                        }
                        actionPerformed = true;
                    }
                }

                // Monster Token Interactions
                else if (draggingEntity.type === 'monster') {
                    // Monster placed on Player/NPC - Attack
                    if (target.type === 'player' || target.type === 'npc') {
                        if (draggingEntity.attacks && draggingEntity.attacks.length > 0) {
                            this.performAttack(draggingEntity, target, draggingEntity.attacks[0]);
                            actionPerformed = true;
                        } else {
                            // Create basic unarmed attack if no attacks configured
                            const unarmedAttack = {
                                name: 'Unarmed Strike',
                                toHit: this.getAbilityModifier(draggingEntity.str) + draggingEntity.proficiencyBonus,
                                damage: '1+' + this.getAbilityModifier(draggingEntity.str),
                                damageType: 'bludgeoning',
                                range: 5,
                                soundEffect: ''
                            };
                            this.performAttack(draggingEntity, target, unarmedAttack);
                            actionPerformed = true;
                        }
                    }
                }

                // Item Token Interactions
                else if (draggingEntity.type === 'item') {
                  
                    // Item placed on Chest - Add to chest inventory
                    if (target.type === 'container' && !target.isMimic) {
                        if (!target.inventory) target.inventory = [];
                        target.inventory.push({...draggingEntity});
                        this.removeEntity(draggingEntity.id);
                        this.addLog(`${draggingEntity.name} added to chest.`, 'info');
                        this.showActionDisplay('info', 'Item Stored', `${draggingEntity.name} added to chest`);
                      
                        // Update chest color to gold since it now has items
                        target.color = '#fbbf24';
                        actionPerformed = true;
                    }
                }
              
                return actionPerformed;
            },
          
            // Setup event listeners
            setupEventListeners() {
                const canvas = document.getElementById('boardCanvas');
                const gameBoard = document.getElementById('gameBoard');

                // Zoom with mouse wheel
                gameBoard.addEventListener('wheel', (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                        this.zoom = Math.max(0.1, Math.min(5, this.zoom * zoomDelta));
                        this.render();
                    }
                });

                // Pan with middle mouse button or space + drag
                gameBoard.addEventListener('mousedown', (e) => {
                    if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                        e.preventDefault();
                        this.isPanning = true;
                        this.lastPanX = e.clientX;
                        this.lastPanY = e.clientY;
                        gameBoard.style.cursor = 'grabbing';
                    }
                });

                gameBoard.addEventListener('mousemove', (e) => {
                    if (this.isPanning) {
                        const deltaX = (e.clientX - this.lastPanX) / this.zoom;
                        const deltaY = (e.clientY - this.lastPanY) / this.zoom;
                        this.panX += deltaX;
                        this.panY += deltaY;
                        this.lastPanX = e.clientX;
                        this.lastPanY = e.clientY;
                        this.render();
                    }
                });

                gameBoard.addEventListener('mouseup', (e) => {
                    if (e.button === 1 || e.button === 0) {
                        this.isPanning = false;
                        gameBoard.style.cursor = 'default';
                    }
                });
              
                canvas.addEventListener('dragover', e => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
              
                canvas.addEventListener('drop', e => {
                    e.preventDefault();
                    if (!this.draggingEntity) return;
                  
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                  
                  
                    // Check for target entity
                    const target = this.entities.find(ent =>
                        ent.id !== this.draggingEntity.id &&
                        Math.abs(ent.x - x) < 40 &&
                        Math.abs(ent.y - y) < 40
                    );
                  
                    let actionPerformed = false;
                  
                    if (this.targetingMode && this.draggingEntity.id === this.targetingMode.source.id) {
                        if (this.targetingMode.action.visualPattern === 'aoe') {
                            this.executeTargetedAction(null, {x, y});
                            actionPerformed = true;
                        } else if (target) {
                            // Execute targeted action
                            this.executeTargetedAction(target);
                            actionPerformed = true;
                        }
                    } else if (target) {
                        // For attacks, arrow will be created by performAttack with correct positions
                        actionPerformed = this.handleTokenInteraction(this.draggingEntity, target, x, y);
                    } else {
                        // Normal movement
                        if (this.editMode) {
                            // Free movement in edit mode - no restrictions
                            this.draggingEntity.x = x;
                            this.draggingEntity.y = y;
                            this.addLog(`${this.draggingEntity.name} moved freely in edit mode.`, 'info');
                            actionPerformed = true;
                        } else {
                            const distance = Math.hypot(x - this.dragStartPos.x, y - this.dragStartPos.y);
                            const movementCost = Math.floor(distance / 5);
                          
                            if (this.enforceTurns && this.turnOrder[this.currentTurn]?.id !== this.draggingEntity.id) {
                                this.addLog('Not your turn!', 'info');
                                return;
                            }
                          
                            if (this.draggingEntity.movement !== undefined && movementCost <= this.draggingEntity.movement) {
                                // Check for opportunity attacks
                                const opportunityAttackers = this.checkForOpportunityAttacks(this.draggingEntity, this.dragStartPos, {x, y});
                                if (opportunityAttackers.length > 0 && !this.draggingEntity.disengaged) {
                                    opportunityAttackers.forEach(attacker => {
                                        if (!attacker.reactionUsed && attacker.attacks.length > 0) {
                                            this.performAttack(attacker, this.draggingEntity, attacker.attacks[0]);
                                            attacker.reactionUsed = true;
                                            this.addLog(`${attacker.name} takes an opportunity attack!`, 'damage');
                                        }
                                    });
                                }
                                this.draggingEntity.x = x;
                                this.draggingEntity.y = y;
                                this.draggingEntity.movement -= movementCost;
                                this.updateTurnOrder();
                                this.addLog(`${this.draggingEntity.name} moves ${movementCost}ft.`, 'info');
                                this.showActionDisplay('info', 'Movement', `${this.draggingEntity.name} moves ${movementCost} feet`, `${this.draggingEntity.movement} feet remaining`);
                                actionPerformed = true;
                            } else if (this.draggingEntity.movement === undefined) {
                                // Items and containers can always move
                                this.draggingEntity.x = x;
                                this.draggingEntity.y = y;
                                actionPerformed = true;
                            } else {
                                this.addLog(`Not enough movement! (${movementCost}ft needed, ${this.draggingEntity.movement}ft remaining)`, 'info');
                            }
                        }
                    }
                  
                    // Remove persistent arrow after action
                    setTimeout(() => {
                        this.removePersistentArrow();
                    }, actionPerformed ? 1500 : 500);
                  
                    this.render();
                });
              
                // Keyboard shortcuts
                document.addEventListener('keydown', e => {
                    // Don't trigger shortcuts if typing in input/textarea
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }

                    if (e.key === 'Enter') this.nextTurn();
                    if (e.key === 'Delete' && this.selectedEntity) this.removeEntity(this.selectedEntity.id);
                });
            },
          
            // Check for opportunity attacks
            checkForOpportunityAttacks(movingEntity, startPos, endPos) {
                const attackers = [];
                const threatRange = 50; // 5ft = 50px assuming 10px/ft? Wait, grid 50px=5ft? Wait, pattern width=50, path M 50 0 L 0 0 0 50, so lines every 50px, each square 50px = 5ft, so 10px/ft.
                // Wait, to be accurate, 5ft = 50px, no, pattern id="grid" width="50", path M 50 0 L 0 0 0 50, so lines every 50px, each square 50px = 5ft, so 10px/ft.
                // So 5ft = 50px.
                const enemies = this.entities.filter(e => 
                    (e.type === 'monster' && movingEntity.type === 'player') ||
                    (e.type === 'player' && movingEntity.type === 'monster') ||
                    (e.type === 'npc' && movingEntity.type === 'monster') || // Assume NPCs allied with players
                    (e.type === 'monster' && movingEntity.type === 'npc')
                );
              
                enemies.forEach(enemy => {
                    const startDist = Math.hypot(startPos.x - enemy.x, startPos.y - enemy.y);
                    const endDist = Math.hypot(endPos.x - enemy.x, endPos.y - enemy.y);
                    if (startDist <= threatRange && endDist > threatRange) {
                        attackers.push(enemy);
                    }
                });
              
                return attackers;
            },
          
            // Targeting system
            startTargeting(source, action) {
                this.targetingMode = {source, action};
              
                document.querySelectorAll('.action-menu, .details-panel').forEach(el => el.remove());
              
                const indicator = document.createElement('div');
                indicator.className = 'targeting-indicator';
                indicator.id = 'targetingIndicator';
                indicator.innerHTML = `
                    <div class="targeting-text">Select target for ${action.name}</div>
                    <button class="cancel-btn" onclick="game.cancelTargeting()">Cancel</button>
                `;
                document.getElementById('gameBoard').appendChild(indicator);
              
                this.render();
            },
          
            executeTargetedAction(target = null, pos = null) {
                if (!this.targetingMode) return;
              
                if (this.targetingMode.source.id === target?.id) {
                    this.addLog('Cannot target self!', 'info');
                    return;
                }
              
                const {source, action} = this.targetingMode;
              
                if (action.level !== undefined) {
                    // It's a spell
                    this.castSpell(source, target, action, null, pos);
                } else if (action.toHit !== undefined) {
                    // It's an attack
                    this.performAttack(source, target, action);
                } else if (action.healing || action.effect) {
                    // It's an item
                    this.useItem(source, action, target);
                } else if (action.type === 'special') {
                    // It's a base combat action
                    this.performBaseAction(source, target, action);
                }
              
                this.cancelTargeting();
            },
            // Perform Base Combat Actions
            performBaseAction(performer, target, action) {
                this.showActionDisplay('info', `${action.name}`, `${performer.name} uses ${action.name}`, action.description);
              
                switch (action.effect) {
                    case 'shove':
                        const shoveRoll = this.rollDice('1d20') + this.getAbilityModifier(performer.str) + performer.proficiencyBonus;
                        const shoveTarget = Math.max(target.ac, 8 + this.getAbilityModifier(target.str));
                        if (shoveRoll >= shoveTarget) {
                            // Push away
                            const dx = target.x - performer.x;
                            const dy = target.y - performer.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist > 0) {
                                const pushDist = 50; // 5ft = 50px
                                target.x += (dx / dist) * pushDist;
                                target.y += (dy / dist) * pushDist;
                            }
                            this.addLog(`${performer.name} shoves ${target.name} away!`, 'info');
                            this.showActionDisplay('info', 'Shove Success', `${target.name} is pushed 5 feet away`);
                        } else {
                            this.addLog(`${performer.name} fails to shove ${target.name}`, 'info');
                            this.showActionDisplay('info', 'Shove Failed', `${target.name} resists the shove`);
                        }
                        break;
                    case 'grapple':
                        const grappleRoll = this.rollDice('1d20') + this.getAbilityModifier(performer.str) + performer.proficiencyBonus;
                        const grappleTarget = Math.max(target.ac, 8 + Math.max(this.getAbilityModifier(target.str), this.getAbilityModifier(target.dex)));
                        if (grappleRoll >= grappleTarget) {
                            this.addCondition(target, 'grappled');
                            this.addLog(`${performer.name} grapples ${target.name}!`, 'info');
                            this.showActionDisplay('info', 'Grapple Success', `${target.name} is grappled`);
                        } else {
                            this.addLog(`${performer.name} fails to grapple ${target.name}`, 'info');
                            this.showActionDisplay('info', 'Grapple Failed', `${target.name} escapes the grapple attempt`);
                        }
                        break;
                    case 'dash':
                        performer.movement += performer.speed;
                        this.addLog(`${performer.name} dashes! Movement doubled.`, 'info');
                        this.showActionDisplay('info', 'Dash', `${performer.name} gains extra movement`, `Total movement: ${performer.movement} feet`);
                        break;
                    case 'disengage':
                        performer.disengaged = true;
                        this.addLog(`${performer.name} disengages from combat.`, 'info');
                        this.showActionDisplay('info', 'Disengage', `${performer.name} can move without opportunity attacks`);
                        break;
                    case 'dodge':
                        this.addLog(`${performer.name} focuses on dodging attacks.`, 'info');
                        this.showActionDisplay('info', 'Dodge', `${performer.name} is harder to hit until next turn`);
                        break;
                    case 'help':
                        this.addLog(`${performer.name} helps ${target.name}.`, 'info');
                        this.showActionDisplay('info', 'Help', `${target.name} gains advantage on their next roll`);
                        break;
                    case 'ready':
                        this.addLog(`${performer.name} readies an action.`, 'info');
                        this.showActionDisplay('info', 'Ready Action', `${performer.name} prepares to react`);
                        break;
                }
              
                if (action.skill) {
                    const skillRoll = this.rollDice('1d20') + this.getAbilityModifier(performer[this.skillsList[action.skill]]) + (performer.skills[action.skill] || 0);
                    this.addLog(`${performer.name} rolls ${action.skill}: ${skillRoll}`, 'info');
                    this.showActionDisplay('roll', `${action.skill.charAt(0).toUpperCase() + action.skill.slice(1)} Check`, `${performer.name} rolled ${skillRoll}`);
                }
              
                // Mark action used
                performer.actionUsed = true;
                this.updateTurnOrder();
            },
          
            cancelTargeting() {
                this.targetingMode = null;
                document.getElementById('targetingIndicator')?.remove();
                this.render();
            },
          
            // UI Functions
            selectEntity(entity) {
                if (this.targetingMode) {
                    this.executeTargetedAction(entity);
                    return;
                }
              
                // Only trigger token interactions when there's already a selected entity AND they're different
                if (this.selectedEntity && this.selectedEntity.id !== entity.id) {
                    // Only trigger interactions if we're dragging or the entities are compatible for interaction
                    if (this.draggingEntity || this.shouldInteractOnClick(this.selectedEntity, entity)) {
                        const actionPerformed = this.handleTokenInteraction(this.selectedEntity, entity, entity.x, entity.y);
                        if (actionPerformed) {
                            this.selectedEntity = null; // Clear selection after interaction
                            this.render();
                            return;
                        }
                    }
                }
              
                this.selectedEntity = entity;
              
                // Remove any existing panels first
                document.querySelectorAll('.details-panel, .action-menu').forEach(el => el.remove());
              
                this.render();
              
                // Show appropriate panel based on entity type
                if (entity.type === 'item' || entity.type === 'container') {
                    this.showItemDetailsPanel(entity);
                    if (entity.type === 'item') {
                        this.showItemActionMenu(entity);
                    }
                } else if (entity.type === 'visualEffect') {
                    this.showVisualEffectDetailsPanel(entity);
                } else {
                    this.showDetailsPanel(entity);
                  
                    if ((entity.type === 'player' || entity.type === 'monster' || entity.type === 'npc') && entity.hp > 0) {
                        this.showActionMenu(entity);
                    }
                }
            },
            // Visual Effect Details Panel
            showVisualEffectDetailsPanel(entity) {
                document.querySelectorAll('.details-panel').forEach(el => el.remove());
              
                const panel = document.createElement('div');
                panel.className = 'details-panel';
              
                panel.innerHTML = `
                    <button class="close-btn" onclick="this.parentElement.remove()">✕</button>
                    <h3 style="color: #fbbf24; margin-bottom: 15px;">${entity.name}</h3>
                  
                    <div class="stat-row">
                        <span>Name:</span>
                        <input type="text" value="${entity.name}" onchange="game.updateEntity(${entity.id}, 'name', this.value)" class="stat-input" style="width: 120px;">
                    </div>
                  
                    <div class="stat-row">
                        <span>Image/GIF URL:</span>
                        <input type="text" value="${entity.url || ''}" onchange="game.updateEntity(${entity.id}, 'url', this.value)" class="stat-input" style="width: 200px;">
                    </div>
                  
                    <div class="stat-row">
                        <span>Width:</span>
                        <input type="number" value="${entity.width || 100}" onchange="game.updateEntity(${entity.id}, 'width', this.value)" class="stat-input">
                    </div>
                  
                    <div class="stat-row">
                        <span>Height:</span>
                        <input type="number" value="${entity.height || 100}" onchange="game.updateEntity(${entity.id}, 'height', this.value)" class="stat-input">
                    </div>
                  
                    <div class="stat-row">
                        <span>Mode:</span>
                        <select onchange="game.updateEntity(${entity.id}, 'mode', this.value)" class="stat-input">
                            <option value="decoration" ${entity.mode === 'decoration' ? 'selected' : ''}>Decoration</option>
                            <option value="once" ${entity.mode === 'once' ? 'selected' : ''}>Play Once</option>
                            <option value="loop" ${entity.mode === 'loop' ? 'selected' : ''}>Loop</option>
                        </select>
                    </div>
                  
                    <div class="stat-row">
                        <span>Duration (seconds):</span>
                        <input type="number" value="${entity.duration || 3}" onchange="game.updateEntity(${entity.id}, 'duration', this.value)" class="stat-input">
                    </div>
                  
                    <button class="btn btn-danger btn-small" onclick="game.removeEntity(${entity.id})">Remove Effect</button>
                `;
              
                document.getElementById('gameBoard').appendChild(panel);
            },
          
            // Helper function to determine if entities should interact on click
            shouldInteractOnClick(selectedEntity, targetEntity) {
                // Players/NPCs clicking on items should pick them up
                if ((selectedEntity.type === 'player' || selectedEntity.type === 'npc') && targetEntity.type === 'item') {
                    return true;
                }
              
                // Items clicking on players/NPCs should be picked up
                if (selectedEntity.type === 'item' && (targetEntity.type === 'player' || targetEntity.type === 'npc')) {
                    return true;
                }
              
                // Items clicking on containers
                if (selectedEntity.type === 'item' && targetEntity.type === 'container') {
                    return true;
                }
              
                // Players/NPCs clicking on containers
                if ((selectedEntity.type === 'player' || selectedEntity.type === 'npc') && targetEntity.type === 'container') {
                    return true;
                }
              
                return false;
            },
            showItemDetailsPanel(entity) {
                document.querySelectorAll('.details-panel').forEach(el => el.remove());
              
                const panel = document.createElement('div');
                panel.className = 'details-panel';
              
                let html = `
                    <button class="close-btn" onclick="this.parentElement.remove()">✕</button>
                    <h3 style="color: #fbbf24; margin-bottom: 15px;">${entity.name}</h3>
                  
                    <div class="item-property-group">
                        <h4>Basic Properties</h4>
                        <div class="property-row">
                            <span class="property-label">Name:</span>
                            <input type="text" value="${entity.name}" onchange="game.updateEntity(${entity.id}, 'name', this.value)" class="property-input">
                        </div>
                        <div class="property-row">
                            <span class="property-label">Type:</span>
                            <span>${entity.type === 'container' ? 'Container' : 'Item'}</span>
                        </div>
                    </div>
                `;
              
                if (entity.type === 'item') {
                    html += `
                        <div class="item-property-group">
                            <h4>Item Details</h4>
                            <div class="property-row">
                                <span class="property-label">Description:</span>
                                <input type="text" value="${entity.description || ''}" onchange="game.updateEntity(${entity.id}, 'description', this.value)" class="property-input">
                            </div>
                            <div class="property-row">
                                <span class="property-label">Value (gp):</span>
                                <inputtype="number" value="${entity.value || 0}" onchange="game.updateEntity(${entity.id}, 'value', this.value)" class="property-input">
                            </div>
                            <div class="property-row">
                                <span class="property-label">Weight (lbs):</span>
                                <input type="number" step="0.1" value="${entity.weight || 0}" onchange="game.updateEntity(${entity.id}, 'weight', this.value)" class="property-input">
                            </div>
                            <div class="property-row">
                                <span class="property-label">Consumable:</span>
                                <input type="checkbox" ${entity.consumable ? 'checked' : ''} onchange="game.updateEntity(${entity.id}, 'consumable', this.checked)">
                            </div>
                            <div class="property-row">
                                <span class="property-label">Rarity:</span>
                                <select onchange="game.updateEntity(${entity.id}, 'rarity', this.value)" class="property-input">
                                    <option value="common" ${entity.rarity === 'common' ? 'selected' : ''}>Common</option>
                                    <option value="uncommon" ${entity.rarity === 'uncommon' ? 'selected' : ''}>Uncommon</option>
                                    <option value="rare" ${entity.rarity === 'rare' ? 'selected' : ''}>Rare</option>
                                    <option value="very rare" ${entity.rarity === 'very rare' ? 'selected' : ''}>Very Rare</option>
                                    <option value="legendary" ${entity.rarity === 'legendary' ? 'selected' : ''}>Legendary</option>
                                    <option value="artifact" ${entity.rarity === 'artifact' ? 'selected' : ''}>Artifact</option>
                                </select>
                            </div>
                        </div>
                      
                        <div class="item-property-group">
                            <h4>Combat Properties</h4>
                            <div class="property-row">
                                <span class="property-label">Healing:</span>
                                <input type="text" value="${entity.healing || ''}" onchange="game.updateEntity(${entity.id}, 'healing', this.value)" class="property-input" placeholder="e.g., 2d4+2">
                            </div>
                            <div class="property-row">
                                <span class="property-label">Damage:</span>
                                <input type="text" value="${entity.damage || ''}" onchange="game.updateEntity(${entity.id}, 'damage', this.value)" class="property-input" placeholder="e.g., 1d8+2">
                            </div>
                            <div class="property-row">
                                <span class="property-label">Damage Type:</span>
                                <input type="text" value="${entity.damageType || ''}" onchange="game.updateEntity(${entity.id}, 'damageType', this.value)" class="property-input" placeholder="e.g., slashing">
                            </div>
                            <div class="property-row">
                                <span class="property-label">AC Bonus:</span>
                                <input type="number" value="${entity.ac || 0}" onchange="game.updateEntity(${entity.id}, 'ac', this.value)" class="property-input">
                            </div>
                        </div>
                      
                        <div class="item-property-group">
                            <h4>Audio & Visual Effects</h4>
                            <div class="property-row">
                                <span class="property-label">Sound Effect URL:</span>
                            </div>
                            <input type="text" value="${entity.soundEffect || ''}" onchange="game.updateEntity(${entity.id}, 'soundEffect', this.value)" class="sound-field" placeholder="MP3/WAV URL for when item is used">
                          
                            <div class="property-row">
                                <span class="property-label">Visual Effect URL:</span>
                            </div>
                            <input type="text" value="${entity.visualEffect || ''}" onchange="game.updateEntity(${entity.id}, 'visualEffect', this.value)" class="effect-field" placeholder="PNG/GIF URL for visual effect">
                        </div>
                    `;
                } else if (entity.type === 'container') {
                    html += `
                        <div class="item-property-group">
                            <h4>Container Properties</h4>
                            <div class="property-row">
                                <span class="property-label">Is Mimic:</span>
                                <input type="checkbox" ${entity.isMimic ? 'checked' : ''} onchange="game.updateEntity(${entity.id}, 'isMimic', this.checked)">
                            </div>
                        </div>
                      
                        <div class="item-property-group">
                            <h4>Container Contents</h4>
                            <div style="margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
                                ${entity.inventory && entity.inventory.length > 0 ?
                                    entity.inventory.map(item => `
                                        <div style="padding: 4px; background: rgba(0,0,0,0.2); margin: 2px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;">
                                            <span>${item.name}</span>
                                            <button onclick="game.removeItemFromContainer(${entity.id}, '${item.name}')" style="background: #ef4444; border: none; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer;">Remove</button>
                                        </div>
                                    `).join('') :
                                    '<p style="color: #9ca3af; text-align: center; padding: 10px;">Empty</p>'
                                }
                            </div>
                        </div>
                      
                        <div class="item-property-group">
                            <h4>Audio & Visual Effects</h4>
                            <div class="property-row">
                                <span class="property-label">Sound Effect URL:</span>
                            </div>
                            <input type="text" value="${entity.soundEffect || ''}" onchange="game.updateEntity(${entity.id}, 'soundEffect', this.value)" class="sound-field" placeholder="MP3/WAV URL for when container is opened">
                        </div>
                    `;
                }
              
                html += `
                    <div class="item-property-group">
                        <h4>Appearance</h4>
                        <div class="property-row">
                            <span class="property-label">Image URL:</span>
                        </div>
                        <input type="text" value="${entity.image || ''}" onchange="game.updateEntity(${entity.id}, 'image', this.value)" class="property-input" style="width: 100%;" placeholder="Token image URL">
                    </div>
                  
                    <div style="margin-top: 15px; display: flex; gap: 10px;">
                        <button class="btn btn-danger btn-small" onclick="game.removeEntity(${entity.id})">Remove</button>
                        <button class="btn btn-success btn-small" onclick="game.saveToLibrary(${entity.id})">Save to Library</button>
                    </div>
                `;
              
                panel.innerHTML = html;
                document.getElementById('gameBoard').appendChild(panel);
            },
          
            showItemActionMenu(entity) {
                document.querySelectorAll('.action-menu').forEach(el => el.remove());
              
                const elem = document.querySelector(`[data-id="${entity.id}"]`);
                if (!elem) return;
              
                const menu = document.createElement('div');
                menu.className = 'action-menu';
              
                let html = `<h4 style="color: #fbbf24;">📦 ${entity.name} Actions</h4>`;
              
                if (entity.type === 'item') {
                    html += '<div class="action-section"><div class="action-section-title">Item Actions</div>';
                  
                    if (entity.healing) {
                        html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), {name: 'Use ${entity.name}', healing: '${entity.healing}', consumable: ${entity.consumable}, soundEffect: '${entity.soundEffect || ''}', visualEffect: '${entity.visualEffect || ''}'})">
                            💊 Use for Healing (${entity.healing})
                        </button>`;
                    }
                  
                    if (entity.damage) {
                        html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), {name: 'Attack with ${entity.name}', damage: '${entity.damage}', damageType: '${entity.damageType || 'bludgeoning'}', soundEffect: '${entity.soundEffect || ''}', visualEffect: '${entity.visualEffect || ''}'})">
                            ⚔️ Attack with Item (${entity.damage} ${entity.damageType || 'bludgeoning'})
                        </button>`;
                    }
                  
                    html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), {name: 'Give ${entity.name}', effect: 'transfer'})">
                        🤝 Give to Character
                    </button>`;
                  
                    html += '</div>';
                  
                    if (entity.spell) {
                        html += '<div class="action-section"><div class="action-section-title">Spell Scroll</div>';
                        html += `<button class="action-btn" onclick="game.castSpellFromItem(${entity.id})">
                            ✨ Cast ${entity.spell}
                        </button>`;
                        html += '</div>';
                    }
                } else if (entity.type === 'container') {
                    html += '<div class="action-section"><div class="action-section-title">Container Actions</div>';
                    html += `<button class="action-btn" onclick="game.openContainer(${entity.id})">
                        📂 Open Container
                    </button>`;
                  
                    if (entity.inventory && entity.inventory.length > 0) {
                        html += `<button class="action-btn" onclick="game.spillContainerContents(${entity.id})">
                            📤 Spill Contents
                        </button>`;
                    }
                    html += '</div>';
                }
              
                menu.innerHTML = html;
              
                // Add close button
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-btn';
                closeBtn.innerHTML = '✕';
                closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    menu.remove();
                };
                menu.appendChild(closeBtn);
                menu.addEventListener('click', function(e) { e.stopPropagation(); });
              
                elem.appendChild(menu);
            },
          
            // Item action functions
            removeItemFromContainer(containerId, itemName) {
                const container = this.getEntity(containerId);
                if (container && container.inventory) {
                    container.inventory = container.inventory.filter(item => item.name !== itemName);
                    this.addLog(`${itemName} removed from ${container.name}`, 'info');
                    this.render();
                    // Refresh the details panel
                    this.showItemDetailsPanel(container);
                }
            },
          
            openContainer(containerId) {
                const container = this.getEntity(containerId);
                if (container) {
                    // Play container sound effect
                    if (container.soundEffect) {
                        this.playIndividualSound(container.soundEffect);
                    } else {
                        this.playSound('open');
                    }
                    this.spillContainerContents(containerId);
                }
            },
          
            spillContainerContents(containerId) {
                const container = this.getEntity(containerId);
                if (container && container.inventory && container.inventory.length > 0) {
                    container.inventory.forEach((item, index) => {
                        const angle = (index / container.inventory.length) * Math.PI * 2;
                        const distance = 80 + (index * 20); // Spread items in a circle
                        const newX = container.x + Math.cos(angle) * distance;
                        const newY = container.y + Math.sin(angle) * distance;
                      
                        const newItem = this.createEntity('item', item.name, newX, newY);
                        Object.assign(newItem, item);
                        newItem.id = this.nextId++;
                        newItem.x = newX;
                        newItem.y = newY;
                        this.entities.push(newItem);
                    });
                  
                    this.addLog(`${container.name} contents spilled! ${container.inventory.length} items.`, 'info');
                    this.showActionDisplay('info', 'Container Opened', `${container.inventory.length} items spilled from ${container.name}`);
                    container.inventory = [];
                    container.color = '#6b7280'; // Grey for empty
                    this.render();
                }
            },
          
            castSpellFromItem(itemId) {
                const item = this.getEntity(itemId);
                if (item && item.spell) {
                    const spell = this.library.spells.find(s => s.name === item.spell);
                    if (spell) {
                        this.addLog(`${item.name} scroll activates ${spell.name}!`, 'info');
                        this.showActionDisplay('spell', 'Spell Scroll', `${item.name} activates ${spell.name}`);
                        if (item.consumable) {
                            this.removeEntity(itemId);
                        }
                    }
                }
            },
          
            showDetailsPanel(entity) {
                // Don't show character details panel for items or containers
                if (entity.type === 'item' || entity.type === 'container') {
                    return;
                }
              
                document.querySelectorAll('.details-panel').forEach(el => el.remove());
              
                const panel = document.createElement('div');
                panel.className = 'details-panel';
              
                let html = `
                    <button class="close-btn" onclick="this.parentElement.remove()">✕</button>
                    <h3 style="color: #fbbf24; margin-bottom: 15px;">${entity.name}</h3>
                    <div class="stat-row">
                        <span>Name:</span>
                        <input type="text" value="${entity.name}" onchange="game.updateEntity(${entity.id}, 'name', this.value)" class="stat-input" style="width: 120px;">
                    </div>
                `;
              
                if (entity.type === 'player' || entity.type=== 'npc') {
                    html += `
                        <div class="stat-row">
                            <span>Class:</span>
                            <input type="text" value="${entity.class}" onchange="game.updateEntity(${entity.id}, 'class', this.value)" class="stat-input" style="width: 80px;">
                            <span>Race:</span>
                            <input type="text" value="${entity.race}" onchange="game.updateEntity(${entity.id}, 'race', this.value)" class="stat-input" style="width: 80px;">
                        </div>
                        <div class="stat-row">
                            <span>Level:</span>
                            <input type="number" value="${entity.level}" onchange="game.updateEntity(${entity.id}, 'level', this.value)" class="stat-input">
                        </div>
                    `;
                }
              
                const strMod = this.getAbilityModifier(entity.str);
                const dexMod = this.getAbilityModifier(entity.dex);
                const conMod = this.getAbilityModifier(entity.con);
                const intMod = this.getAbilityModifier(entity.int);
                const wisMod = this.getAbilityModifier(entity.wis);
                const chaMod = this.getAbilityModifier(entity.cha);
              
                html += `
                    <div class="stat-row">
                        <span>HP:</span>
                        <div>
                            <input type="number" value="${entity.hp}" onchange="game.updateEntity(${entity.id}, 'hp', this.value)" class="stat-input">
                            / <input type="number" value="${entity.maxHp}" onchange="game.updateEntity(${entity.id}, 'maxHp', this.value)" class="stat-input">
                            ${entity.tempHp > 0 ? `(+${entity.tempHp} temp)` : ''}
                        </div>
                    </div>
                    <div class="stat-row">
                        <span>AC:</span>
                        <span>${this.calculateAC(entity)}</span>
                    </div>
                    <div class="stat-row">
                        <span>Speed:</span>
                        <input type="number" value="${entity.speed}" onchange="game.updateEntity(${entity.id}, 'speed', this.value)" class="stat-input">ft
                    </div>
                  
                    <h4 style="margin-top: 15px;">Ability Scores</h4>
                    <div class="stat-group">
                        <div class="stat-box">
                            <div class="stat-label">STR</div>
                            <input type="number" value="${entity.str}" onchange="game.updateEntity(${entity.id}, 'str', this.value)" class="stat-input">
                            <div class="stat-mod">${strMod >= 0 ? '+' : ''}${strMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">DEX</div>
                            <input type="number" value="${entity.dex}" onchange="game.updateEntity(${entity.id}, 'dex', this.value)" class="stat-input">
                            <div class="stat-mod">${dexMod >= 0 ? '+' : ''}${dexMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">CON</div>
                            <input type="number" value="${entity.con}" onchange="game.updateEntity(${entity.id}, 'con', this.value)" class="stat-input">
                            <div class="stat-mod">${conMod >= 0 ? '+' : ''}${conMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">INT</div>
                            <input type="number" value="${entity.int}" onchange="game.updateEntity(${entity.id}, 'int', this.value)" class="stat-input">
                            <div class="stat-mod">${intMod >= 0 ? '+' : ''}${intMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">WIS</div>
                            <input type="number" value="${entity.wis}" onchange="game.updateEntity(${entity.id}, 'wis', this.value)" class="stat-input">
                            <div class="stat-mod">${wisMod >= 0 ? '+' : ''}${wisMod}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">CHA</div>
                            <input type="number" value="${entity.cha}" onchange="game.updateEntity(${entity.id}, 'cha', this.value)" class="stat-input">
                            <div class="stat-mod">${chaMod >= 0 ? '+' : ''}${chaMod}</div>
                        </div>
                    </div>
                  
                    <h4 style="margin-top: 15px;">Conditions</h4>
                    <div style="margin-bottom: 10px;">
                        ${entity.conditions && entity.conditions.length > 0 ?
                            entity.conditions.map(cond => `
                                <span style="display: inline-block; background: rgba(139, 92, 246, 0.2); padding: 2px 8px; border-radius: 4px; margin: 2px;">
                                    ${cond}${entity.conditionTurns && entity.conditionTurns[cond] ? ` (${entity.conditionTurns[cond]})` : ''}
                                    <button onclick="game.removeCondition(game.getEntity(${entity.id}), '${cond}')" style="background: none; border: none; color: #ef4444; cursor: pointer;">✕</button>
                                </span>
                            `).join('') :
                            'None'
                        }
                    </div>
                  
                    ${entity.type === 'player' || entity.type === 'npc' ? `
                        <h4>Spell Slots</h4>
                        <div class="stat-group">
                            ${[1,2,3].map(level => `
                                <div class="stat-box">
                                    <div class="stat-label">Lvl ${level}</div>
                                    <div>${entity.spellSlotsUsed[level] || 0}/${entity.spellSlots[level] || 0}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                  
                    <div class="stat-row">
                        <span>Image URL:</span>
                        <input type="text" value="${entity.image}" onchange="game.updateEntity(${entity.id}, 'image', this.value)" class="stat-input" style="width: 200px;">
                    </div>
                  
                    <div class="stat-row">
                        <span>Sound Effect:</span>
                        <input type="text" value="${entity.soundEffect || ''}" onchange="game.updateEntity(${entity.id}, 'soundEffect', this.value)" class="stat-input" style="width: 200px;">
                    </div>
                  
                    <div class="stat-row">
                        <span>Visual Effect:</span>
                        <input type="text" value="${entity.visualEffect || ''}" onchange="game.updateEntity(${entity.id}, 'visualEffect', this.value)" class="stat-input" style="width: 200px;">
                    </div>
                  
                    <button class="btn btn-primary btn-small" onclick="game.openSpellManager(${entity.id})">Manage Spells</button>
                    <button class="btn btn-primary btn-small" onclick="game.openInventoryManager(${entity.id})">Manage Inventory</button>
                  
                    <button class="btn btn-danger btn-small" onclick="game.removeEntity(${entity.id})">Remove</button>
                    <button class="btn btn-success btn-small" onclick="game.saveToLibrary(${entity.id})">Save to Library</button>
                `;
              
                panel.innerHTML = html;
                document.getElementById('gameBoard').appendChild(panel);
            },
          
            showActionMenu(entity) {
                document.querySelectorAll('.action-menu').forEach(el => el.remove());
              
                const elem = document.querySelector(`[data-id="${entity.id}"]`);
                if (!elem) return;
              
                const menu = document.createElement('div');
                menu.className = 'action-menu';
              
                let html = `<h4 style="color: #fbbf24;">⭐ Actions for ${entity.name}</h4>
                           <p style="font-size: 11px; color: #9ca3af; margin: 5px 0;">Click an action, then click target</p>`;
              
                // Base Combat Actions
                if (entity.baseActions && entity.baseActions.length > 0) {
                    html += '<div class="action-section"><div class="action-section-title">Basic Actions</div>';
                    entity.baseActions.forEach((action, index) => {
                        const disabled = entity.actionUsed && action.actionType === 'action' ? 'disabled' : '';

                        // Actions that need targeting
                        if (action.name === 'Unarmed Strike' || action.name === 'Shove' ||
                            action.name === 'Grapple' || action.name === 'Help') {
                            html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).baseActions[${index}])">
                ${this.getActionIcon(action.type)} ${action.name}
            </button>`;
                        }
                        // Actions that execute immediately without targeting
                        else {
                            html += `<button class="action-btn ${disabled}" onclick="game.performBaseAction(game.getEntity(${entity.id}), game.getEntity(${entity.id}), game.getEntity(${entity.id}).baseActions[${index}])">
                ${this.getActionIcon(action.type)} ${action.name}
            </button>`;
                        }
                    });
                    html += '</div>';
                }
              
                // Attacks
                if (entity.attacks && entity.attacks.length > 0) {
                    html += '<div class="action-section"><div class="action-section-title">Attacks</div>';
                    entity.attacks.forEach((attack, index) => {
                        const disabled = entity.actionUsed && !attack.bonusAction ? 'disabled' : '';
                        const range = attack.range || 5;
                        html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).attacks[${index}])">
                            ⚔️ ${attack.name} (+${attack.toHit}, ${attack.damage}) [${range}ft]
                        </button>`;
                    });
                    html += '</div>';
                }
              
                // Spells
                if (entity.spells && entity.spells.length > 0) {
                    html += '<div class="action-section"><div class="action-section-title">Spells</div>';
                    entity.spells.forEach((spell, index) => {
                        const canCast = spell.level === 0 ||
                                       (entity.spellSlots && entity.spellSlots[spell.level] > entity.spellSlotsUsed[spell.level]);
                        const disabled = !canCast ||
                                       (spell.castingTime === 'action' && entity.actionUsed) ||
                                       (spell.castingTime === 'bonus action' && entity.bonusActionUsed) ? 'disabled' : '';
                      
                        const slotInfo = spell.level > 0 ?
                            `<span class="spell-slot-info">${entity.spellSlotsUsed[spell.level]}/${entity.spellSlots[spell.level]}</span>` : '';
                      
                        html += `<button class="action-btn ${disabled}" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).spells[${index}])">
                            ✨ ${spell.name} (Lvl ${spell.level}) ${slotInfo}
                        </button>`;
                    });
                    html += '</div>';
                }
              
                // Items
                if (entity.inventory && entity.inventory.length > 0) {
                    const usableItems = entity.inventory.filter(item => item.healing || item.effect || item.spell);
                    if (usableItems.length > 0) {
                        html += '<div class="action-section"><div class="action-section-title">Items</div>';
                        usableItems.forEach((item, index) => {
                            const actualIndex = entity.inventory.indexOf(item);
                            html += `<button class="action-btn" onclick="game.startTargeting(game.getEntity(${entity.id}), game.getEntity(${entity.id}).inventory[${actualIndex}])">
                                🧪 ${item.name}
                            </button>`;
                        });
                        html += '</div>';
                    }
                }
              
                // Abilities (non-targeting ones)
                if (entity.abilities && entity.abilities.length > 0) {
                    const activeAbilities = entity.abilities.filter(a => a.actionType !== 'passive');
                    if (activeAbilities.length > 0) {
                        html += '<div class="action-section"><div class="action-section-title">Special Abilities</div>';
                        activeAbilities.forEach(ability => {
                            const disabled = (ability.actionType === 'action' && entity.actionUsed) ||
                                           (ability.actionType === 'bonus' && entity.bonusActionUsed) ||
                                           (ability.actionType === 'reaction' && entity.reactionUsed) ? 'disabled' : '';
                           html += `<button class="action-btn ${disabled}" title="${ability.description}">
                                💫 ${ability.name}
                            </button>`;
                        });
                        html += '</div>';
                    }
                }
              
                menu.innerHTML = html;
              
                // Add close button after menu is created
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-btn';
                closeBtn.innerHTML = '✕';
                closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    menu.remove();
                };
                menu.appendChild(closeBtn);
                menu.addEventListener('click', function(e) { e.stopPropagation(); });
              
                elem.appendChild(menu);
            },
            // Get Action Icon
            getActionIcon(actionType) {
                const icons = {
                    attack: '⚔️',
                    special: '⭐',
                    skill: '🎯',
                    movement: '👣',
                    defense: '🛡️',
                    support: '🤝'
                };
                return icons[actionType] || '⚡';
            },
          
            // Managers
            openSpellManager(entityId) {
                const entity = this.getEntity(entityId);
                if (!entity) return;
              
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                let html = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">✕</button>
                        <h2>✨ Manage Spells for ${entity.name}</h2>
                      
                        <h3>Current Spells</h3>
                        <div class="item-list">
                            ${entity.spells.map((s, i) => `
                                <div class="item-card">
                                    <strong>${s.name}</strong> (Level ${s.level})<br>
                                    <small>${s.description}</small><br>
                                    <div>
                                        Sound: <select onchange="game.updateSpellSFX(${entityId}, ${i}, this.value)">
                                            <option value="">None</option>
                                            ${game.library.sfx.map(sfx => `<option value="${sfx.url}" ${s.soundEffect === sfx.url ? 'selected' : ''}>${sfx.name}</option>`).join('')}
                                        </select>
                                    </div>
                                    <div>
                                        VFX: <select onchange="game.updateSpellVFX(${entityId}, ${i}, this.value)">
                                            <option value="">None</option>
                                            ${game.library.vfx.map(vfx => `<option value="${vfx.url}" ${s.visualEffect === vfx.url ? 'selected' : ''}>${vfx.name}</option>`).join('')}
                                        </select>
                                    </div>
                                    <div>
                                        Pattern: <select onchange="game.updateSpellPattern(${entityId}, ${i}, this.value)">
                                            <option value="onEntity" ${s.visualPattern === 'onEntity' ? 'selected' : ''}>On Entity</option>
                                            <option value="shoot" ${s.visualPattern === 'shoot' ? 'selected' : ''}>Shoot</option>
                                            <option value="aoe" ${s.visualPattern === 'aoe' ? 'selected' : ''}>Area of Effect</option>
                                        </select>
                                    </div>
                                    <button class="btn btn-small btn-danger" onclick="game.removeSpell(${entityId}, ${i}); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openSpellManager(${entityId});">Remove</button>
                                </div>
                            `).join('')}
                        </div>
                      
                        <h3>Available Spells</h3>
                        <div class="item-list">
                            ${this.library.spells.filter(s => !entity.spells.some(es => es.name === s.name)).map(s => `
                                <div class="item-card" onclick="game.addSpell(${entityId}, '${s.name}'); this.parentElement.parentElement.parentElement.remove(); game.openSpellManager(${entityId});">
                                    <strong>${s.name}</strong> (Level ${s.level})<br>
                                    <small>${s.description}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                modal.innerHTML = html;
                document.body.appendChild(modal);
            },
          
            openInventoryManager(entityId) {
                const entity = this.getEntity(entityId);
                if (!entity) return;
              
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                let html = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">✕</button>
                        <h2>🎒 Manage Inventory for ${entity.name}</h2>
                      
                        <h3>Equipment</h3>
                        <div class="item-list">
                            ${Object.entries(entity.equipment).map(([slot, item]) => `
                                <div class="item-card">
                                    <strong>${slot}:</strong> ${item ? item.name : 'Empty'}
                                    ${item ? `<button class="btn btn-small btn-danger" onclick="game.unequipItem(game.getEntity(${entityId}), game.getEntity(${entityId}).equipment['${slot}']); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Unequip</button>` : ''}
                                </div>
                            `).join('')}
                        </div>
                      
                        <h3>Inventory</h3>
                        <div class="item-list">
                            ${entity.inventory.map((item, i) => `
                                <div class="item-card">
                                    <strong>${item.name}</strong><br>
                                    <small>${item.description || ''}</small><br>
                                    ${item.type === 'weapon' ? `
                                        <div>
                                            Sound: <select onchange="game.updateInventorySFX(${entityId}, ${i}, this.value)">
                                                <option value="">None</option>
                                                ${game.library.sfx.map(sfx => `<option value="${sfx.url}" ${item.soundEffect === sfx.url ? 'selected' : ''}>${sfx.name}</option>`).join('')}
                                            </select>
                                        </div>
                                        <div>
                                            VFX: <select onchange="game.updateInventoryVFX(${entityId}, ${i}, this.value)">
                                                <option value="">None</option>
                                                ${game.library.vfx.map(vfx => `<option value="${vfx.url}" ${item.visualEffect === vfx.url ? 'selected' : ''}>${vfx.name}</option>`).join('')}
                                            </select>
                                        </div>
                                    ` : ''}
                                    <button class="btn btn-small btn-danger" onclick="game.removeInventoryItem(${entityId}, ${i}); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Remove</button>
                                    ${item.equipSlot ? `<button class="btn btn-small btn-primary" onclick="game.equipItem(game.getEntity(${entityId}), game.getEntity(${entityId}).inventory[${i}]); this.parentElement.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">Equip</button>` : ''}
                                </div>
                            `).join('')}
                        </div>
                      
                        <h3>Add Items</h3>
                        <div class="item-list">
                            ${[...this.library.items, ...this.library.equipment].map(item => `
                                <div class="item-card" onclick="game.addInventoryItem(${entityId}, '${item.name}'); this.parentElement.parentElement.parentElement.remove(); game.openInventoryManager(${entityId});">
                                    <strong>${item.name}</strong><br>
                                    <small>${item.description || ''}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                modal.innerHTML = html;
                document.body.appendChild(modal);
            },
          
            // Helper functions for managers
            addSpell(entityId, spellName) {
                const entity = this.getEntity(entityId);
                const spell = this.library.spells.find(s => s.name === spellName);
                if (entity && spell) {
                    entity.spells.push(JSON.parse(JSON.stringify(spell)));
                    this.addLog(`${entity.name} learns ${spell.name}`, 'info');
                }
            },
          
            removeSpell(entityId, index) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index]) {
                    const spellName = entity.spells[index].name;
                    entity.spells.splice(index, 1);
                    this.addLog(`${entity.name} forgets ${spellName}`, 'info');
                }
            },
          
            addInventoryItem(entityId, itemName) {
                const entity = this.getEntity(entityId);
                const item = [...this.library.items, ...this.library.equipment].find(i => i.name === itemName);
                if (entity && item) {
                    entity.inventory.push(JSON.parse(JSON.stringify(item)));
                    this.addLog(`${entity.name} receives ${item.name}`, 'info');
                }
            },
          
            removeInventoryItem(entityId, index) {
                const entity = this.getEntity(entityId);
                if (entity && entity.inventory[index]) {
                    const itemName = entity.inventory[index].name;
                    entity.inventory.splice(index, 1);
                    this.addLog(`${entity.name} discards ${itemName}`, 'info');
                }
            },
          
            updateSpellSFX(entityId, index, value) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index]) {
                    entity.spells[index].soundEffect = value;
                }
            },
            updateSpellVFX(entityId, index, value) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index]) {
                    entity.spells[index].visualEffect = value;
                }
            },
            updateSpellPattern(entityId, index, value) {
                const entity = this.getEntity(entityId);
                if (entity && entity.spells[index]) {
                    entity.spells[index].visualPattern = value;
                }
            },
            updateInventorySFX(entityId, index, value) {
                const entity = this.getEntity(entityId);
                if (entity && entity.inventory[index]) {
                    entity.inventory[index].soundEffect = value;
                }
            },
            updateInventoryVFX(entityId, index, value) {
                const entity = this.getEntity(entityId);
                if (entity && entity.inventory[index]) {
                    entity.inventory[index].visualEffect = value;
                }
            },
          
            // Enhanced Add entities with better modals
            addPlayerCharacter() {
                const name = prompt('Enter character name:');
                if (!name) return;
              
                // Create modal for class and race selection
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="creation-modal">
                        <h2>🛡️ Create Player Character</h2>
                        <div class="form-group">
                            <label class="form-label">Class:</label>
                            <select id="classSelect" class="form-select">
                                ${this.classList.map(cls => `<option value="${cls}">${cls}</option>`).join('')}
                            </select>
                            <input type="text" id="customClass" placeholder="Enter custom class name" class="custom-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Race:</label>
                            <select id="raceSelect" class="form-select">
                                ${this.raceList.map(race => `<option value="${race}">${race}</option>`).join('')}
                            </select>
                            <input type="text" id="customRace" placeholder="Enter custom race name" class="custom-input">
                        </div>
                      
                        <button class="advanced-toggle" onclick="this.nextElementSibling.classList.toggle('show')">⚙️ Advanced Options</button>
                        <div class="advanced-options">
                            <div class="advanced-grid">
                                <div>
                                    <label class="form-label">Hit Points:</label>
                                    <input type="number" id="playerHP" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Armor Class:</label>
                                    <input type="number" id="playerAC" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Speed:</label>
                                    <input type="number" id="playerSpeed" value="30" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Strength:</label>
                                    <input type="number" id="playerStr" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Dexterity:</label>
                                    <input type="number" id="playerDex" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Constitution:</label>
                                    <input type="number" id="playerCon" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Intelligence:</label>
                                    <input type="number" id="playerInt" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Wisdom:</label>
                                    <input type="number" id="playerWis" value="10" class="advanced-input">
                                </div>
                                <div>
                                    <label class="form-label">Charisma:</label>
                                    <input type="number" id="playerCha" value="10" class="advanced-input">
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Character Image URL:</label>
                                <input type="text" id="playerImage" placeholder="Image URL" class="advanced-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Spell Slots (Level 1):</label>
                                <input type="number" id="playerSpellSlots1" value="2" class="advanced-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Spell Slots (Level 2):</label>
                                <input type="number" id="playerSpellSlots2" value="0" class="advanced-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Spell Slots (Level 3):</label>
                                <input type="number" id="playerSpellSlots3" value="0" class="advanced-input">
                            </div>
                        </div>
                      
                        <div class="modal-buttons">
                            <button class="btn btn-danger" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createPlayerFromModal('${name}')">Create Character</button>
                        </div>
                    </div>
                `;
              
                // Add event listeners for custom option toggles
                modal.querySelector('#classSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#customClass');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
              
                modal.querySelector('#raceSelect').addEventListener('change', (e) => {
                    const customInput = modal.querySelector('#customRace');
                    if (e.target.value === 'Custom') {
                        customInput.classList.add('show');
                    } else {
                        customInput.classList.remove('show');
                    }
                });
              
                document.body.appendChild(modal);
            },
          
            createPlayerFromModal(name) {
                const modal = document.querySelector('.modal-overlay');
                const classSelect = modal.querySelector('#classSelect');
                const customClass = modal.querySelector('#customClass');
                const raceSelect = modal.querySelector('#raceSelect');
                const customRace = modal.querySelector('#customRace');
              
                const selectedClass = classSelect.value === 'Custom' ? customClass.value || 'Fighter' : classSelect.value;
                const selectedRace = raceSelect.value === 'Custom' ? customRace.value || 'Human' : raceSelect.value;
              
                const entity = this.createEntity('player', name, 200 + Math.random() * 100, 200 + Math.random() * 200);
                entity.class = selectedClass;
                entity.race = selectedRace;
              
                // Apply advanced options if filled
                const hp = parseInt(modal.querySelector('#playerHP').value) || 10;
                const ac = parseInt(modal.querySelector('#playerAC').value) || 10;
                const speed = parseInt(modal.querySelector('#playerSpeed').value) || 30;
                const str = parseInt(modal.querySelector('#playerStr').value) || 10;
                const dex = parseInt(modal.querySelector('#playerDex').value) || 10;
                const con = parseInt(modal.querySelector('#playerCon').value) || 10;
                const int = parseInt(modal.querySelector('#playerInt').value) || 10;
                const wis = parseInt(modal.querySelector('#playerWis').value) || 10;
                const cha = parseInt(modal.querySelector('#playerCha').value) || 10;
                const image = modal.querySelector('#playerImage').value || '';
                const spellSlots1 = parseInt(modal.querySelector('#playerSpellSlots1').value) || 2;
                const spellSlots2 = parseInt(modal.querySelector('#playerSpellSlots2').value) || 0;
                const spellSlots3 = parseInt(modal.querySelector('#playerSpellSlots3').value) || 0;
              
                entity.hp = hp;
                entity.maxHp = hp;
                entity.ac = ac;
                entity.speed = speed;
                entity.str = str;
                entity.dex = dex;
                entity.con = con;
                entity.int = int;
                entity.wis = wis;
                entity.cha = cha;
                entity.image = image;
                entity.spellSlots[1] = spellSlots1;
                entity.spellSlots[2] = spellSlots2;
                entity.spellSlots[3] = spellSlots3;
              
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
              
                modal.remove();
            },
          
            addMonster() {
                const name = prompt('Enter monster name:', 'Goblin');
                if (!name) return;
              
                const entity = this.createEntity('monster', name, 400 + Math.random() * 200, 200 + Math.random() * 200);
                this.entities.push(entity);
                this.updateTurnOrder();
                this.render();
            },
          
            addItem() {
                const name = prompt('Enter item name:', 'Healing Potion');
                if (!name) return;
              
                const entity = this.createEntity('item', name, 350 + Math.random() * 100, 350 + Math.random() * 100);
                this.entities.push(entity);
                this.render();
            },
          
            // Enhanced Add Chest function with item selection
            addChest() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal">
                        <button class="close-btn" onclick="this.parentElement.parentElement.remove()">✕</button>
                        <h2>🗃️ Create Chest</h2>
                      
                        <div style="margin-bottom: 20px;">
                            <label style="display: flex; align-items: center; gap: 10px; color: #e0e0e0; font-weight: 600;">
                                <input type="checkbox" id="mimicToggle" style="transform: scale(1.2);">
                                This chest is a Mimic
                            </label>
                        </div>
                      
                        <h3>Select Items for Chest</h3>
                        <div style="margin-bottom: 15px;">
                            <input type="text" id="chestItemSearch" placeholder="Search items..." class="search-bar" onkeyup="game.filterChestItems(this.value)">
                        </div>
                      
                        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #374151; border-radius: 8px; padding: 10px; background: rgba(0,0,0,0.3);">
                            <div id="chestItemsList">
                                ${[...this.library.items, ...this.library.equipment].map((item, index) => `
                                    <div class="chest-item-option" data-name="${item.name.toLowerCase()}">
                                        <label style="display: flex; align-items: center; gap: 10px; padding: 8px; cursor: pointer; color: #e0e0e0;" onclick="game.toggleChestItem('${item.name}', this)">
                                            <input type="checkbox" class="chest-item-checkbox" style="transform: scale(1.1);">
                                            <span>${item.name}</span>
                                            <span style="font-size: 11px; color: #9ca3af; margin-left: auto;">${item.description ? item.description.substring(0, 50) + '...' : ''}</span>
                                        </label>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                      
                       <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn btn-danger" onclick="this.parentElement.parentElement.parentElement.remove()">Cancel</button>
                            <button class="btn btn-success" onclick="game.createChestFromModal()">Create Chest</button>
                        </div>
                    </div>
                `;
              
                document.body.appendChild(modal);
            },
          
            filterChestItems(searchTerm) {
                const items = document.querySelectorAll('.chest-item-option');
                const term = searchTerm.toLowerCase();
              
                items.forEach(item => {
                    if (item.dataset.name.includes(term)) {
                        item.style.display = 'block';
                    } else {
                        item.style.display = 'none';
                    }
                });
            },
          
            toggleChestItem(itemName, labelElement) {
                const checkbox = labelElement.querySelector('input[type="checkbox"]');
                checkbox.checked = !checkbox.checked;
            },
          
            createChestFromModal() {
                const modal = document.querySelector('.modal-overlay');
                const isMimic = modal.querySelector('#mimicToggle').checked;
                const checkedItems = modal.querySelectorAll('.chest-item-checkbox:checked');
              
                const selectedItems = [];
                checkedItems.forEach(checkbox => {
                    const itemName = checkbox.parentElement.querySelector('span').textContent;
                    const item = [...this.library.items, ...this.library.equipment].find(i => i.name === itemName);
                    if (item) {
                        selectedItems.push(JSON.parse(JSON.stringify(item)));
                    }
                });
              
                const entity = this.createEntity('container', 'Chest', 350 + Math.random() * 100, 350 + Math.random() * 100);
                entity.isMimic = isMimic;
                entity.inventory = selectedItems;
              
                // Set appropriate color based on content and type
                if (isMimic) {
                    entity.color = '#8B4513'; // Brown for mimics
                } else if (selectedItems.length === 0) {
                    entity.color = '#6b7280'; // Grey for empty chests
                } else {
                    entity.color = '#fbbf24'; // Gold for filled chests
                }
              
                this.entities.push(entity);
                this.render();
              
                modal.remove();
            },
          
            // Library functions
            saveToLibrary(id) {
                const entity = this.getEntity(id);
                if (!entity) return;
              
                const copy = JSON.parse(JSON.stringify(entity));
                delete copy.id;
                delete copy.x;
                delete copy.y;
                delete copy.movement;
                delete copy.actionUsed;
                delete copy.bonusActionUsed;
                delete copy.reactionUsed;
                copy.image = entity.image || '';
              
                if (entity.type === 'player' || entity.type === 'npc') {
                    if (!this.library.players.some(p => p.name === copy.name)) {
                        this.library.players.push(copy);
                    }
                } else if (entity.type === 'monster') {
                    if (!this.library.monsters.some(m => m.name === copy.name)) {
                        this.library.monsters.push(copy);
                    }
                }
              
                this.saveLibrary();
                this.addLog(`${entity.name} saved to library`, 'info');
                this.populateLibrarySidebar();
            },
          
            saveCurrentEntity() {
                if (!this.selectedEntity) {
                    alert('Select an entity first!');
                    return;
                }
                this.saveToLibrary(this.selectedEntity.id);
            },
          
            addFromLibrary(name, category) {
                const x = 300 + Math.random() * 200;
                const y = 200 + Math.random() * 200;
              
                let entity;
                if (category === 'monster' || category === 'player') {
                    entity = this.createEntity(category, name, x, y);
                } else if (category === 'item' || category === 'equipment') {
                    entity = this.createEntity('item', name, x, y);
                }
              
                if (entity) {
                    // Set image from library
                    const libItem = [...this.library.monsters, ...this.library.items, ...this.library.equipment, ...this.library.players, ...this.library.spells].find(i => i.name === name);
                    if (libItem && libItem.image) {
                        entity.image = libItem.image;
                    }
                    this.entities.push(entity);
                    this.updateTurnOrder();
                    this.render();
                    switchTab({target: document.querySelector('.tab.active')}, 'combat');
                }
            },
          
            // Background functions
            saveBackground() {
                const url = document.getElementById('newBgUrl').value;
                if (url && !this.savedBackgrounds.includes(url)) {
                    this.savedBackgrounds.push(url);
                    localStorage.setItem('dndBackgrounds', JSON.stringify(this.savedBackgrounds));
                    this.updateBackgroundList();
                    document.getElementById('newBgUrl').value = '';
                }
            },
          
            removeBackground(url) {
                const index = this.savedBackgrounds.indexOf(url);
                if (index > -1) {
                    this.savedBackgrounds.splice(index, 1);
                    localStorage.setItem('dndBackgrounds', JSON.stringify(this.savedBackgrounds));
                    this.updateBackgroundList();
                }
            },
          
            loadBackground(url) {
                document.getElementById('bgUrl').value = url;
                this.changeBackground();
            },
          
            updateBackgroundList() {
                const list = document.getElementById('backgroundList');
                if (!list) return;
                list.innerHTML = '';
                this.savedBackgrounds.forEach(url => {
                    const card = document.createElement('div');
                    card.className = 'background-card';
                    card.style.backgroundImage = `url(${url})`;
                    card.onclick = () => this.loadBackground(url);
                    card.innerHTML = `
                        <div class="background-overlay">
                            <span>Use this</span>
                            <button class="background-delete-btn" onclick="event.stopPropagation(); game.removeBackground('${url}')">Delete</button>
                        </div>
                    `;
                    list.appendChild(card);
                });
            },
          
            loadSavedBackgrounds() {
                const saved = localStorage.getItem('dndBackgrounds');
                if (saved) {
                    this.savedBackgrounds = JSON.parse(saved);
                    this.updateBackgroundList();
                }
            },
          
            // Settings
            toggleGrid() {
                this.showGrid = !this.showGrid;
                const btn = document.getElementById('gridToggle');
                const grid = document.getElementById('gridOverlay');
              
                btn.classList.toggle('active', this.showGrid);
                grid.style.display = this.showGrid ? 'block' : 'none';
            },
          
            toggleTurnEnforcement() {
                this.enforceTurns = !this.enforceTurns;
                const btn = document.getElementById('turnToggle');
                btn.classList.toggle('active', this.enforceTurns);
                this.addLog(`Turn enforcement ${this.enforceTurns ? 'enabled' : 'disabled'}`, 'info');
            },
          
            toggleMovementRange() {
                this.showMovementRange = !this.showMovementRange;
                const btn = document.getElementById('movementToggle');
                btn.classList.toggle('active', this.showMovementRange);
                this.render();
            },
          
            changeBackground() {
                const url = document.getElementById('bgUrl').value;
                this.backgroundUrl = url;
                const container = document.getElementById('boardContainer');
                if (url && container) {
                    container.style.backgroundImage = `url(${url})`;
                }
            },
          
            // Combat log
            addLog(message, type = 'info') {
                const log = document.getElementById('combatLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = message;
              
                log.insertBefore(entry, log.firstChild);
                if (log.children.length > 15) {
                    log.removeChild(log.lastChild);
                }
            },
          
            // Animations
            createFloatingText(text, x, y, color) {
                const elem = document.createElement('div');
                elem.className = 'floating-text';
                elem.style.left = `${x}px`;
                elem.style.top = `${y}px`;
                elem.style.color = color;
                elem.textContent = text;
              
                document.getElementById('boardCanvas').appendChild(elem);
                setTimeout(() => elem.remove(), 1500);
            },
          
            createArrowAnimation(x1, y1, x2, y2) {
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const distance = Math.hypot(x2 - x1, y2 - y1);
              
                const arrow = document.createElement('div');
                arrow.className = 'arrow-animation';
                arrow.style.left = `${x1}px`;
                arrow.style.top = `${y1}px`;
                arrow.style.transform = `rotate(${angle}rad)`;
                arrow.innerHTML = `<div class="arrow-line" style="width: ${distance}px"></div>`;
              
                document.getElementById('boardCanvas').appendChild(arrow);
                setTimeout(() => arrow.remove(), 500);
            },
          
            createSpellAnimation(x1, y1, x2, y2, school) {
                const colors = {
                    evocation: '#ff4444',
                    abjuration: '#4444ff',
                    conjuration: '#44ff44',
                    divination: '#ffffff',
                    enchantment: '#ff44ff',
                    illusion: '#ff44ff',
                    necromancy: '#444444',
                    transmutation: '#ffff44'
                };
              
                const effect = document.createElement('div');
                effect.className = 'spell-effect';
                effect.style.left = `${x2 - 50}px`;
                effect.style.top = `${y2 - 50}px`;
                effect.innerHTML = `<div class="magic-circle" style="border-color: ${colors[school] || '#8b5cf6'}"></div>`;
              
                document.getElementById('boardCanvas').appendChild(effect);
                setTimeout(() => effect.remove(), 1000);
            },
          
            // Save/Load
            saveGameState() {
                const state = {
                    entities: this.entities.map(e => ({...e, image: e.image || ''})),
                    currentTurn: this.currentTurn,
                    turnOrder: this.turnOrder,
                    roundNumber: this.roundNumber,
                    nextId: this.nextId,
                    editMode: this.editMode,
                    backgroundUrl: this.backgroundUrl,
                    quickSlots: this.quickSlots
                };
              
                localStorage.setItem('dndGameState', JSON.stringify(state));
                this.addLog('Game saved!', 'info');
            },
          
            loadGameState() {
                const saved = localStorage.getItem('dndGameState');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        this.entities = state.entities || [];
                        this.currentTurn = state.currentTurn || 0;
                        this.turnOrder = state.turnOrder || [];
                        this.roundNumber = state.roundNumber || 1;
                        this.nextId = state.nextId || 1;
                        this.editMode = state.editMode || false;
                        this.backgroundUrl = state.backgroundUrl || '';
                        this.quickSlots = state.quickSlots || [];
                        const bgInput = document.getElementById('bgUrl');
                        if (bgInput) bgInput.value = this.backgroundUrl;
                        this.changeBackground();
                        this.entities.forEach(e => {
                            if (state.entities.find(se => se.id === e.id)) {
                                e.image = state.entities.find(se => se.id === e.id).image || '';
                            }
                        });
                        this.render();
                        this.updateTurnOrder();
                        const editBtn = document.getElementById('editToggle');
                        if (editBtn) editBtn.classList.toggle('active', this.editMode);
                        this.addLog('Game loaded!', 'info');
                    } catch (e) {
                        console.error('Failed to load game state:', e);
                    }
                }
            },

            // Reset zoom and pan
            resetView() {
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.render();
                this.addLog('View reset', 'info');
            },

            clearBoard() {
                if (confirm('Clear all entities from the board?')) {
                    this.entities = [];
                    this.selectedEntity = null;
                    this.currentTurn = 0;
                    this.turnOrder = [];
                    this.roundNumber = 1;
                    this.render();
                    this.updateTurnOrder();
                    this.addLog('Board cleared', 'info');
                }
            },
          
            // Import/Export
            exportLibrary() {
                const data = JSON.stringify(this.library, null, 2);
                const exportField = document.getElementById('exportData');
                if (exportField) exportField.value = data;
            },
          
            importLibrary() {
                try {
                    const importField = document.getElementById('importData');
                    if (!importField) return;
                  
                    const data = JSON.parse(importField.value);
                  
                    // Merge libraries with backward compatibility
                    ['monsters', 'spells', 'items', 'equipment', 'players', 'sfx'].forEach(key => {
                        if (data[key] && Array.isArray(data[key])) {
                            data[key].forEach(newItem => {
                                // Add missing fields
                                if (key === 'monsters' || key === 'players') {
                                    newItem.baseActions = newItem.baseActions || [...this.baseCombatActions];
                                    newItem.soundEffect = newItem.soundEffect || '';
                                    newItem.visualEffect = newItem.visualEffect || '';
                                } else if (key === 'spells') {
                                    newItem.soundEffect = newItem.soundEffect || '';
                                    newItem.visualEffect = newItem.visualEffect || '';
                                } else if (key === 'items' || key === 'equipment') {
                                    newItem.soundEffect = newItem.soundEffect || '';
                                    newItem.visualEffect = newItem.visualEffect || '';
                                }
                                if (!this.library[key].some(item => item.name === newItem.name)) {
                                    this.library[key].push(newItem);
                                }
                            });
                        }
                    });
                  
                    this.saveLibrary();
                    this.populateLibrarySidebar();
                    alert('Library imported successfully!');
                } catch (e) {
                    alert('Invalid JSON data!');
                }
            },
          
            saveLibrary() {
                localStorage.setItem('dndLibrary', JSON.stringify(this.library));
            },
          
            loadLibrary() {
                const saved = localStorage.getItem('dndLibrary');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        // Merge with existing library
                        Object.keys(data).forEach(key => {
                            if (Array.isArray(data[key])) {
                                data[key].forEach(item => {
                                    if (!this.library[key].some(existing => existing.name === item.name)) {
                                        this.library[key].push(item);
                                    }
                                });
                            }
                        });
                    } catch (e) {
                        console.error('Failed to load library:', e);
                    }
                }
            },
          
            // Setup quick add buttons
            setupQuickAdd() {
                const grid = document.getElementById('quickAddGrid');
                if (!grid) return;
              
                grid.innerHTML = '';
              
                this.quickSlots.forEach((slot, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'quick-add-btn customizable';
                    btn.innerHTML = `
                        ${slot.name}
                        <button class="remove-quick" onclick="event.stopPropagation(); game.removeQuickSlot(${index})">×</button>
                    `;
                    btn.onclick = () => {
                        const entity = this.createEntity(slot.type, slot.name, 300 + Math.random() * 200, 200 + Math.random() * 200);
                        const libItem = [...this.library.monsters, ...this.library.players, ...this.library.items, ...this.library.equipment].find(i => i.name === slot.name);
                        if (libItem && libItem.image) {
                            entity.image = libItem.image;
                        }
                        this.entities.push(entity);
                        this.updateTurnOrder();
                        this.render();
                    };
                    grid.appendChild(btn);
                });
              
                // Add empty slots up to 8
                for (let i = this.quickSlots.length; i < 8; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'quick-add-btn';
                    btn.textContent = 'Empty';
                    btn.onclick = () => this.customizeQuickSlots();
                    grid.appendChild(btn);
                }
            },
            removeQuickSlot(index) {
                this.quickSlots.splice(index, 1);
                this.saveQuickSlots();
                this.setupQuickAdd();
            },
          
            // Enhanced character sheet functions
            updateCharacterList() {
                const list = document.getElementById('characterList');
                if (!list) return;
              
                list.innerHTML = '';
              
                this.entities.filter(e => e.type === 'player' || e.type === 'npc').forEach(character => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                  
                    const typeIcon = character.type === 'npc' ? '🤖' : '👤';
                    const hpPercent = (character.hp / character.maxHp) * 100;
                  
                    card.innerHTML = `
                        <div class="character-card-header">
                            <div class="character-card-avatar">
                                ${character.image ? `<img src="${character.image}" alt="${character.name}">` : typeIcon}
                            </div>
                            <div class="character-card-info">
                                <h4>${character.name}</h4>
                                <p>Level ${character.level} ${character.race} ${character.class}</p>
                            </div>
                        </div>
                        <div class="character-card-stats">
                            <div class="character-card-stat">
                                <div class="character-card-stat-value">${character.hp}/${character.maxHp}</div>
                                <div class="character-card-stat-label">Hit Points</div>
                            </div>
                            <div class="character-card-stat">
                                <div class="character-card-stat-value">${this.calculateAC(character)}</div>
                                <div class="character-card-stat-label">Armor Class</div>
                            </div>
                            <div class="character-card-stat">
                                <div class="character-card-stat-value">${this.getAbilityModifier(character.dex) >= 0 ? '+' : ''}${this.getAbilityModifier(character.dex)}</div>
                                <div class="character-card-stat-label">Initiative</div>
                            </div>
                        </div>
                    `;
                    card.onclick = () => this.showCharacterSheet(character);
                    list.appendChild(card);
                });
            },
          
            showCharacterSheet(character) {
                const content = document.getElementById('sheetContent');
                if (!content) return;
              
                content.style.display = 'block';
              
                const typeIcon = character.type === 'npc' ? '🤖' : '👤';
                const hpPercent = (character.hp / character.maxHp) * 100;
                const hpClass = hpPercent > 75 ? 'healthy' : hpPercent > 25 ? 'wounded' : '';
              
                let html = `
                    <div class="sheet-header">
                        <div class="sheet-avatar">
                            ${character.image ? `<img src="${character.image}" alt="${character.name}">` : typeIcon}
                        </div>
                        <div class="sheet-basic-info">
                            <h2>${character.name}</h2>
                            <p>Level ${character.level} ${character.race} ${character.class}</p>
                        </div>
                    </div>
                  
                    <div class="sheet-tabs">
                        <button class="sheet-tab active" onclick="game.switchSheetTab(event, 'stats')">Stats</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'combat')">Combat</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'spells')">Spells</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'equipment')">Equipment</button>
                        <button class="sheet-tab" onclick="game.switchSheetTab(event, 'notes')">Notes</button>
                    </div>
                  
                    <div id="sheet-stats" class="sheet-tab-content active">
                        ${this.renderStatsTab(character)}
                    </div>
                  
                    <div id="sheet-combat" class="sheet-tab-content">
                        ${this.renderCombatTab(character)}
                    </div>
                  
                    <div id="sheet-spells" class="sheet-tab-content">
                        ${this.renderSpellsTab(character)}
                    </div>
                  
                    <div id="sheet-equipment" class="sheet-tab-content">
                        ${this.renderEquipmentTab(character)}
                    </div>
                  
                    <div id="sheet-notes" class="sheet-tab-content">
                        ${this.renderNotesTab(character)}
                    </div>
                `;
              
                content.innerHTML = html;
            },
          
            switchSheetTab(event, tabName) {
                // Remove active class from all tabs and content
                document.querySelectorAll('.sheet-tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.sheet-tab-content').forEach(content => content.classList.remove('active'));
              
                // Add active class to clicked tab and corresponding content
                event.target.classList.add('active');
                document.getElementById(`sheet-${tabName}`).classList.add('active');
            },
          
            renderStatsTab(character) {
                const hpPercent = (character.hp / character.maxHp) * 100;
                const hpClass = hpPercent > 75 ? 'healthy' : hpPercent > 25 ? 'wounded' : '';
              
                return `
                    <div class="core-stats">
                        <div class="stat-card stat-card-large">
                            <h3>Hit Points</h3>
                            <div class="hp-display">
                                <div class="hp-bar-fill ${hpClass}" style="width: ${hpPercent}%"></div>
                                <div class="hp-text">
                                    <input type="number" value="${character.hp}" onchange="game.updateCharacterStat(${character.id}, 'hp', this.value)" class="editable-field" style="width: 40px; background: transparent; border: none; color: white; text-align: center;">
                                    /
                                    <input type="number" value="${character.maxHp}" onchange="game.updateCharacterStat(${character.id}, 'maxHp', this.value)" class="editable-field" style="width: 40px; background: transparent; border: none; color: white; text-align: center;">
                                </div>
                            </div>
                            <div class="stat-card-subtitle">Current / Maximum</div>
                        </div>
                      
                        <div class="stat-card stat-card-large">
                            <h3>Armor Class</h3>
                            <div class="stat-card-value">${this.calculateAC(character)}</div>
                            <div class="stat-card-subtitle">Total AC</div>
                        </div>
                      
                        <div class="stat-card stat-card-large">
                            <h3>Initiative</h3>
                            <div class="stat-card-value">${this.getAbilityModifier(character.dex) >= 0 ? '+' : ''}${this.getAbilityModifier(character.dex)}</div>
                            <div class="stat-card-subtitle">Dex Modifier</div>
                        </div>
                        <div class="stat-card stat-card-large">
                            <h3>Inspiration</h3>
                            <div class="stat-card-value">
                                <input type="number" value="${character.inspiration || 0}" onchange="game.updateCharacterStat(${character.id}, 'inspiration', this.value)" class="editable-field">
                            </div>
                        </div>
                    </div>
                  
                    <h3 style="color: #fbbf24; margin-bottom: 20px;">Ability Scores</h3>
                    <div class="ability-scores">
                        ${['str', 'dex', 'con', 'int', 'wis', 'cha'].map(ability => {
                            const score = character[ability];
                            const modifier = this.getAbilityModifier(score);
                            return `
                                <div class="ability-score">
                                    <div class="ability-score-name">${ability.toUpperCase()}</div>
                                    <div class="ability-score-value">
                                        <input type="number" value="${score}" onchange="game.updateCharacterStat(${character.id}, '${ability}', this.value)" class="editable-field" style="width: 60px;">
                                    </div>
                                    <div class="ability-score-modifier">${modifier >= 0 ? '+' : ''}${modifier}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                  
                    <div class="skills-section">
                        <div class="skill-category">
                            <h4>Saving Throws</h4>
                            <div class="skill-list">
                                ${['str', 'dex', 'con', 'int', 'wis', 'cha'].map(ability => {
                                    const modifier = this.getAbilityModifier(character[ability]);
                                    const saveBonus = modifier + (character.savingThrows[ability] || 0);
                                    const isProficient = character.savingThrows[ability] > 0;
                                    return `
                                        <div class="skill-item ${isProficient ? 'proficient' : ''}">
                                            <div class="skill-name">
                                                <div class="proficiency-indicator ${isProficient ? 'filled' : ''}"></div>
                                                ${ability.charAt(0).toUpperCase() + ability.slice(1)}
                                            </div>
                                            <div class="skill-bonus">${saveBonus >= 0 ? '+' : ''}${saveBonus}</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                      
                        <div class="skill-category">
                            <h4>Skills</h4>
                            <div class="skill-list">
                                ${Object.entries(this.skillsList).map(([skill, ability]) => {
                                    const abilityMod = this.getAbilityModifier(character[ability]);
                                    const skillBonus = character.skills[skill] || abilityMod;
                                    const isProficient = character.skills[skill] && character.skills[skill] > abilityMod;
                                    const skillName = skill.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                                    return `
                                        <div class="skill-item ${isProficient ? 'proficient' : ''}">
                                            <div class="skill-name">
                                                <div class="proficiency-indicator ${isProficient ? 'filled' : ''}"></div>
                                                ${skillName}
                                            </div>
                                            <div class="skill-bonus">${skillBonus >= 0 ? '+' : ''}${skillBonus}</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
            },
          
            renderCombatTab(character) {
                return `
                    <div class="combat-stats">
                        <div class="stat-card">
                            <h3>Speed</h3>
                            <div class="stat-card-value">
                                <input type="number" value="${character.speed}" onchange="game.updateCharacterStat(${character.id}, 'speed', this.value)" class="editable-field" style="width: 60px;">
                            </div>
                            <div class="stat-card-subtitle">feet</div>
                        </div>
                      
                        <div class="stat-card">
                            <h3>Prof Bonus</h3>
                            <div class="stat-card-value">+${character.proficiencyBonus}</div>
                            <div class="stat-card-subtitle">Proficiency</div>
                        </div>
                      
                        <div class="stat-card">
                            <h3>Hit Dice</h3>
                            <div class="stat-card-value">${character.hitDiceRemaining}${character.hitDice}</div>
                            <div class="stat-card-subtitle">Remaining</div>
                        </div>
                      
                        <div class="stat-card">
                            <h3>Level</h3>
                            <div class="stat-card-value">
                                <input type="number" value="${character.level}" onchange="game.updateCharacterStat(${character.id}, 'level', this.value)" class="editable-field" style="width: 60px;">
                            </div>
                            <div class="stat-card-subtitle">Character Level</div>
                        </div>
                    </div>
                  
                    <div class="attacks-section">
                        <h4>⚔️ Attacks & Weapons</h4>
                        ${character.attacks.length > 0 ? `
                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 15px; padding: 10px; border-bottom: 2px solid #374151; margin-bottom: 15px; font-weight: 600; color: #9ca3af; font-size: 12px; text-transform: uppercase;">
                                <div>Weapon</div>
                                <div style="text-align: center;">Attack Bonus</div>
                                <div style="text-align: center;">Damage</div>
                                <div style="text-align: center;">Range</div>
                            </div>
                            ${character.attacks.map(attack => `
                                <div class="attack-item">
                                    <div class="attack-name">${attack.name}</div>
                                    <div class="attack-stat">
                                        <div class="attack-stat-value">+${attack.toHit || 0}</div>
                                    </div>
                                    <div class="attack-stat">
                                        <div class="attack-stat-value">${attack.damage}</div>
                                        <div style="font-size: 10px; color: #6b7280;">${attack.damageType}</div>
                                    </div>
                                    <div class="attack-stat">
                                        <div class="attack-stat-value">${attack.range || 5}ft</div>
                                    </div>
                                </div>
                            `).join('')}
                        ` : '<p style="color: #9ca3af; text-align: center; padding: 20px;">No attacks configured</p>'}
                    </div>
                  
                    ${character.conditions.length > 0 ? `
                        <div class="attacks-section">
                            <h4>🔮 Active Conditions</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                                ${character.conditions.map(condition => `
                                    <span style="background: rgba(139, 92, 246, 0.2); color: #8b5cf6; padding: 5px 12px; border-radius: 20px; font-size: 12px; font-weight: 600;">
                                        ${condition}${character.conditionTurns && character.conditionTurns[condition] ? ` (${character.conditionTurns[condition]})` : ''}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                `;
            },
          
            renderSpellsTab(character) {
                const hasSpells = character.spells && character.spells.length > 0;
                const hasSpellSlots = Object.values(character.spellSlots || {}).some(slots => slots > 0);
              
                if (!hasSpells && !hasSpellSlots) {
                    return '<p style="color: #9ca3af; text-align: center; padding: 40px;">This character does not have spellcasting abilities.</p>';
                }
              
                return `
                    ${hasSpellSlots ? `
                        <h4 style="color: #8b5cf6; margin-bottom: 20px;">Spell Slots</h4>
                        <div class="spell-slots">
                            ${[1,2,3,4,5,6,7,8,9].map(level => {
                                const total = character.spellSlots[level] || 0;
                                const used = character.spellSlotsUsed[level] || 0;
                                if (total === 0) return '';
                                return `
                                    <div class="spell-slot-level">
                                        <h5>Level ${level}</h5>
                                        <div class="spell-slot-tracker">
                                            <input type="number" value="${used}" style="width:40px" onchange="game.updateSpellSlots(${character.id}, ${level}, this.value, 'used')">
                                            /
                                            <input type="number" value="${total}" style="width:40px" onchange="game.updateSpellSlots(${character.id}, ${level}, this.value, 'total')">
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : ''}
                  
                    ${hasSpells ? `
                        <h4 style="color: #8b5cf6; margin-bottom: 20px;">Known Spells</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                            ${character.spells.map(spell => `
                                <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; border-radius: 8px; padding: 15px;">
                                    <h5 style="color: #8b5cf6; margin: 0 0 8px 0;">${spell.name}</h5>
                                    <p style="color: #9ca3af; font-size: 12px; margin: 0 0 8px 0;">Level ${spell.level} ${spell.school}</p>
                                    <p style="color: #e0e0e0; font-size: 13px; margin: 0;">${spell.description}</p>
                                    ${spell.damage ? `<p style="color: #ef4444; font-size: 12px; margin: 5px 0 0 0;">Damage: ${spell.damage} ${spell.damageType}</p>` : ''}
                                    ${spell.healing ? `<p style="color: #10b981; font-size: 12px; margin: 5px 0 0 0;">Healing: ${spell.healing}</p>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            },
          
            renderEquipmentTab(character) {
                const equipmentSlots = [
                    {key: 'armor', name: 'Armor'},
                    {key: 'mainHand', name: 'Main Hand'},
                    {key: 'offHand', name: 'Off Hand'},
                    {key: 'helmet', name: 'Helmet'},
                    {key: 'boots', name: 'Boots'},
                    {key: 'gloves', name: 'Gloves'},
                    {key: 'amulet', name: 'Amulet'},
                    {key: 'cloak', name: 'Cloak'},
                    {key: 'ring1', name: 'Ring 1'},
                    {key: 'ring2', name: 'Ring 2'}
                ];
              
                return `
                    <h4 style="color: #10b981; margin-bottom: 20px;">Equipment Slots</h4>
                    <div class="equipment-slots">
                        ${equipmentSlots.map(slot => {
                            const item = character.equipment[slot.key];
                            return `
                                <div class="equipment-slot ${item ? 'filled' : ''}">
                                    <div class="equipment-slot-name">${slot.name}</div>
                                    <div class="equipment-item">
                                        ${item ? item.name : 'Empty'}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                  
                    ${character.inventory && character.inventory.length > 0 ? `
                        <h4 style="color: #f59e0b; margin: 30px 0 20px 0;">Inventory</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                            ${character.inventory.map(item => `
                                <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid #f59e0b; border-radius: 8px; padding: 15px;">
                                    <h5 style="color: #f59e0b; margin: 0 0 5px 0;">${item.name}</h5>
                                    ${item.description ? `<p style="color: #9ca3af; font-size: 12px; margin: 0;">${item.description}</p>` : ''}
                                    ${item.damage ? `<p style="color: #ef4444; font-size: 11px; margin: 5px 0 0 0;">Damage: ${item.damage}</p>` : ''}
                                    ${item.ac ? `<p style="color: #3b82f6; font-size: 11px; margin: 5px 0 0 0;">AC: ${item.ac}</p>` : ''}
                                    ${item.healing ? `<p style="color: #10b981; font-size: 11px; margin: 5px 0 0 0;">Healing: ${item.healing}</p>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    ` : '<p style="color: #9ca3af; text-align: center; padding: 20px;">No items in inventory</p>'}
                `;
            },
          
            renderNotesTab(character) {
                return `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                        <div>
                            <h4 style="color: #fbbf24; margin-bottom: 15px;">Character Details</h4>
                            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #374151; border-radius: 8px; padding: 20px;">
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Character Name</label>
                                    <input type="text" value="${character.name}" onchange="game.updateCharacterStat(${character.id}, 'name', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Race</label>
                                    <input type="text" value="${character.race}" onchange="game.updateCharacterStat(${character.id}, 'race', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Class</label>
                                    <input type="text" value="${character.class}" onchange="game.updateCharacterStat(${character.id}, 'class', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                                <div>
                                    <label style="display: block; color: #9ca3af; font-size: 12px; margin-bottom: 5px;">Character Image URL</label>
                                    <input type="text" value="${character.image || ''}" onchange="game.updateCharacterStat(${character.id}, 'image', this.value)" class="editable-field" style="width: 100%; padding: 8px;">
                                </div>
                            </div>
                        </div>
                      
                        <div>
                            <h4 style="color: #fbbf24; margin-bottom: 15px;">Notes & Roleplay</h4>
                            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #374151; border-radius: 8px; padding: 20px;">
                                <textarea placeholder="Character backstory, personality traits, ideals, bonds, flaws..." style="width: 100%; height: 200px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white; padding: 12px; resize: vertical;" onchange="game.updateCharacterStat(${character.id}, 'notes', this.value)">${character.notes || ''}</textarea>
                            </div>
                        </div>
                    </div>
                `;
            },
          
            updateCharacterStat(characterId, property, value) {
                const character = this.getEntity(characterId);
                if (!character) return;
              
                const numericProps = ['hp', 'maxHp', 'ac', 'speed', 'str', 'dex', 'con', 'int', 'wis', 'cha', 'tempHp', 'level', 'inspiration'];
              
                if (numericProps.includes(property)) {
                    character[property] = parseInt(value) || 0;
                } else {
                    character[property] = value;
                }
              
                // Recalculate AC if ability scores change
                if (['str', 'dex'].includes(property)) {
                    character.ac = this.calculateAC(character);
                }
              
                // Update the board representation
                this.render();
              
                // Update the character list if it's visible
                if (document.getElementById('characters-tab').classList.contains('active')) {
                    this.updateCharacterList();
                }
            },
            updateSpellSlots(id, level, value, type) {
                const char = this.getEntity(id);
                if (type === 'used') char.spellSlotsUsed[level] = parseInt(value);
                else char.spellSlots[level] = parseInt(value);
            },
            updateMediaLists() {
                this.updateSfxList()
                this.updateVfxList()
                this.updateBgmList()
            },
            updateSfxList() {
                const list = document.getElementById('sfxList')
                if (list) {
                    list.innerHTML = this.library.sfx.map(s => `
                        <div class="item-card">
                            ${s.name}
                            <button onclick="game.previewSFX('${s.url}')">Play</button>
                            <button class="btn-danger" onclick="game.removeMedia('${s.name}', 'sfx')">Delete</button>
                        </div>
                    `).join('')
                }
            },
            updateVfxList() {
                const list = document.getElementById('vfxList')
                if (list) {
                    list.innerHTML = this.library.vfx.map(v => `
                        <div class="item-card">
                            ${v.name}
                            <img src="${v.url}" style="width:50px">
                            <button onclick="game.previewVFX('${v.url}')">Preview</button>
                            <button onclick="game.placeVFXOnBoard('${v.url}', '${v.name}')">Place as Decoration</button>
                            <button class="btn-danger" onclick="game.removeMedia('${v.name}', 'vfx')">Delete</button>
                        </div>
                    `).join('')
                }
            },
            updateBgmList() {
                const list = document.getElementById('bgmList')
                if (list) {
                    list.innerHTML = this.library.bgm.map(b => `
                        <div class="item-card">
                            ${b.name}
                            <button onclick="game.setBackgroundMusicAndPlay(\`${b.url}\`)">Set Current</button>
                            <button onclick="game.previewSFX('${b.url}')">Preview</button>
                            <button class="btn-danger" onclick="game.removeMedia('${b.name}', 'bgm')">Delete</button>
                        </div>
                    `).join('')
                }
            },
            saveMedia(url, type, name=null) {
                if (!name) name = prompt('Enter name for this media:')
                if (name && url) {
                    this.library[type].push({name, url})
                    this.saveLibrary()
                    this.updateMediaLists()
                }
            },
            saveMediaFromFile(file, type) {
                if (file) {
                    const reader = new FileReader()
                    reader.onload = (e) => {
                        const name = prompt('Enter name for this media:', file.name)
                        if (name) {
                            this.library[type].push({name, url: e.target.result})
                            this.saveLibrary()
                            this.updateMediaLists()
                        }
                    }
                    reader.readAsDataURL(file)
                }
            },
            removeMedia(name, type) {
                if (confirm(`Delete ${name}?`)) {
                    const index = this.library[type].findIndex(m => m.name === name)
                    if (index > -1) {
                        this.library[type].splice(index, 1)
                        this.saveLibrary()
                        this.updateMediaLists()
                    }
                }
            },
            previewVFX(url) {
                this.playVisualEffect(url, window.innerWidth/2, window.innerHeight/2, 200, 200, 5)
            },
            shortRest() {
                this.entities.filter(e => e.type === 'player' || e.type === 'npc').forEach(e => {
                    if (e.hitDiceRemaining > 0) {
                        const roll = this.rollDice(e.hitDice);
                        e.hp = Math.min(e.maxHp, e.hp + roll + this.getAbilityModifier(e.con));
                        e.hitDiceRemaining--;
                        this.addLog(`${e.name} recovers ${roll} HP from short rest.`, 'heal');
                    }
                });
            },
            longRest() {
                this.entities.filter(e => e.type === 'player' || e.type === 'npc').forEach(e => {
                    e.hp = e.maxHp;
                    Object.keys(e.spellSlotsUsed).forEach(level => e.spellSlotsUsed[level] = 0);
                    e.hitDiceRemaining = Math.floor(e.level / 2) || 1;
                    e.conditions = e.conditions.filter(c => !['exhaustion'].includes(c));
                    this.addLog(`${e.name} fully recovers from long rest.`, 'heal');
                });
            },
            // Customization functions
            setUIHue(hue) {
                document.documentElement.style.setProperty('--primary-hue', hue);
                localStorage.setItem('dndUIHue', hue);
                if (document.getElementById('currentHue')) {
                    document.getElementById('currentHue').textContent = hue;
                }
                if (document.getElementById('hueSlider')) {
                    document.getElementById('hueSlider').value = hue;
                }
            },
            setBackgroundHue(hue) {
                document.documentElement.style.setProperty('--background-hue', hue);
                localStorage.setItem('dndBackgroundHue', hue);
                if (document.getElementById('currentBackgroundHue')) {
                    document.getElementById('currentBackgroundHue').textContent = hue;
                }
                if (document.getElementById('backgroundHueSlider')) {
                    document.getElementById('backgroundHueSlider').value = hue;
                }
            },
            setUIFont(font) {
                document.body.style.fontFamily = font;
                localStorage.setItem('dndUIFont', font);
            },
            loadCustomFonts() {
                const savedFonts = localStorage.getItem('dndCustomFonts');
                if (savedFonts) {
                    const fonts = JSON.parse(savedFonts);
                    fonts.forEach(font => {
                        const style = document.createElement('style');
                        style.textContent = `@font-face { font-family: '${font.name}'; src: url('${font.url}') format('opentype'); }`;
                        document.head.appendChild(style);
                    });
                }
                this.buildFontDropdown();
            },

            buildFontDropdown() {
                const container = document.getElementById('fontDropdownContainer');
                if (!container) return;

                const savedFonts = JSON.parse(localStorage.getItem('dndCustomFonts') || '[]');
                const currentFont = localStorage.getItem('dndUIFont') || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";

                let html = `
        <select id="fontSelect" onchange="game.setUIFont(this.value)" style="width: 100%; padding: 10px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: white;">
            <option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif" ${currentFont.includes('apple-system') ? 'selected' : ''}>Default System</option>
            <option value="Arial, sans-serif" ${currentFont === 'Arial, sans-serif' ? 'selected' : ''}>Arial</option>
            <option value="'Times New Roman', serif" ${currentFont === "'Times New Roman', serif" ? 'selected' : ''}>Times New Roman</option>
            <option value="'Courier New', monospace" ${currentFont === "'Courier New', monospace" ? 'selected' : ''}>Courier New</option>
            <option value="Georgia, serif" ${currentFont === 'Georgia, serif' ? 'selected' : ''}>Georgia</option>
    `;

                savedFonts.forEach(font => {
                    html += `<option value="'${font.name}', sans-serif" ${currentFont.includes(font.name) ? 'selected' : ''}>${font.name}</option>`;
                });

                html += `</select>`;

                if (savedFonts.length > 0) {
                    html += `<div style="margin-top: 10px; font-size: 12px; color: #9ca3af;">Custom Fonts:</div>`;
                    savedFonts.forEach((font, index) => {
                        html += `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 5px 10px; background: rgba(0,0,0,0.3); margin-top: 5px; border-radius: 4px;">
                    <span>${font.name}</span>
                    <button onclick="game.removeCustomFont(${index})" style="background: #ef4444; border: none; color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">✕</button>
                </div>
            `;
                    });
                }

                container.innerHTML = html;
            },
            setHeaderLogo(url) {
                const logo = document.getElementById('combatHeaderLogo');
                const text = document.getElementById('combatHeaderText');
                if (logo && url) {
                    logo.src = url;
                    logo.style.display = 'block';
                    if (text) text.style.display = 'none';
                    localStorage.setItem('dndHeaderLogo', url);
                }
            },

            uploadHeaderLogo(file) {
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.setHeaderLogo(e.target.result);
                        const input = document.getElementById('headerLogoUrl');
                        if (input) input.value = 'Custom uploaded logo';
                    };
                    reader.readAsDataURL(file);
                }
            },

            clearHeaderLogo() {
                const logo = document.getElementById('combatHeaderLogo');
                const text = document.getElementById('combatHeaderText');
                if (logo) {
                    logo.style.display = 'none';
                    logo.src = '';
                }
                if (text) text.style.display = 'block';
                localStorage.removeItem('dndHeaderLogo');
                const input = document.getElementById('headerLogoUrl');
                if (input) input.value = '';
            },
            setUIBackground(url) {
                if (url) {
                    document.body.style.setProperty('--ui-bg-image', `url(${url})`);
                    const pseudo = document.querySelector('body::before') || document.body;
                    document.documentElement.style.setProperty('--ui-bg-url', `url(${url})`);
                    localStorage.setItem('dndUIBackground', url);

                    // Apply to body::before via style tag
                    let styleTag = document.getElementById('ui-bg-style');
                    if (!styleTag) {
                        styleTag = document.createElement('style');
                        styleTag.id = 'ui-bg-style';
                        document.head.appendChild(styleTag);
                    }
                    styleTag.textContent = `body::before { background-image: url(${url}) !important; }`;
                }
            },

            uploadUIBackground(file) {
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.setUIBackground(e.target.result);
                        const input = document.getElementById('uiBackgroundUrl');
                        if (input) input.value = 'Custom uploaded image';
                    };
                    reader.readAsDataURL(file);
                }
            },

            setUIBackgroundOpacity(value) {
                const opacity = parseInt(value) / 100;
                let styleTag = document.getElementById('ui-bg-style');
                if (!styleTag) {
                    styleTag = document.createElement('style');
                    styleTag.id = 'ui-bg-style';
                    document.head.appendChild(styleTag);
                }

                const currentBg = localStorage.getItem('dndUIBackground') || '';
                styleTag.textContent = `body::before { background-image: url(${currentBg}) !important; opacity: ${opacity} !important; }`;

                const display = document.getElementById('currentBgOpacity');
                if (display) display.textContent = value;

                localStorage.setItem('dndUIBackgroundOpacity', value);
            },
            uploadCustomFont(file) {
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const name = prompt('Enter font name:');
                        if (name) {
                            const fontUrl = e.target.result;
                            const style = document.createElement('style');
                            style.textContent = `@font-face { font-family: '${name}'; src: url('${fontUrl}') format('opentype'); }`;
                            document.head.appendChild(style);
                            this.setUIFont(`'${name}', sans-serif`);
                            let savedFonts = JSON.parse(localStorage.getItem('dndCustomFonts') || '[]');
                            savedFonts.push({ name, url: fontUrl });
                            localStorage.setItem('dndCustomFonts', JSON.stringify(savedFonts));
                            this.buildFontDropdown();
                        }
                    };
                    reader.readAsDataURL(file);
                }
            },

            removeCustomFont(index) {
                let savedFonts = JSON.parse(localStorage.getItem('dndCustomFonts') || '[]');
                const fontName = savedFonts[index].name;
                if (confirm(`Remove ${fontName}?`)) {
                    savedFonts.splice(index, 1);
                    localStorage.setItem('dndCustomFonts', JSON.stringify(savedFonts));
                    this.buildFontDropdown();
                    // Reset to default if current font was removed
                    if (document.body.style.fontFamily.includes(fontName)) {
                        this.setUIFont("-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif");
                    }
                }
            }
            ,

            // Import D&D Beyond PDF
            async importCharacterPDF(file) {
                if (!file) return;

                try {
                    const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
                    const pdf = await loadingTask.promise;

                    let fullText = '';

                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + '\n';
                    }

                    console.log('EXTRACTED TEXT:', fullText);
                    const characterData = this.parseDnDBeyondPDF(fullText);
                    console.log('PARSED DATA:', characterData);
                    const character = this.createEntity('player', characterData.name, 200, 200);
                    Object.assign(character, characterData);

                    this.entities.push(character);
                    this.updateCharacterList();
                    this.render();

                    this.addLog(`Imported ${characterData.name} from PDF`, 'info');
                    alert(`Successfully imported ${characterData.name}!`);
                } catch (e) {
                    alert('Failed to import PDF: ' + e.message);
                }
            },

            parseDnDBeyondPDF(text) {
                const data = {
                    name: 'Unknown',
                    class: 'Fighter',
                    race: 'Human',
                    level: 1,
                    hp: 10,
                    maxHp: 10,
                    ac: 10,
                    speed: 30,
                    str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10,
                    proficiencyBonus: 2,
                    attacks: [],
                    inventory: [],
                    spells: []
                };

                const nameMatch = text.match(/CHARACTER NAME\s+([^\n]+)/i);
                if (nameMatch) data.name = nameMatch[1].trim();

                const classMatch = text.match(/CLASS & LEVEL\s+([A-Za-z]+)\s+(\d+)/i);
                if (classMatch) {
                    data.class = classMatch[1];
                    data.level = parseInt(classMatch[2]);
                }

                const raceMatch = text.match(/SPECIES\s+([A-Za-z]+)/i);
                if (raceMatch) data.race = raceMatch[1];

                const strMatch = text.match(/Strength\s+(\d+)/i);
                if (strMatch) data.str = parseInt(strMatch[1]);

                const dexMatch = text.match(/Dexterity\s+(\d+)/i);
                if (dexMatch) data.dex = parseInt(dexMatch[1]);

                const conMatch = text.match(/Constitution\s+(\d+)/i);
                if (conMatch) data.con = parseInt(conMatch[1]);

                const intMatch = text.match(/Intelligence\s+(\d+)/i);
                if (intMatch) data.int = parseInt(intMatch[1]);

                const wisMatch = text.match(/Wisdom\s+(\d+)/i);
                if (wisMatch) data.wis = parseInt(wisMatch[1]);

                const chaMatch = text.match(/Charisma\s+(\d+)/i);
                if (chaMatch) data.cha = parseInt(chaMatch[1]);

                const hpMatch = text.match(/Max HP\s+(\d+)/i);
                if (hpMatch) {
                    data.maxHp = parseInt(hpMatch[1]);
                    data.hp = data.maxHp;
                }

                const acMatch = text.match(/ARMOR\s+CLASS\s+(\d+)/i);
                if (acMatch) data.ac = parseInt(acMatch[1]);

                const speedMatch = text.match(/(\d+)\s*ft\.\s*\(Walking\)/i);
                if (speedMatch) data.speed = parseInt(speedMatch[1]);

                return data;
            }
        };


      
        // Global tab switching function
        function switchTab(event, tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          
            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(`${tabName}-tab`).classList.add('active');
          
            if (tabName === 'characters') game.updateCharacterList();
            if (tabName === 'backgrounds') game.updateBackgroundList();
            if (tabName === 'media') game.updateMediaLists();
        }
        function openConversationManager() {
            window.open("DND Conversation Manager.html", "_blank");
        }
      
        // Initialize the game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
    </script>
</body>
</html>