0deg,
rgba(255,255,255,0.03) 0px,
transparent 1px,
transparent 2px,
rgba(255,255,255,0.03) 3px
);
pointer-events: none;
z-index: 1;
animation: staticNoise 8s steps(10) infinite;
}
@keyframes staticNoise {
0%, 100% { transform: translate(0, 0); }
10% { transform: translate(-1%, -1%); }
20% { transform: translate(1%, 1%); }
30% { transform: translate(-1%, 1%); }
40% { transform: translate(1%, -1%); }
50% { transform: translate(-1%, 0); }
60% { transform: translate(1%, 0); }
70% { transform: translate(0, -1%); }
80% { transform: translate(0, 1%); }
90% { transform: translate(1%, 1%); }
}
@keyframes glitch {
0%, 100% {
text-shadow: 2px 0 var(--accent-red), -2px 0 var(--accent-blue);
transform: translate(0);
}
20% {
text-shadow: 2px 0 var(--accent-blue), -2px 0 var(--accent-red);
transform: translate(-2px, 2px);
}
40% {
text-shadow: -2px 0 var(--accent-pink), 2px 0 var(--accent-green);
transform: translate(-2px, -2px);
}
60% {
text-shadow: 2px 0 var(--accent-green), -2px 0 var(--accent-purple);
transform: translate(2px, 2px);
}
80% {
text-shadow: -2px 0 var(--accent-purple), 2px 0 var(--accent-pink);
transform: translate(2px, -2px);
}
}
@keyframes shake {
0% { transform: translate(0, 0); }
25% { transform: translate(-5px, 0); }
50% { transform: translate(5px, 0); }
75% { transform: translate(-5px, 0); }
100% { transform: translate(0, 0); }
}
.password-screen {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: radial-gradient(circle at center, rgba(220,20,60,0.1) 0%, rgba(10,10,10,1) 100%);
display: flex;
justify-content: center;
align-items: center;
z-index: 9999;
transition: opacity 0.5s ease, visibility 0.5s ease;
}
.password-screen.hidden {
opacity: 0;
visibility: hidden;
}
.password-container {
text-align: center;
padding: 2rem;
position: relative;
z-index: 2;
}
.password-wrapper {
position: relative;
display: inline-block;
width: 100%;
max-width: 300px;
background: rgba(10,10,10,0.5);
border-radius: 5px;
}
.password-container h1 {
font-size: clamp(2rem, 5vw, 3rem);
margin-bottom: 2rem;
letter-spacing: 0.2em;
animation: glitch 2s infinite;
}
.password-input {
background: rgba(255,255,255,0.05) !important;
background-color: rgba(255,255,255,0.05) !important;
border: 2px solid rgba(255,255,255,0.2);
color: var(--primary-white) !important;
padding: 1rem 3rem 1rem 2rem;
font-size: 1.2rem;
text-align: center;
border-radius: 5px;
outline: none;
transition: border-color 0.3s ease, box-shadow 0.3s ease;
letter-spacing: 0.1em;
width: 100%;
-webkit-text-fill-color: var(--primary-white) !important;
-webkit-appearance: none;
-moz-appearance: none;
appearance: none;
}
.password-input:focus {
background: rgba(255,255,255,0.05) !important;
background-color: rgba(255,255,255,0.05) !important;
border-color: var(--accent-red);
box-shadow: 0 0 20px rgba(220,20,60,0.3);
}
.password-input:-webkit-autofill,
.password-input:-webkit-autofill:hover,
.password-input:-webkit-autofill:focus,
.password-input:-webkit-autofill:active {
-webkit-box-shadow: 0 0 0 1000px #0a0a0a inset !important;
-webkit-text-fill-color: var(--primary-white) !important;
background-color: transparent !important;
transition: background-color 5000s ease-in-out 0s;
caret-color: var(--primary-white) !important;
filter: brightness(0.9) !important;
color: #0a0a0a !important; /* Fallback to black text if white background appears */
}
/* Firefox autofill fix */
.password-input:-moz-autofill,
.password-input:-moz-autofill-preview {
background-color: transparent !important;
color: var(--primary-white) !important;
filter: brightness(0.9) !important;
}
/* Edge/IE autofill fix */
.password-input:-ms-input-placeholder {
color: rgba(255,255,255,0.5) !important;
}
input:-internal-autofill-selected {
appearance: menulist-button;
background-color: transparent !important;
background-image: none !important;
color: var(--primary-white) !important;
}
.password-toggle {
position: absolute;
right: 10px;
top: 50%;
transform: translateY(-50%);
background: none;
border: none;
color: var(--primary-white);
cursor: pointer;
padding: 5px;
font-size: 1.2rem;
opacity: 0.8;
transition: opacity 0.3s ease;
line-height: 1;
}
.password-toggle:hover {
opacity: 1;
}
@keyframes typing-glow {
0% { box-shadow: 0 0 5px rgba(220,20,60,0.5); }
50% { box-shadow: 0 0 20px rgba(220,20,60,0.8); }
100% { box-shadow: 0 0 5px rgba(220,20,60,0.5); }
}
.password-input.typing {
animation: typing-glow 0.5s ease;
}
.error-message {
color: var(--accent-red);
margin-top: 1rem;
opacity: 0;
transition: opacity 0.3s ease;
}
.error-message.show {
opacity: 1;
}
.main-hub {
display: none;
min-height: 100vh;
background: radial-gradient(circle at center, rgba(220,20,60,0.05) 0%, rgba(10,10,10,1) 100%);
position: relative;
z-index: 2;
}
.main-hub.active {
display: block;
}
.hub-header {
text-align: center;
padding: 4rem 2rem 2rem;
position: relative;
z-index: 2;
}
@keyframes floatLogo {
0%, 100% { transform: translateY(0px); }
50% { transform: translateY(-10px); }
}
.hub-logo {
max-width: 400px;
width: 100%;
height: auto;
margin-bottom: 1rem;
animation: floatLogo 3s ease-in-out infinite;
filter: drop-shadow(0 0 20px rgba(220,20,60,0.5))
drop-shadow(0 0 40px rgba(220,20,60,0.3));
position: relative;
z-index: 2;
}
.hub-header p {
font-size: 1.2rem;
opacity: 0.8;
}
.nav-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
gap: 2rem;
max-width: 1200px;
margin: 4rem auto;
padding: 0 2rem;
position: relative;
z-index: 2;
}
.nav-section {
background: rgba(255,255,255,0.05);
border: 2px solid rgba(255,255,255,0.1);
border-radius: 10px;
padding: 2rem;
transition: all 0.3s ease;
cursor: pointer;
}
.nav-section:hover {
transform: translateY(-5px);
border-color: var(--accent-red);
box-shadow: 0 10px 30px rgba(220,20,60,0.3);
}
.nav-section.keyboard-selected {
border-color: var(--accent-red);
box-shadow: 0 0 30px rgba(220,20,60,0.5);
transform: translateY(-5px);
}
.nav-section h2 {
font-size: 1.8rem;
margin-bottom: 1rem;
color: var(--accent-red);
letter-spacing: 0.1em;
}
.nav-section p {
opacity: 0.8;
margin-bottom: 1.5rem;
}
.section-view {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: radial-gradient(circle at center, rgba(220,20,60,0.05) 0%, rgba(10,10,10,1) 100%);
display: none;
z-index: 1000;
overflow: hidden;
}
.section-view.active {
display: flex;
flex-direction: column;
animation: expandIn 0.5s ease-out;
}
@keyframes expandIn {
from {
opacity: 0;
transform: scale(0.95);
}
to {
opacity: 1;
transform: scale(1);
}
}
.section-header {
text-align: center;
padding: 2rem;
position: relative;
z-index: 2;
}
.section-header h2 {
font-size: 3rem;
color: var(--accent-red);
margin-bottom: 1rem;
animation: glitch 3s infinite;
}
.carousel-container {
flex: 1;
display: flex;
align-items: center;
justify-content: center;
position: relative;
padding: 2rem;
perspective: 1200px;
min-height: 600px;
}
.carousel {
display: flex;
align-items: center;
height: 500px;
position: relative;
transform-style: preserve-3d;
width: 100%;
max-width: 1400px;
}
.project-card {
position: absolute;
width: 300px;
background: rgba(255,255,255,0.05);
border: 2px solid rgba(255,255,255,0.2);
border-radius: 15px;
overflow: hidden;
transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
cursor: pointer;
transform-origin: center;
will-change: transform, opacity, height;
-webkit-backface-visibility: hidden;
backface-visibility: hidden;
}
.project-card img {
width: 100%;
height: 200px;
object-fit: cover;
border-bottom: 2px solid rgba(255,255,255,0.1);
}
.project-card-content {
padding: 1.5rem;
}
.project-card h3 {
font-size: 1.5rem;
color: var(--accent-red);
margin-bottom: 1rem;
}
.project-card p {
opacity: 0.8;
font-size: 0.9rem;
line-height: 1.4;
}
.progress-bar {
margin-top: 1rem;
height: 10px;
background: rgba(255, 255, 255, 0.2);
border-radius: 5px;
overflow: hidden;
}
.progress-bar-fill {
height: 100%;
background: var(--accent-green);
transition: width 0.3s ease;
}
.progress-bar-label {
font-size: 0.8rem;
margin-top: 0.5rem;
color: var(--primary-white);
opacity: 0.8;
}
.link-status {
margin-top: 1rem;
padding: 0.5rem;
background: rgba(255,255,255,0.1);
border-radius: 5px;
text-align: center;
font-size: 0.9rem;
font-weight: bold;
letter-spacing: 0.05em;
}
.link-status.has-website {
color: var(--accent-green);
border: 1px solid var(--accent-green);
}
.link-status.has-vrchat {
color: var(--accent-blue);
border: 1px solid var(--accent-blue);
}
.link-status.no-website {
color: #888;
border: 1px solid #666;
}
.carousel-nav {
position: absolute;
top: 50%;
transform: translateY(-50%);
background: rgba(255,255,255,0.1);
border: 2px solid rgba(255,255,255,0.2);
color: var(--primary-white);
width: 40px;
height: 40px;
padding: 0;
line-height: 40px;
cursor: pointer;
border-radius: 50%;
font-size: 1.5rem;
transition: all 0.3s ease;
z-index: 10;
text-align: center;
}
.carousel-nav:hover {
background: rgba(220,20,60,0.2);
border-color: var(--accent-red);
}
.carousel-nav.prev {
left: 2rem;
}
.carousel-nav.next {
right: 2rem;
}
.project-card.unavailable {
opacity: 0.5;
filter: grayscale(100%);
cursor: not-allowed;
pointer-events: none;
}
.project-card.unavailable:hover {
transform: none;
border-color: rgba(255,255,255,0.1);
box-shadow: none;
}
.project-card.unavailable img {
filter: brightness(0.5);
}
.project-card.unavailable .project-card-content h3::after {
content: " (UNAVAILABLE)";
color: #888;
font-size: 0.8rem;
}
.project-card.unavailable .project-card-content p,
.project-card.unavailable .progress-bar,
.project-card.unavailable .progress-bar-label,
.project-card.unavailable .link-status {
display: none;
}
.gallery-viewport {
position: relative;
width: 100%;
height: calc(100vh - 120px);
overflow: hidden;
cursor: move;
}
.gallery-canvas {
position: absolute;
width: 100%;
height: 100%;
transform-origin: center center;
transition: transform 0.1s ease-out;
}
.gallery-arrow {
position: absolute;
color: var(--accent-red);
font-size: 3rem;
opacity: 0;
transition: opacity 0.3s ease;
pointer-events: none;
text-shadow: 0 0 20px rgba(220,20,60,0.8);
z-index: 10;
}
.gallery-arrow.active {
opacity: 0.8;
}
.gallery-arrow.top {
top: 20px;
left: 50%;
transform: translateX(-50%);
}
.gallery-arrow.bottom {
bottom: 20px;
left: 50%;
transform: translateX(-50%) rotate(180deg);
}
.gallery-arrow.left {
left: 20px;
top: 50%;
transform: translateY(-50%) rotate(-90deg);
}
.gallery-arrow.right {
right: 20px;
top: 50%;
transform: translateY(-50%) rotate(90deg);
}
.gallery-image {
position: absolute;
cursor: pointer;
transition: transform 0.3s ease;
opacity: 0;
transform: scale(0.9);
}
.gallery-image.loaded {
opacity: 1;
transform: scale(1);
}
.gallery-image img {
max-width: 300px;
max-height: 300px;
width: auto;
height: auto;
border: 2px solid rgba(255,255,255,0.1);
border-radius: 10px;
display: block;
}
.gallery-image:hover {
transform: scale(1.1);
z-index: 10;
}
.gallery-image:hover img {
box-shadow: 0 0 30px rgba(220,20,60,0.6);
border-color: var(--accent-red);
}
.gallery-image.focused {
transform: scale(1.3);
z-index: 100;
}
.gallery-image.focused img {
box-shadow: 0 0 50px rgba(220,20,60,0.8);
border-color: var(--accent-red);
}
.gallery-image-info {
position: absolute;
bottom: -30px;
left: 50%;
transform: translateX(-50%);
background: rgba(0,0,0,0.9);
padding: 8px 15px;
border-radius: 5px;
white-space: nowrap;
opacity: 0;
transition: opacity 0.3s ease;
font-size: 0.9rem;
pointer-events: none;
text-align: center;
max-width: 400px;
width: max-content;
}
.gallery-image:hover .gallery-image-info,
.gallery-image.show-title .gallery-image-info {
opacity: 1;
}
.gallery-image-title {
color: var(--primary-white);
margin-bottom: 5px;
}
.gallery-image-description {
color: #ff4444;
font-size: 0.85rem;
white-space: normal;
line-height: 1.3;
margin-top: 5px;
display: none;
}
.gallery-image.show-description .gallery-image-description {
display: block;
}
.gallery-image.centered {
transform: scale(1.3);
z-index: 100;
}
.gallery-image.centered img {
box-shadow: 0 0 50px rgba(220,20,60,0.8);
border-color: var(--accent-red);
}
.gallery-image.centered .gallery-image-info {
opacity: 1;
}
.gallery-image.centered .gallery-image-description {
display: block;
}
.about-section {
max-width: 800px;
margin: 4rem auto;
padding: 0 2rem;
text-align: center;
position: relative;
z-index: 2;
}
.about-section.hidden {
display: none;
}
.profile-header {
margin-bottom: 2rem;
}
.profile-pic {
width: 200px;
height: 200px;
border-radius: 50%;
border: 3px solid var(--accent-red);
margin-bottom: 2rem;
object-fit: cover;
filter: drop-shadow(0 0 20px rgba(220,20,60,0.3));
}
.bio-text p {
margin-bottom: 1rem;
}
.bio-text p:last-child {
margin-bottom: 2rem;
}
.social-links {
display: flex;
justify-content: center;
gap: 2rem;
flex-wrap: wrap;
}
.social-link {
display: inline-block;
padding: 0.8rem 1.5rem;
background: rgba(255,255,255,0.05);
border: 2px solid rgba(255,255,255,0.2);
border-radius: 5px;
text-decoration: none;
color: var(--primary-white);
transition: all 0.3s ease;
}
.social-link:hover {
border-color: var(--accent-red);
transform: translateY(-2px);
box-shadow: 0 5px 15px rgba(220,20,60,0.3);
}
@keyframes float {
0%, 100% { transform: translateY(0px); }
50% { transform: translateY(-20px); }
}
.red-shard {
width: 80px;
height: 80px;
background: radial-gradient(circle, var(--accent-red), rgba(220,20,60,0.3));
border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
margin: 2rem auto;
animation: float 3s ease-in-out infinite;
box-shadow: 0 0 50px var(--accent-red);
cursor: pointer;
transition: transform 0.1s ease;
}
.red-shard.shake {
animation: shake 0.3s ease;
}
.back-button {
position: fixed;
top: 2rem;
left: 2rem;
padding: 0.8rem 1.5rem;
background: rgba(255,255,255,0.05);
border: 2px solid rgba(255,255,255,0.2);
color: var(--primary-white);
cursor: pointer;
border-radius: 5px;
transition: all 0.3s ease;
z-index: 100;
}
.back-button:hover {
border-color: var(--accent-red);
animation: glitch 0.3s;
}
.back-button.hidden {
display: none;
}
.volume-control {
position: fixed;
bottom: 1rem;
right: 1rem;
z-index: 1000;
display: flex;
align-items: center;
gap: 0.5rem;
}
.volume-control label {
font-size: 0.9rem;
opacity: 0.8;
}
.volume-slider {
-webkit-appearance: none;
appearance: none;
width: 100px;
height: 5px;
background: rgba(255,255,255,0.2);
border-radius: 5px;
outline: none;
transition: background 0.3s ease;
}
.volume-slider::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 15px;
height: 15px;
background: var(--accent-red);
border-radius: 50%;
cursor: pointer;
box-shadow: 0 0 10px rgba(220,20,60,0.5);
}
.volume-slider::-moz-range-thumb {
width: 15px;
height: 15px;
background: var(--accent-red);
border-radius: 50%;
cursor: pointer;
box-shadow: 0 0 10px rgba(220,20,60,0.5);
}
.volume-slider:hover {
background: rgba(255,255,255,0.3);
}
@media (max-width: 768px) {
body {
overflow-x: hidden;
}
.section-view {
overflow-x: hidden;
overflow-y: hidden;
}
.nav-grid {
grid-template-columns: 1fr;
padding: 0 1rem;
}
.hub-logo {
max-width: 250px;
}
.social-links {
flex-direction: column;
align-items: center;
}
.profile-pic {
width: 150px;
height: 150px;
}
.volume-control {
bottom: 0.5rem;
right: 0.5rem;
}
.volume-slider {
width: 80px;
}
.carousel-container {
perspective: none;
padding: 1rem;
min-height: 500px;
}
.carousel {
height: 420px;
transform-style: flat;
}
.project-card {
width: 280px;
}
.project-card img {
height: 180px;
}
.carousel-nav {
width: 40px;
height: 40px;
padding: 0;
line-height: 40px;
font-size: 1.2rem;
}
.carousel-nav.prev {
left: 0.5rem;
}
.carousel-nav.next {
right: 0.5rem;
}
.section-header {
padding: 1.5rem 1rem;
}
.section-header h2 {
font-size: 2rem;
}
.gallery-image img {
max-width: 200px;
max-height: 200px;
}
.gallery-arrow {
font-size: 2rem;
}
.gallery-image.centered {
transform: scale(1.2) !important;
z-index: 100;
}
.gallery-image-info {
font-size: 0.85rem;
bottom: -60px;
}
.gallery-image.centered .gallery-image-info {
opacity: 1;
}
}
</style>
</head>
<body>
<div class="password-screen" id="passwordScreen">
<div class="password-container">
<h1>ENTER THE ABYSS</h1>
<div class="red-shard" id="redShard" onclick="checkPasswordViaShard()"></div>
<div class="password-wrapper">
<input type="password"
class="password-input"
id="passwordInput"
placeholder="Enter Password"
autocomplete="new-password"
autocorrect="off"
autocapitalize="off"
spellcheck="false">
<button class="password-toggle" id="passwordToggle" onclick="togglePassword()" type="button">üëÅ</button>
</div>
<div class="error-message" id="errorMessage">Access Denied</div>
</div>
</div>
    
        <button class="back-button hidden" id="backButton" onclick="showHub()">‚Üê BACK TO HUB</button>
        
            
                <img src="Art Folder/logo0.png" alt="Abyssal Light Logo" class="hub-logo">
                Games & Digital Experiences
            
            
                
                    GAMES
                    Gaming Experiences and Concepts of all different kinds
                
                
                    VRCHAT WORLDS
                    Worlds and Games Made Exclusively for VRChat
                
                
                    ART GALLERY
                    Random Collection of Art Created Over the Years
                
                
                    ABYL RPG SYSTEM
                    Turn-based RPG framework for VRChat
                
                
                    OTHER PROJECTS
                    Other Projects and Experiments from Across Different Mediums
                
                
                    ABOUT
                    Learn more about the creator
                
            
        
        
            
                <img src="Art Folder/profile-pic.jpg" alt="Profile" class="profile-pic">
                NULLXVOID
            
            
                
                    I'm NullxVoid ‚Äî or just "Null" ‚Äî And I'm an amateur game designer and VRChat world and avatar creator. I specialize in crafting emotionally driven, psychologically rich experiences that blend surrealism with interactive storytelling.
                
                
                    My work often explores identity, perception, and the uncanny, using genre fusion as a tool to challenge expectations. As a creator, I aspire to build immersive spaces that resonate deeply, provoke thought, and leave a lasting impression beyond the screen.
                
            
            
                Twitter
                Discord
                YouTube
                GitHub
                Patreon
            
        
    
    
        
            GAMES
            Gaming Experiences and Concepts of all different kinds
        
        
            <button class="carousel-nav prev" onclick="moveCarousel(&#x27;games&#x27;, -1)">‚Äπ</button>
            
            <button class="carousel-nav next" onclick="moveCarousel(&#x27;games&#x27;, 1)">‚Ä∫</button>
        
        <button class="back-button" onclick="closeSection()">‚Üê BACK TO HUB</button>
    
    
        
            VRCHAT WORLDS
            Worlds and Games Made Exclusively for VRChat
        
        
            <button class="carousel-nav prev" onclick="moveCarousel(&#x27;vrchat&#x27;, -1)">‚Äπ</button>
            
            <button class="carousel-nav next" onclick="moveCarousel(&#x27;vrchat&#x27;, 1)">‚Ä∫</button>
        
        <button class="back-button" onclick="closeSection()">‚Üê BACK TO HUB</button>
    
    
        
            ART GALLERY
            Random Collection of Art Created Over the Years
        
        
            
            ‚ñ≤
            ‚ñ≤
            ‚ñ≤
            ‚ñ≤
        
        <button class="back-button" onclick="closeSection()">‚Üê BACK TO HUB</button>
    
    
        
            OTHER PROJECTS
            Other Projects and Experiments from Across Different Mediums
        
        
            <button class="carousel-nav prev" onclick="moveCarousel(&#x27;other&#x27;, -1)">‚Äπ</button>
            
            <button class="carousel-nav next" onclick="moveCarousel(&#x27;other&#x27;, 1)">‚Ä∫</button>
        
        <button class="back-button" onclick="closeSection()">‚Üê BACK TO HUB</button>
    
    <audio id="passwordAudio" loop>
        <source src="audio/password-bg.mp3" type="audio/mpeg">
    </audio>
    <audio id="hubAudio" loop>
        <source src="audio/hub-bg.mp3" type="audio/mpeg">
    </audio>
    <audio id="clickAudio">
        <source src="audio/Click.mp3" type="audio/mpeg">
    </audio>
    
        Volume
        
    
    <script>
        // Audio functionality
        const passwordAudio = document.getElementById('passwordAudio');
        const hubAudio = document.getElementById('hubAudio');
        const clickAudio = document.getElementById('clickAudio');
        const volumeSlider = document.getElementById('volumeSlider');

        passwordAudio.volume = volumeSlider.value;
        hubAudio.volume = volumeSlider.value;
        clickAudio.volume = volumeSlider.value;

        volumeSlider.addEventListener('input', function() {
            passwordAudio.volume = this.value;
            hubAudio.volume = this.value;
            clickAudio.volume = this.value;
        });

        function playClickSound() {
            clickAudio.currentTime = 0;
            clickAudio.play().catch(e => console.log('Click sound error:', e));
        }

        document.addEventListener('click', function(e) {
            if (e.target.matches('.nav-section, .project-card, .gallery-image, button, .social-link, .carousel-nav')) {
                playClickSound();
            }
        });

        const passwordInput = document.getElementById('passwordInput');
        const passwordScreen = document.getElementById('passwordScreen');
        const mainHub = document.getElementById('mainHub');
        const errorMessage = document.getElementById('errorMessage');
        const redShard = document.getElementById('redShard');

        function togglePassword() {
            const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordInput.setAttribute('type', type);
            document.getElementById('passwordToggle').textContent = type === 'password' ? 'üëÅ' : '‚óè';
        }

        passwordInput.addEventListener('input', function() {
            this.classList.add('typing');
            setTimeout(() => this.classList.remove('typing'), 500);
        });

        passwordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                checkPassword();
            }
        });

function checkPassword() {
    if (passwordInput.value === 'Neurorine') {
        // Store authentication flag in localStorage
        localStorage.setItem('abyssalAuth', 'true');
        passwordScreen.classList.add('hidden');
        let fadeOut = setInterval(() => {
            if (passwordAudio.volume > 0.01) {
                passwordAudio.volume -= 0.01;
            } else {
                passwordAudio.pause();
                clearInterval(fadeOut);
            }
        }, 50);
        setTimeout(() => {
            passwordScreen.style.display = 'none';
            mainHub.classList.add('active');
            // Reinitialize keyboard navigation now that hub is visible
            initKeyboardNav();
            // Reset keyboard navigation state
            keyboardNav.enabled = false;
            keyboardNav.currentIndex = -1;
            keyboardNav.hubSections.forEach(section => {
                section.classList.remove('keyboard-selected');
            });
            hubAudio.volume = 0;
            hubAudio.play();
            let fadeIn = setInterval(() => {
                if (hubAudio.volume < volumeSlider.value) {
                    hubAudio.volume = Math.min(hubAudio.volume + 0.01, volumeSlider.value);
                } else {
                    clearInterval(fadeIn);
                }
            }, 50);
        }, 500);
    } else {
        errorMessage.classList.add('show');
        passwordInput.value = '';
        setTimeout(() => errorMessage.classList.remove('show'), 2000);
    }
}

        function checkPasswordViaShard() {
            redShard.classList.add('shake');
            setTimeout(() => redShard.classList.remove('shake'), 300);
            checkPassword();
        }

        const projectData = {
            games: [
                {
                    title: "Caine & Cin: God Killers",
                    description: "Indie RPG following Caine, a boy cursed into a demon, and Cin, a fallen angel, as they descend into The Afterlife to confront the God who damned them.",
                    image: "Art Folder/GameProject2.jpg",
                    link: "Caine&Cin.html",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Ego/Dive",
                    description: "Indie RPG where fragmented personalities of a comatose person unite in the surreal world of Absentia to mend their fractured mind.",
                    image: "Art Folder/GameProject1.jpg",
                    link: "ego-dive.html",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Axiom of Infinity",
                    description: "JRPG-Fighting Game hybrid where Cliff, Amber, and dimension-hopping allies battle to halt a universe-threatening Calamity.",
                    image: "Art Folder/GameProject4.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Phantom Echoes",
                    description: "Horror Platformer where Alex, a red fox, traverses a nightmarish dreamscape to find peace amidst haunting challenges.",
                    image: "Art Folder/GameProject5.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Milo's Quest",
                    description: "Platformer following Milo, a boy escaping his monstrous father to deliver flowers to his mother's grave in a perilous journey.",
                    image: "Art Folder/GameProject6.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Enclave 447",
                    description: "Adventure Game where Will and friends reunite after a tragedy in a strange town to witness a rare astrological event.",
                    image: "Art Folder/GameProject7.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Go! Ko! Go! Kart Racer DX",
                    description: "Kart Racing Visual Novel Horror where demon girl Ko competes in the Grand Prix while investigating a killer targeting racers.",
                    image: "Art Folder/GameProject3.jpg",
                    link: "GO-KO-GO.html",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Vex: Arcadian Entropy",
                    description: "FPS JRPG hybrid, Where 2 people from differnt worlds journey together with their allies to stop an insidious plot to strip humanity of it's resources",
                    image: "Art Folder/GameProject8.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
            ],
            vrchat: [
                // Completed projects first
                {
                    title: "Club Flipside",
                    description: "VRChat Experience where players dance in a zero-gravity club with optional physics, creating a surreal social space.",
                    image: "Art Folder/VRCProject2.jpg",
                    link: "Club-Flipside.html",
                    progress: "Completed",
                    isAvailable: "O"
                },
                {
                    title: "Omni-Cube",
                    description: "Multi-sided gravity cube, with 6 different themes for each side and switchable skyboxes and video player.",
                    image: "Art Folder/VRCProject12.jpg",
                    link: "https://vrchat.com/home/launch?worldId=wrld_58b431d7-e804-44dc-975d-d0cbf0593e77",
                    progress: "Completed",
                    isAvailable: "O"
                },
                {
                    title: "Pickup Park",
                    description: "Park hangout environment, players can climb and ride on each other and customize environment.",
                    image: "Art Folder/VRCProject13.jpg",
                    link: "https://vrchat.com/home/launch?worldId=wrld_8a5ee9df-7dc3-47b9-a3b2-1b19a771cd89",
                    progress: "Completed",
                    isAvailable: "O"
                },
                {
                    title: "Void Island Redux",
                    description: "Island hangout world, customizable settings, house hangout and secrets.",
                    image: "Art Folder/VRCProject14.jpg",
                    link: "https://vrchat.com/home/launch?worldId=wrld_dec9ed04-5621-406a-a09c-a7e663357c6b",
                    progress: "Completed",
                    isAvailable: "O"
                },
                {
                    title: "Abyssal: Club and Arcade",
                    description: "Immensely Customizable Bar and Arcade with many hangout areas including a bar and theater.",
                    image: "Art Folder/VRCProject15.jpg",
                    link: "https://vrchat.com/home/launch?worldId=wrld_d02a5236-9024-49bd-ba3e-f6384a48872f",
                    progress: "Completed",
                    isAvailable: "O"
                },
                // Unfinished projects (highest to lowest percentage)
                {
                    title: "360 Video Room",
                    description: "360 video world with customization and customization options, group games.",
                    image: "Art Folder/VRCProject16.jpg",
                    link: "https://vrchat.com/home/launch?worldId=wrld_6c65be07-8720-48d6-81a5-f3cb16e4fc58",
                    progress: { status: "Unfinished", percentage: 85 },
                    isAvailable: "O"
                },
                {
                    title: "Vapor Waves",
                    description: "Vaporwave themed beaches with multiple hangout areas and persistent customization.",
                    image: "Art Folder/VRCProject17.jpg",
                    link: "https://vrchat.com/home/launch?worldId=wrld_58f36abc-bcc4-419b-bc56-71d2dd288cf2",
                    progress: { status: "Unfinished", percentage: 70 },
                    isAvailable: "O"
                },
                {
                    title: "Super Mario 64 Warfare",
                    description: "VRChat Experience where chaos unfolds in a colliding Mushroom Kingdom, blending nostalgia with mayhem.",
                    image: "Art Folder/VRCProject3.jpg",
                    link: "SM64W.html",
                    progress: { status: "Unfinished", percentage: 40 },
                    isAvailable: "O"
                },
                {
                    title: "Drifter's Passing",
                    description: "World based off a Role-play Campaign, Noir Digital Cabaret diner/bar with option gameplay elements and record player with savable custom records.",
                    image: "Art Folder/VRCProject18.jpg",
                    link: "#",
                    progress: { status: "Unfinished", percentage: 40 },
                    isAvailable: "O"
                },
                {
                    title: "Joyride",
                    description: "Vehicle Hangout world allowing you to chill in an automated drive in different select environments and vehicles.",
                    image: "Art Folder/VRCProject19.jpg",
                    link: "#",
                    progress: { status: "Unfinished", percentage: 40 },
                    isAvailable: "O"
                },
                {
                    title: "Sonic Adventure VR",
                    description: "VRChat Remake of Sonic Adventure with rebuilt physics and multiplayer, reimagining the classic for VR.",
                    image: "Art Folder/SAMCover.png",
                    link: "SAVR.html",
                    progress: { status: "Unfinished", percentage: 20 },
                    isAvailable: "O"
                },
                {
                    title: "2000's TV Room",
                    description: "2000's TV Room, where channels can be selected that show videos exclusively to that channel, including commercials and time blocks based on realtime.",
                    image: "Art Folder/VRCProject20.jpg",
                    link: "#",
                    progress: { status: "Unfinished", percentage: 20 },
                    isAvailable: "O"
                },
                {
                    title: "Dear Mario",
                    description: "VRChat Horror where Mario, distorted as 'Mar,' hunts for 5 Bleached Stars in a monochrome, twisted castle.",
                    image: "Art Folder/VRCProject5.jpg",
                    link: "Dear-Mario.html",
                    progress: { status: "Unfinished", percentage: 10 },
                    isAvailable: "O"
                },
                {
                    title: "EGO/TRIP",
                    description: "VRChat Experience guiding players through a surreal labyrinth of the mind, serving as a prelude to deeper narratives.",
                    image: "Art Folder/VRCProject0.jpg",
                    link: "ego-trip.html",
                    progress: { status: "Unfinished", percentage: 10 },
                    isAvailable: "O"
                },
                {
                    title: "The Static Speaks My Name Remake",
                    description: "Remake of the Indie horror game of the same name, inside the mind and apartment of a tortured mind.",
                    image: "Art Folder/VRCProject21.jpg",
                    link: "#",
                    progress: { status: "Unfinished", percentage: 10 },
                    isAvailable: "O"
                },
                {
                    title: "End with You",
                    description: "VRChat Experience where players have 30 minutes before an apocalypse to interact with NPCs, fulfill requests, or offer comfort, with a journal tracking routines.",
                    image: "Art Folder/VRCProject1.jpg",
                    link: "end-with-you.html",
                    progress: { status: "Unfinished", percentage: 5 },
                    isAvailable: "O"
                },
                {
                    title: "Super Mario 64 Warfare: Zombies",
                    description: "Zombies mode version of Super Mario 64 Warfare, based around co-op and wave survival, similar to Call of Duty Zombies.",
                    image: "Art Folder/VRCProject22.jpg",
                    link: "#",
                    progress: { status: "Unfinished", percentage: 5 },
                    isAvailable: "O"
                },
                // Concept projects
                {
                    title: "Escape Unit",
                    description: "Asymmetric VRChat Horror where players navigate haunted locations against unique monsters, guided by control room allies.",
                    image: "Art Folder/VRCProject6.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Tales of VRtallis",
                    description: "VR JRPG where four warriors, hosting gods, battle corruption through turn-based combat and exploration.",
                    image: "Art Folder/VRCProject7.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Maverick Force X",
                    description: "Mega Man X-style VRChat game where players battle viral androids, gain boss abilities, and uncover a shadowy conspiracy.",
                    image: "Art Folder/VRCProject8.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "The AIEOS Phenomenon",
                    description: "VR Horror RPG where survivors hunt a mysterious signal in a dystopian world, wielding AI-powered nano-tech.",
                    image: "Art Folder/VRCProject9.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Tsuki≈ç Koromashi (Moon King: Roll it Up!)",
                    description: "VR Katamari-inspired game where players roll clutter to form planets for the Moon King's galactic empire.",
                    image: "Art Folder/VRCProject10.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "FNAF Prophunt",
                    description: "Prophunt based in Freddy Fazbear's Pizzaria, with jump scare prop mechanics.",
                    image: "Art Folder/VRCProject23.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Out of Hell's Reach",
                    description: "A VRChat Competitive Climbing Horror Game, where players compete to reach a mountain top while outclimbing a pursuing monster.",
                    image: "Art Folder/VRCProject24.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
            ],
            other: [
                // Unfinished projects first
                {
                    title: "Wraith Blade VRChat Project",
                    description: "Arcade Machine Project made for VRChat, inspired by Vampire Survivors.",
                    image: "Art Folder/OtherProject12.jpg",
                    link: "#",
                    progress: { status: "Unfinished", percentage: 20 },
                    isAvailable: "O"
                },
                // Concept projects
                {
                    title: "Red Threads",
                    description: "Book/Audio Play where a detective hunts a serial killer stitching victims into grotesque displays, unraveling a chilling mystery.",
                    image: "Art Folder/OtherProject2.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Oracle's Burden",
                    description: "Book following a therapist haunted by a patient's suicide, unraveling their cryptic influence from beyond the grave.",
                    image: "Art Folder/OtherProject3.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "M.E.G Notes 0017| Maggie",
                    description: "Backrooms Story where a young girl and a Party-Pooper entity form a bond to survive the Backrooms' dangers.",
                    image: "Art Folder/OtherProject4.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Think Tank",
                    description: "Book Idea where soldiers and a sentient hand, trapped in a Vietnam War tank, descend into madness.",
                    image: "Art Folder/OtherProject5.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "The Place Unknown",
                    description: "Short Story where immortals confront an abyss, one paralyzed by fear, exploring existential dread.",
                    image: "Art Folder/OtherProject6.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "VStalkR16",
                    description: "VR Horror Series where players hunt a hacker in a decaying virtual world after a fatal incident.",
                    image: "Art Folder/OtherProject1.jpg",
                    link: "VS16.html",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Apex",
                    description: "Action Horror Film where an assassin battles a supernatural killer to save his daughter in a gritty showdown.",
                    image: "Art Folder/OtherProject7.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Let's Hate Each Other",
                    description: "Dark Comedy Horror where two girls escalate a rivalry through heinous acts, blending humor and horror.",
                    image: "Art Folder/OtherProject8.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Reincarnate The Apex",
                    description: "Isekai where a fish reincarnates as monster Gyo, bonding with mage Ekverdt in a fantastical world.",
                    image: "Art Folder/OtherProject9.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Charlotte & Ben",
                    description: "Romance War Story of a man and woman longing for reunion amidst a devastating war's chaos.",
                    image: "Art Folder/OtherProject10.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "LimeLight",
                    description: "Crime Thriller where a lawyer, blackmailed by a client, navigates a dangerous murder case conspiracy.",
                    image: "Art Folder/OtherProject11.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "REPO Board Game",
                    description: "A board game based on the game mechanics of REPO, the Roguelite Horror Party Game.",
                    image: "Art Folder/OtherProject13.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                },
                {
                    title: "Abyl DND System",
                    description: "DnD Combat and Game Manager",
                    image: "Art Folder/OtherProject14.jpg",
                    link: "#",
                    progress: "Concept",
                    isAvailable: "O"
                }
            ]
        };

        let carouselStates = {
            games: { currentIndex: 0 },
            vrchat: { currentIndex: 0 },
            other: { currentIndex: 0 }
        };

        let touchStartX = 0;
        let touchEndX = 0;

        function handleTouchStart(e) {
            touchStartX = e.changedTouches[0].screenX;
        }

        function handleTouchEnd(e, type) {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe(type);
        }

        function handleSwipe(type) {
            if (touchEndX < touchStartX - 50) {
                moveCarousel(type, 1);
            }
            if (touchEndX > touchStartX + 50) {
                moveCarousel(type, -1);
            }
        }

        function initializeCarousels() {
            initializeCarousel('games', projectData.games);
            initializeCarousel('vrchat', projectData.vrchat);
            initializeCarousel('other', projectData.other);
            
            ['games', 'vrchat', 'other'].forEach(type => {
                const carousel = document.getElementById(`${type}Carousel`);
                if (carousel) {
                    carousel.addEventListener('touchstart', handleTouchStart, { passive: true });
                    carousel.addEventListener('touchend', (e) => handleTouchEnd(e, type), { passive: true });
                }
            });
        }

        function initializeCarousel(type, data) {
            const carousel = document.getElementById(`${type}Carousel`);
            carousel.innerHTML = '';
            
            carousel.style.position = 'relative';
            carousel.style.width = '100%';
            carousel.style.height = '100%';
            
            // Sort data based on completion and availability
            const sortedData = [...data].sort((a, b) => {
                // Check if projects are unavailable
                const aUnavailable = a.isAvailable === "X";
                const bUnavailable = b.isAvailable === "X";
                
                // Unavailable projects go to the end
                if (aUnavailable && !bUnavailable) return 1;
                if (!aUnavailable && bUnavailable) return -1;
                if (aUnavailable && bUnavailable) return 0;
                
                // Sort by completion status
                const getCompletionOrder = (project) => {
                    if (project.progress === "Completed") return 0;
                    if (project.progress && project.progress.status === "Unfinished") return 1;
                    return 2; // Concept
                };
                
                const aOrder = getCompletionOrder(a);
                const bOrder = getCompletionOrder(b);
                
                if (aOrder !== bOrder) return aOrder - bOrder;
                
                // If both are unfinished, sort by percentage
                if (a.progress && a.progress.status === "Unfinished" && 
                    b.progress && b.progress.status === "Unfinished") {
                    return b.progress.percentage - a.progress.percentage;
                }
                
                return 0;
            });
            
            sortedData.forEach((project, index) => {
                const card = document.createElement('div');
                card.className = 'project-card';
                
                // Check if project is unavailable
                const isUnavailable = project.isAvailable === "X";
                if (isUnavailable) {
                    card.classList.add('unavailable');
                }
                
                card.style.left = '50%';
                card.style.top = '50%';
                
                let progressHTML = '';
                let linkStatusHTML = '';
                
                if (!isUnavailable) {
                    // Progress bar HTML
                    if (project.progress === "Completed") {
                        progressHTML = `
                            
                                
                            
                            Progress: Completed
                        `;
                    } else if (project.progress === "Concept") {
                        progressHTML = `
                            
                                
                            
                            Progress: Concept
                        `;
                    } else if (project.progress.status === "Unfinished") {
                        progressHTML = `
                            
                                
                            
                            Progress: Unfinished (${project.progress.percentage}%)
                        `;
                    }
                    
                    // Link status HTML
                    if (project.link && project.link !== '#') {
                        if (project.link.includes('vrchat')) {
                            linkStatusHTML = 'Visit VRChat Link!';
                        } else {
                            linkStatusHTML = 'Visit Website!';
                        }
                    } else {
                        linkStatusHTML = 'No Website Yet Available';
                    }
                }

                card.innerHTML = `
                    <img src="${project.image}" alt="${project.title}" onerror="this.src=&#x27;Art Folder/placeholder.jpg&#x27;">
                    
                        ${project.title}
                        ${project.description}
                        ${progressHTML}
                        ${linkStatusHTML}
                    
                `;
                
                if (!isUnavailable && project.link && project.link !== '#') {
                    card.onclick = () => {
                        if (project.link.startsWith('http')) {
                            window.open(project.link, '_blank');
                        } else {
                            window.location.href = project.link;
                        }
                    };
                }
                
                carousel.appendChild(card);
            });
            
            updateCarouselPositions(type);
        }

        function updateCarouselPositions(type) {
            const carousel = document.getElementById(`${type}Carousel`);
            const cards = carousel.querySelectorAll('.project-card');
            const { currentIndex } = carouselStates[type];
            const isMobile = window.innerWidth <= 768;
            
            cards.forEach((card, index) => {
                const offset = index - currentIndex;
                const absOffset = Math.abs(offset);
                const sign = offset < 0 ? -1 : 1;
                
                // Reset height to auto to measure content height for focused card
                card.style.height = 'auto';
                
                // Calculate content height for focused card
                let cardHeight = isMobile ? 380 : 450; // Default heights
                if (index === currentIndex) {
                    const content = card.querySelector('.project-card-content');
                    const img = card.querySelector('img');
                    const contentHeight = content.offsetHeight;
                    const imgHeight = isMobile ? 180 : 200;
                    cardHeight = contentHeight + imgHeight + 4; // Include border
                }
                
                card.style.height = `${cardHeight}px`;
                
                if (isMobile) {
                    const cardWidth = 280;
                    const translateX = offset * (cardWidth + 20);
                    const scale = absOffset === 0 ? 1 : 0.85;
                    const opacity = absOffset === 0 ? 1 : 0.3;
                    
                    card.style.marginLeft = `-${cardWidth / 2}px`;
                    card.style.marginTop = `-${cardHeight / 2}px`;
                    
                    card.style.transform = `translateX(${translateX}px) scale(${scale})`;
                    card.style.opacity = opacity;
                    card.style.zIndex = absOffset === 0 ? 10 : 1;
                    card.style.transition = 'all 0.4s ease-out';
                } else {
                    const spacing = 320;
                    const translateX = offset * spacing;
                    const translateZ = -absOffset * 100;
                    const rotateY = sign * Math.min(absOffset * 15, 45);
                    const scale = 1 - Math.min(absOffset * 0.2, 0.6);
                    const opacity = 1 - Math.min(absOffset * 0.3, 0.7);
                    
                    card.style.marginLeft = '-150px';
                    card.style.marginTop = `-${cardHeight / 2}px`;
                    
                    card.style.transform = `
                        translateX(${translateX}px) 
                        translateZ(${translateZ}px) 
                        rotateY(${rotateY}deg) 
                        scale(${scale})
                    `;
                    card.style.opacity = opacity;
                    card.style.zIndex = 10 - absOffset;
                    card.style.transition = 'all 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                }
                
                card.style.pointerEvents = absOffset === 0 ? 'auto' : 'none';
            });
        }

        function moveCarousel(type, direction) {
            const carousel = document.getElementById(`${type}Carousel`);
            const cards = carousel.querySelectorAll('.project-card');
            const state = carouselStates[type];
            
            state.currentIndex = Math.max(0, Math.min(cards.length - 1, state.currentIndex + direction));
            updateCarouselPositions(type);
        }

        // Gallery Mind Map functionality
        const galleryState = {
            images: [],
            loadedImages: new Map(),
            canvasOffset: { x: 0, y: 0 },
            velocity: { x: 0, y: 0 },
            mousePos: { x: 0.5, y: 0.5 },
            worldSize: { width: 10000, height: 10000 },
            focusedImage: null,
            animationId: null,
            isGalleryActive: false,
            touchStartPos: { x: 0, y: 0 },
            lastTouchPos: { x: 0, y: 0 },
            isTouching: false,
            isPanning: false
        };

        const galleryImages = [
            'GalleryProject1(Rudy the Rat)[Just a goofy little guy I drew, he looks shifty lol].jpg', 'GalleryProject2(Dynne).jpg', 'GalleryProject3(Revera).jpg', 'GalleryProject4(Fancy Eel).jpg',
            'GalleryProject5(Kalen the Demon Early).jpg', 'GalleryProject6(Kirby on a Cloud).jpg', 'GalleryProject7(You Make Me Smile).jpg', 'GalleryProject8(EgoDive Conflicting Interests).jpg',
            'GalleryProject9(The Stranger).jpg', 'GalleryProject10(Tarot in Absentia).jpg', 'GalleryProject11(Fracture).jpg', 'GalleryProject12(Self Portrait).jpg',
            'GalleryProject13(Ko Overview).jpg', 'GalleryProject14(Usurper KUA)[The fusion of my Ego/Dive characters "Midas" and "Neuro". Was for a TLT Music Video lol].jpg', 'GalleryProject15(C.U,A,C Poster)[Poster for my friends Homebrew DND Campaign, located in my "Drifters Passing" world].jpg', 'GalleryProject16(CodeMonkeys Poster).jpg',
            'GalleryProject17(Drifters Poster)[Poster for my friends Homebrew DND Campaign, located in my "Drifters Passing" world-- This is my Characters faction/group lol].jpg', 'GalleryProject18(Bio Chip Instructional Poster).jpg', 'GalleryProject19(Gilly Art)[Art of the character that would become my first VRChat Avatar!].jpg', 'GalleryProject20(The Lighthouse).jpg',
            'GalleryProject21(Lizzie).jpg', 'GalleryProject22(Roxie)[Like her design a lot lol].jpg', 'GalleryProject23.jpg', 'GalleryProject24.jpg',
            'GalleryProject25.jpg', 'GalleryProject26.jpg', 'GalleryProject27.jpg', 'GalleryProject28.jpg',
            'GalleryProject29.jpg', 'GalleryProject30.jpg', 'GalleryProject31.jpg', 'GalleryProject32.jpg',
            'GalleryProject33.jpg', 'GalleryProject34.jpg', 'GalleryProject35(Thomas Applejack)[An early version of my Axiom of Infinity character "Davesh", at the time known as Thomas. He is mononymous, only having one name-- "Applejack" being a nickname he got in the military. His design would be much different now lol.].jpg', 'GalleryProject36.jpg',
            'GalleryProject37.jpg', 'GalleryProject38.jpg', 'GalleryProject39.jpg', 'GalleryProject40.jpg',
            'GalleryProject41.jpg', 'GalleryProject42.jpg', 'GalleryProject43.jpg', 'GalleryProject44.jpg',
            'GalleryProject45.jpg', 'GalleryProject46.jpg', 'GalleryProject47.jpg', 'GalleryProject48.jpg',
            'GalleryProject49.jpg', 'GalleryProject50.jpg', 'GalleryProject51.jpg', 'GalleryProject52.jpg',
            'GalleryProject53.jpg', 'GalleryProject54.jpg', 'GalleryProject55.jpg', 'GalleryProject56.jpg',
            'GalleryProject57.jpg', 'GalleryProject58.jpg', 'GalleryProject59.jpg', 'GalleryProject60.jpg',
            'GalleryProject61.jpg', 'GalleryProject62.jpg', 'GalleryProject63(Wisp)[Fan art of an OC by a creator I like].jpg', 'GalleryProject64.jpg',
            'GalleryProject65.jpg', 'GalleryProject66.jpg', 'GalleryProject67.jpg', 'GalleryProject68.jpg',
            'GalleryProject69(Heart of the Castle)[Concept art for my "Dear Mario" VRChat game].jpg', 'GalleryProject70.jpg', 'GalleryProject71.jpg', 'GalleryProject72.jpg',
            'GalleryProject73.jpg', 'GalleryProject74.jpg', 'GalleryProject75.jpg', 'GalleryProject76.jpg',
            'GalleryProject77.jpg', 'GalleryProject78.jpg', 'GalleryProject79.jpg', 'GalleryProject80.jpg',
            'GalleryProject81.jpg', 'GalleryProject82.jpg', 'GalleryProject83.jpg', 'GalleryProject84.jpg',
            'GalleryProject85.jpg', 'GalleryProject86.jpg', 'GalleryProject87.jpg', 'GalleryProject88.jpg',
            'GalleryProject89.jpg', 'GalleryProject90.jpg', 'GalleryProject91.jpg', 'GalleryProject92.jpg',
            'GalleryProject93.jpg', 'GalleryProject94.jpg', 'GalleryProject95.jpg', 'GalleryProject96.jpg',
            'GalleryProject97.jpg', 'GalleryProject98.jpg', 'GalleryProject99.jpg', 'GalleryProject100.jpg',
            'GalleryProject101.jpg', 'GalleryProject102.jpg', 'GalleryProject103.jpg', 'GalleryProject104.jpg',
            'GalleryProject105.jpg', 'GalleryProject106.jpg', 'GalleryProject107.jpg', 'GalleryProject108.jpg',
            'GalleryProject109.jpg', 'GalleryProject110.jpg', 'GalleryProject111.jpg', 'GalleryProject112.jpg',
            'GalleryProject113.jpg', 'GalleryProject114.jpg', 'GalleryProject115.jpg', 'GalleryProject116.jpg',
            'GalleryProject117.jpg', 'GalleryProject118(Kalen, First iteration)[The very first drawing I drew of my Demon character Kalen. They are my main persona online and in VRC].jpg', 'GalleryProject119.jpg', 'GalleryProject120.jpg'
        ];

        function parseImageData(filename) {
            // Extract title from parentheses
            const titleMatch = filename.match(/$$ ([^)]+) $$/);
            // Extract description from square brackets
            const descriptionMatch = filename.match(/$$ ([^ $$]+)\]/);
            
            // Get base filename without description (but keep everything else)
            let baseFilename = filename;
            if (descriptionMatch) {
                // Remove the description part to get the actual filename
                baseFilename = filename.substring(0, filename.indexOf('[')) + 
                               filename.substring(filename.indexOf(']') + 1);
            }
            
            const title = titleMatch ? titleMatch[1] : baseFilename.replace(/\.(jpg|png|gif|jpeg)$/i, '');
            const description = descriptionMatch ? descriptionMatch[1] : null;
            
            return { title, description, cleanFilename: baseFilename };
        }

        function initializeGallery() {
            const viewport = document.getElementById('galleryViewport');
            const canvas = document.getElementById('galleryCanvas');
            
            if (!viewport || !canvas || galleryState.images.length > 0) return;
            
            const minSpacing = 350;
            const maxAttempts = 100;
            const imageSize = 300;
            
            const viewportRect = viewport.getBoundingClientRect();
            const imagesPerViewport = 2;
            const viewportArea = viewportRect.width * viewportRect.height;
            const imageArea = imageSize * imageSize;
            const totalImages = Math.max(galleryImages.length, Math.ceil((viewportArea / imageArea) * imagesPerViewport));
            
            const imagesToUse = galleryImages.slice(0, totalImages);
            if (totalImages > galleryImages.length) {
                for (let i = galleryImages.length; i < totalImages; i++) {
                    imagesToUse.push(galleryImages[i % galleryImages.length]);
                }
            }
            
            imagesToUse.forEach((image, index) => {
                let position;
                let attempts = 0;
                
                do {
                    position = {
                        x: Math.random() * (galleryState.worldSize.width - imageSize),
                        y: Math.random() * (galleryState.worldSize.height - imageSize),
                        image: image,
                        id: `gallery-img-${index}`,
                        velocityX: 0,
                        velocityY: 0
                    };
                    attempts++;
                } while (isOverlapping(position, galleryState.images, minSpacing) && attempts < maxAttempts);
                
                galleryState.images.push(position);
            });
            
            viewport.addEventListener('mousemove', handleGalleryMouseMove);
            viewport.addEventListener('mouseleave', handleGalleryMouseLeave);
            
            // Touch events for mobile
            viewport.addEventListener('touchstart', handleGalleryTouchStart, { passive: false });
            viewport.addEventListener('touchmove', handleGalleryTouchMove, { passive: false });
            viewport.addEventListener('touchend', handleGalleryTouchEnd, { passive: false });
            
            galleryState.canvasOffset.x = -galleryState.worldSize.width / 2 + viewportRect.width / 2;
            galleryState.canvasOffset.y = -galleryState.worldSize.height / 2 + viewportRect.height / 2;
            
            loadAllVisibleImages();
        }

        function handleGalleryTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            galleryState.touchStartPos.x = touch.clientX;
            galleryState.touchStartPos.y = touch.clientY;
            galleryState.lastTouchPos.x = touch.clientX;
            galleryState.lastTouchPos.y = touch.clientY;
            galleryState.isTouching = true;
        }

        function handleGalleryTouchMove(e) {
            e.preventDefault();
            if (!galleryState.isTouching) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - galleryState.lastTouchPos.x;
            const deltaY = touch.clientY - galleryState.lastTouchPos.y;
            
            galleryState.canvasOffset.x += deltaX;
            galleryState.canvasOffset.y += deltaY;
            
            galleryState.lastTouchPos.x = touch.clientX;
            galleryState.lastTouchPos.y = touch.clientY;
            
            const canvas = document.getElementById('galleryCanvas');
            canvas.style.transform = `translate(${galleryState.canvasOffset.x}px, ${galleryState.canvasOffset.y}px)`;
            
            updateVisibleImages();
        }

        function handleGalleryTouchEnd(e) {
            e.preventDefault();
            galleryState.isTouching = false;
        }

        function isOverlapping(newPos, existingImages, minSpacing) {
            return existingImages.some(img => {
                const dx = newPos.x - img.x;
                const dy = newPos.y - img.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < minSpacing;
            });
        }

        function handleGalleryMouseMove(e) {
            if (galleryState.isTouching) return;
            
            const viewport = e.currentTarget;
            const rect = viewport.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            galleryState.mousePos.x = x / rect.width;
            galleryState.mousePos.y = y / rect.height;
        }

        function handleGalleryMouseLeave() {
            if (galleryState.isTouching) return;
            
            galleryState.mousePos.x = 0.5;
            galleryState.mousePos.y = 0.5;
        }

        function updateGalleryView() {
            if (!galleryState.isGalleryActive) {
                return;
            }
            
            const canvas = document.getElementById('galleryCanvas');
            if (!canvas) return;
            
            // Only apply movement if not touching or panning
            if (!galleryState.isTouching && !galleryState.isPanning) {
                const maxSpeed = 15;
                const deadZone = 0.2;
                
                const distX = galleryState.mousePos.x - 0.5;
                const distY = galleryState.mousePos.y - 0.5;
                
                const effectiveDistX = Math.abs(distX) < deadZone ? 0 : distX - (deadZone * Math.sign(distX));
                const effectiveDistY = Math.abs(distY) < deadZone ? 0 : distY - (deadZone * Math.sign(distY));
                
                const targetVelX = effectiveDistX * maxSpeed * 2;
                const targetVelY = effectiveDistY * maxSpeed * 2;
                
                const smoothing = 0.1;
                galleryState.velocity.x += (targetVelX - galleryState.velocity.x) * smoothing;
                galleryState.velocity.y += (targetVelY - galleryState.velocity.y) * smoothing;
                
                galleryState.canvasOffset.x -= galleryState.velocity.x;
                galleryState.canvasOffset.y -= galleryState.velocity.y;
                
                const arrowThreshold = 1;
                document.getElementById('arrowLeft').classList.toggle('active', galleryState.velocity.x < -arrowThreshold);
                document.getElementById('arrowRight').classList.toggle('active', galleryState.velocity.x > arrowThreshold);
                document.getElementById('arrowTop').classList.toggle('active', galleryState.velocity.y < -arrowThreshold);
                document.getElementById('arrowBottom').classList.toggle('active', galleryState.velocity.y > arrowThreshold);
            } else {
                // Clear arrow indicators when touching or panning
                document.getElementById('arrowLeft').classList.remove('active');
                document.getElementById('arrowRight').classList.remove('active');
                document.getElementById('arrowTop').classList.remove('active');
                document.getElementById('arrowBottom').classList.remove('active');
            }
            
            // Always apply physics to images
            const repulsionStrength = 0.5;
            const repulsionDistance = 350;
            const damping = 0.9;
            
            galleryState.images.forEach((img1, i) => {
                let forceX = 0;
                let forceY = 0;
                
                galleryState.images.forEach((img2, j) => {
                    if (i !== j) {
                        const dx = img1.x - img2.x;
                        const dy = img1.y - img2.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < repulsionDistance && distance > 0) {
                            const force = (repulsionDistance - distance) * repulsionStrength / distance;
                            forceX += dx * force;
                            forceY += dy * force;
                        }
                    }
                });
                
                img1.velocityX = (img1.velocityX + forceX) * damping;
                img1.velocityY = (img1.velocityY + forceY) * damping;
                
                img1.x += img1.velocityX;
                img1.y += img1.velocityY;
                
                img1.x = Math.max(0, Math.min(img1.x, galleryState.worldSize.width));
                img1.y = Math.max(0, Math.min(img1.y, galleryState.worldSize.height));
                
                const imgElement = galleryState.loadedImages.get(img1.id);
                if (imgElement) {
                    imgElement.style.left = img1.x + 'px';
                    imgElement.style.top = img1.y + 'px';
                }
            });
            
            // Handle world wrapping
            const wrapBuffer = 1000;
            if (galleryState.canvasOffset.x > wrapBuffer) {
                galleryState.canvasOffset.x -= galleryState.worldSize.width;
                repositionImages();
            } else if (galleryState.canvasOffset.x < -galleryState.worldSize.width - wrapBuffer) {
                galleryState.canvasOffset.x += galleryState.worldSize.width;
                repositionImages();
            }
            
            if (galleryState.canvasOffset.y > wrapBuffer) {
                galleryState.canvasOffset.y -= galleryState.worldSize.height;
                repositionImages();
            } else if (galleryState.canvasOffset.y < -galleryState.worldSize.height - wrapBuffer) {
                galleryState.canvasOffset.y += galleryState.worldSize.height;
                repositionImages();
            }
            
            canvas.style.transform = `translate(${galleryState.canvasOffset.x}px, ${galleryState.canvasOffset.y}px)`;
            
            updateVisibleImages();
            
            // Continue animation loop
            galleryState.animationId = requestAnimationFrame(updateGalleryView);
        }

        function loadAllVisibleImages() {
            updateVisibleImages();
        }

        function updateVisibleImages() {
            const viewport = document.getElementById('galleryViewport');
            if (!viewport) return;
            
            const viewportRect = viewport.getBoundingClientRect();
            const buffer = 400;
            const minVisibleImages = 2;
            
            let visibleCount = 0;
            const visibleImages = [];
            
            galleryState.images.forEach(imgData => {
                const worldX = imgData.x + galleryState.canvasOffset.x;
                const worldY = imgData.y + galleryState.canvasOffset.y;
                
                const isVisible = (
                    worldX > -buffer && 
                    worldX < viewportRect.width + buffer &&
                    worldY > -buffer && 
                    worldY < viewportRect.height + buffer
                );
                
                if (isVisible) {
                    visibleCount++;
                    visibleImages.push(imgData);
                }
                
                if (isVisible && !galleryState.loadedImages.has(imgData.id)) {
                    const imgElement = createGalleryImage(imgData);
                    document.getElementById('galleryCanvas').appendChild(imgElement);
                    galleryState.loadedImages.set(imgData.id, imgElement);
                } else if (!isVisible && galleryState.loadedImages.has(imgData.id)) {
                    const farBuffer = 800;
                    if (worldX < -farBuffer || worldX > viewportRect.width + farBuffer ||
                        worldY < -farBuffer || worldY > viewportRect.height + farBuffer) {
                        const imgElement = galleryState.loadedImages.get(imgData.id);
                        imgElement.remove();
                        galleryState.loadedImages.delete(imgData.id);
                    }
                }
            });
            
            if (visibleCount < minVisibleImages) {
                const imagesToAdd = minVisibleImages - visibleCount;
                const imageSize = 300;
                const minSpacing = 350;
                const maxAttempts = 50;
                
                for (let i = 0; i < imagesToAdd; i++) {
                    let position;
                    let attempts = 0;
                    
                    do {
                        const viewportX = Math.random() * viewportRect.width;
                        const viewportY = Math.random() * viewportRect.height;
                        position = {
                            x: viewportX - galleryState.canvasOffset.x,
                            y: viewportY - galleryState.canvasOffset.y,
                            image: galleryImages[Math.floor(Math.random() * galleryImages.length)],
                            id: `gallery-img-${galleryState.images.length + i}`,
                            velocityX: 0,
                            velocityY: 0
                        };
                        attempts++;
                    } while (isOverlapping(position, galleryState.images, minSpacing) && attempts < maxAttempts);
                    
                    if (attempts < maxAttempts) {
                        galleryState.images.push(position);
                        const imgElement = createGalleryImage(position);
                        document.getElementById('galleryCanvas').appendChild(imgElement);
                        galleryState.loadedImages.set(position.id, imgElement);
                    }
                }
            }
        }

        function repositionImages() {
            galleryState.loadedImages.forEach((imgElement, id) => {
                const imgData = galleryState.images.find(img => img.id === id);
                if (imgData) {
                    imgElement.style.left = imgData.x + 'px';
                    imgElement.style.top = imgData.y + 'px';
                }
            });
        }

        function createGalleryImage(imgData) {
            const container = document.createElement('div');
            container.className = 'gallery-image';
            container.style.left = imgData.x + 'px';
            container.style.top = imgData.y + 'px';
            container.id = imgData.id;
            
            const imageData = parseImageData(imgData.image);
            
            const img = document.createElement('img');
            img.src = `Art Gallery/${imageData.cleanFilename}`;
            img.alt = imageData.title;
            
            img.onerror = function() { 
                console.log('Failed to load:', imageData.cleanFilename);
                this.src = 'Art Folder/placeholder.jpg'; 
            };
            
            const info = document.createElement('div');
            info.className = 'gallery-image-info';
            
            const title = document.createElement('div');
            title.className = 'gallery-image-title';
            title.textContent = `"${imageData.title}"`;
            info.appendChild(title);
            
            if (imageData.description) {
                const desc = document.createElement('div');
                desc.className = 'gallery-image-description';
                desc.textContent = imageData.description;
                info.appendChild(desc);
            }
            
            container.appendChild(img);
            container.appendChild(info);
            
            const isMobile = window.innerWidth <= 768;
            
            // Function to handle the click/tap
            const handleImageClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                centerImage(container);
                playClickSound();
            };
            
            // Add both click and touch listeners for mobile compatibility
            container.addEventListener('click', handleImageClick);
            
            if (isMobile) {
                container.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    centerImage(container);
                    playClickSound();
                });
            }
            
            setTimeout(() => container.classList.add('loaded'), 50);
            
            return container;
        }

        function centerImage(container) {
            if (galleryState.focusedImage && galleryState.focusedImage !== container) {
                galleryState.focusedImage.classList.remove('centered');
                galleryState.focusedImage.classList.remove('show-description');
            }
            
            // Toggle centered state
            if (container.classList.contains('centered')) {
                container.classList.remove('centered');
                container.classList.remove('show-description');
                galleryState.focusedImage = null;
                return;
            }
            
            // Get the image's current position relative to viewport
            const imgData = galleryState.images.find(img => img.id === container.id);
            if (!imgData) return;
            
            const viewport = document.getElementById('galleryViewport');
            const viewportRect = viewport.getBoundingClientRect();
            
            // Calculate target offset to center this image
            const targetOffsetX = viewportRect.width / 2 - imgData.x - 150;
            const targetOffsetY = viewportRect.height / 2 - imgData.y - 150;
            
            // Stop any ongoing animation and set panning state
            galleryState.isPanning = true;
            
            // Animate the pan
            const startOffsetX = galleryState.canvasOffset.x;
            const startOffsetY = galleryState.canvasOffset.y;
            const startTime = performance.now();
            const duration = 600; // milliseconds
            
            function animatePan(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease-in-out)
                const easeProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // Update canvas position
                galleryState.canvasOffset.x = startOffsetX + (targetOffsetX - startOffsetX) * easeProgress;
                galleryState.canvasOffset.y = startOffsetY + (targetOffsetY - startOffsetY) * easeProgress;
                
                const canvas = document.getElementById('galleryCanvas');
                canvas.style.transform = `translate(${galleryState.canvasOffset.x}px, ${galleryState.canvasOffset.y}px)`;
                
                // Update visible images during pan
                updateVisibleImages();
                
                if (progress < 1) {
                    requestAnimationFrame(animatePan);
                } else {
                    // After pan completes, scale the image
                    galleryState.isPanning = false;
                    
                    container.classList.add('centered');
                    container.classList.add('show-description');
                    
                    galleryState.focusedImage = container;
                }
            }
            
            requestAnimationFrame(animatePan);
        }

        function closeCenteredImage() {
            if (galleryState.focusedImage) {
                galleryState.focusedImage.classList.remove('centered');
                galleryState.focusedImage.classList.remove('show-description');
                galleryState.focusedImage.classList.remove('show-title');
                galleryState.focusedImage = null;
            }
        }

        function showSection(sectionType) {
            document.getElementById('mainHub').style.display = 'none';
            
            const section = document.getElementById(`${sectionType}Section`);
            section.classList.add('active');
            
            if (sectionType === 'gallery') {
                galleryState.isGalleryActive = true;
                if (galleryState.images.length === 0) {
                    initializeGallery();
                }
                if (!galleryState.animationId) {
                    updateGalleryView();
                }
            } else {
                updateCarouselPositions(sectionType);
            }
        }

        function closeSection() {
            document.querySelectorAll('.section-view').forEach(section => {
                section.classList.remove('active');
            });
            
            if (galleryState.isGalleryActive) {
                galleryState.isGalleryActive = false;
                if (galleryState.animationId) {
                    cancelAnimationFrame(galleryState.animationId);
                    galleryState.animationId = null;
                }
                document.querySelectorAll('.gallery-arrow').forEach(arrow => {
                    arrow.classList.remove('active');
                });
                closeCenteredImage();
            }
            
            document.getElementById('mainHub').style.display = 'block';
            
            // Reset keyboard navigation
            keyboardNav.enabled = false;
            keyboardNav.currentIndex = -1;
            if (keyboardNav.hubSections) {
                keyboardNav.hubSections.forEach(section => {
                    section.classList.remove('keyboard-selected');
                });
            }
        }

        function showAbout() {
            document.getElementById('hubHome').style.display = 'none';
            document.getElementById('aboutSection').classList.remove('hidden');
            document.getElementById('backButton').classList.remove('hidden');
        }

        function showHub() {
            document.getElementById('hubHome').style.display = 'block';
            document.getElementById('aboutSection').classList.add('hidden');
            document.getElementById('backButton').classList.add('hidden');
            
            // Reset keyboard navigation
            keyboardNav.enabled = false;
            keyboardNav.currentIndex = -1;
            if (keyboardNav.hubSections) {
                keyboardNav.hubSections.forEach(section => {
                    section.classList.remove('keyboard-selected');
                });
            }
        }

window.onload = function() {
    // Check if user is already authenticated
    if (localStorage.getItem('abyssalAuth') === 'true') {
        passwordScreen.style.display = 'none';
        mainHub.classList.add('active');
        initKeyboardNav();
        hubAudio.volume = 0;
        hubAudio.play();
        let fadeIn = setInterval(() => {
            if (hubAudio.volume < volumeSlider.value) {
                hubAudio.volume = Math.min(hubAudio.volume + 0.01, volumeSlider.value);
            } else {
                clearInterval(fadeIn);
            }
        }, 50);
    } else {
        passwordInput.focus();
        document.getElementById('passwordToggle').textContent = 'üëÅ';
        passwordAudio.play().catch(error => {
            console.log('Autoplay prevented:', error);
            document.addEventListener('click', function playAudioOnce() {
                passwordAudio.play();
                document.removeEventListener('click', playAudioOnce);
            });
        });
    }
    initializeCarousels();
    initKeyboardNav();
};

        // Keyboard navigation state for hub only
        let keyboardNav = {
            enabled: false,
            currentIndex: -1,
            hubSections: []
        };

        // Initialize keyboard navigation for hub
        function initKeyboardNav() {
            keyboardNav.hubSections = Array.from(document.querySelectorAll('#hubHome .nav-section'));
        }

        // Update keyboard selection
        function updateKeyboardSelection(index) {
            // Remove previous selection
            keyboardNav.hubSections.forEach(section => {
                section.classList.remove('keyboard-selected');
            });
            
            // Add new selection
            if (index >= 0 && index < keyboardNav.hubSections.length) {
                keyboardNav.currentIndex = index;
                keyboardNav.hubSections[index].classList.add('keyboard-selected');
                keyboardNav.enabled = true;
            }
        }

        // Navigate hub with keyboard
        function navigateHub(direction) {
            if (!keyboardNav.enabled) {
                keyboardNav.enabled = true;
                keyboardNav.currentIndex = 0; // Start at "Games"
                updateKeyboardSelection(0);
                return;
            }
            
            // Calculate grid dimensions
            const gridContainer = document.querySelector('.nav-grid');
            const computedStyle = window.getComputedStyle(gridContainer);
            const gridTemplateColumns = computedStyle.gridTemplateColumns;
            const cols = gridTemplateColumns.split(' ').length;
            
            let newIndex = keyboardNav.currentIndex;
            
            switch(direction) {
                case 'up':
                    newIndex = keyboardNav.currentIndex - cols;
                    if (newIndex < 0) {
                        // Wrap to bottom row, same column
                        const currentCol = keyboardNav.currentIndex % cols;
                        const lastRowStart = Math.floor((keyboardNav.hubSections.length - 1) / cols) * cols;
                        newIndex = Math.min(lastRowStart + currentCol, keyboardNav.hubSections.length - 1);
                    }
                    break;
                case 'down':
                    newIndex = keyboardNav.currentIndex + cols;
                    if (newIndex >= keyboardNav.hubSections.length) {
                        // Wrap to top row, same column
                        newIndex = keyboardNav.currentIndex % cols;
                    }
                    break;
                case 'left':
                    newIndex = keyboardNav.currentIndex - 1;
                    if (newIndex < 0 || (keyboardNav.currentIndex % cols === 0)) {
                        // Wrap to end of current row
                        const currentRow = Math.floor(keyboardNav.currentIndex / cols);
                        newIndex = Math.min((currentRow + 1) * cols - 1, keyboardNav.hubSections.length - 1);
                    }
                    break;
                case 'right':
                    newIndex = keyboardNav.currentIndex + 1;
                    if (newIndex >= keyboardNav.hubSections.length || (newIndex % cols === 0)) {
                        // Wrap to start of current row
                        newIndex = Math.floor(keyboardNav.currentIndex / cols) * cols;
                    }
                    break;
            }
            
            updateKeyboardSelection(newIndex);
        }

        // Keyboard navigation for carousels and gallery
document.addEventListener('keydown', function(e) {
    // Don't handle keyboard navigation if user is typing in an input
    if (document.activeElement.tagName === 'INPUT') return;
    
    // Log keypress for debugging
    console.log('Key pressed:', e.key);

    // Volume control with Shift + Up/Down or W/S
    if (e.shiftKey) {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
            e.preventDefault();
            volumeSlider.value = Math.min(1, parseFloat(volumeSlider.value) + 0.1);
            volumeSlider.dispatchEvent(new Event('input'));
        } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
            e.preventDefault();
            volumeSlider.value = Math.max(0, parseFloat(volumeSlider.value) - 0.1);
            volumeSlider.dispatchEvent(new Event('input'));
        }
        return;
    }
    
    // Escape key to go back
    if (e.key === 'Escape') {
        e.preventDefault();
        // If in about section
        if (!document.getElementById('aboutSection').classList.contains('hidden')) {
            showHub();
            playClickSound();
        }
        // If in any other section
        else if (document.querySelector('.section-view.active')) {
            closeSection();
            playClickSound();
        }
        return;
    }
    
    // PRIORITY: Check if gallery is active FIRST
    if (document.getElementById('gallerySection').classList.contains('active')) {
        // Don't move if currently panning to a centered image
        if (galleryState.isPanning) return;
        
        // WASD navigation for gallery
        const keySpeed = 20;
        let moved = false;
        
        if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            e.preventDefault();
            galleryState.canvasOffset.y += keySpeed;
            moved = true;
            document.getElementById('arrowTop').classList.add('active');
            setTimeout(() => document.getElementById('arrowTop').classList.remove('active'), 200);
        } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
            e.preventDefault();
            galleryState.canvasOffset.y -= keySpeed;
            moved = true;
            document.getElementById('arrowBottom').classList.add('active');
            setTimeout(() => document.getElementById('arrowBottom').classList.remove('active'), 200);
        } else if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
            e.preventDefault();
            galleryState.canvasOffset.x += keySpeed;
            moved = true;
            document.getElementById('arrowLeft').classList.add('active');
            setTimeout(() => document.getElementById('arrowLeft').classList.remove('active'), 200);
        } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
            e.preventDefault();
            galleryState.canvasOffset.x -= keySpeed;
            moved = true;
            document.getElementById('arrowRight').classList.add('active');
            setTimeout(() => document.getElementById('arrowRight').classList.remove('active'), 200);
        }
        
        if (moved) {
            const canvas = document.getElementById('galleryCanvas');
            canvas.style.transform = `translate(${galleryState.canvasOffset.x}px, ${galleryState.canvasOffset.y}px)`;
            updateVisibleImages();
        }
        return; // Stop here to avoid other controls
    }
    
    // PRIORITY: Check if any carousel section is active
    let activeSection = null;
    if (document.getElementById('gamesSection').classList.contains('active')) {
        activeSection = 'games';
    } else if (document.getElementById('vrchatSection').classList.contains('active')) {
        activeSection = 'vrchat';
    } else if (document.getElementById('otherSection').classList.contains('active')) {
        activeSection = 'other';
    }
    
    if (activeSection) {
        console.log('Active carousel section:', activeSection, 'Current index:', carouselStates[activeSection].currentIndex);
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
            e.preventDefault();
            moveCarousel(activeSection, -1);
            playClickSound();
        } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
            e.preventDefault();
            moveCarousel(activeSection, 1);
            playClickSound();
        } else if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            console.log('Enter/Space pressed in carousel:', activeSection, 'index:', carouselStates[activeSection].currentIndex);
            const carousel = document.getElementById(`${activeSection}Carousel`);
            const cards = carousel.querySelectorAll('.project-card');
            const currentIndex = carouselStates[activeSection].currentIndex;
            const selectedCard = cards[currentIndex];
            if (selectedCard) {
                if (!selectedCard.classList.contains('unavailable')) {
                    console.log('Triggering click on card:', selectedCard.querySelector('h3').textContent);
                    selectedCard.click();
                    playClickSound();
                } else {
                    console.log('Card is unavailable, click not triggered');
                }
            } else {
                console.log('No card found at index:', currentIndex);
            }
        }
        return; // Stop here to avoid hub controls
    }
    
    // ONLY NOW check hub navigation - if no sections are active
    if (document.getElementById('hubHome').style.display !== 'none' && 
        document.getElementById('aboutSection').classList.contains('hidden')) {
        
        // Log state for debugging
        console.log('Hub active, keyboardNav:', keyboardNav);

        if ((e.key === 'Enter' || e.key === ' ') && keyboardNav.enabled && keyboardNav.currentIndex >= 0) {
            e.preventDefault();
            console.log('Enter/Space pressed, activating hub section:', keyboardNav.currentIndex);
            const selectedSection = keyboardNav.hubSections[keyboardNav.currentIndex];
            if (selectedSection) {
                selectedSection.click();
                playClickSound();
                // Reset keyboard navigation
                keyboardNav.enabled = false;
                keyboardNav.currentIndex = -1;
                keyboardNav.hubSections.forEach(section => {
                    section.classList.remove('keyboard-selected');
                });
            }
            return;
        }

        // Initialize keyboard navigation on first keypress if not enabled
        if (!keyboardNav.enabled && 
            ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'W', 's', 'S', 'a', 'A', 'd', 'D'].includes(e.key)) {
            e.preventDefault();
            keyboardNav.enabled = true;
            keyboardNav.currentIndex = 0; // Start at first section
            updateKeyboardSelection(0);
        }

        // Handle navigation
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
            e.preventDefault();
            navigateHub('up');
        } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
            e.preventDefault();
            navigateHub('down');
        } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
            e.preventDefault();
            navigateHub('left');
        } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
            e.preventDefault();
            navigateHub('right');
        }
    }
});

        // Reset keyboard navigation when clicking anywhere
        document.addEventListener('click', function() {
            if (keyboardNav.enabled) {
                keyboardNav.enabled = false;
                keyboardNav.currentIndex = -1;
                keyboardNav.hubSections.forEach(section => {
                    section.classList.remove('keyboard-selected');
                });
            }
        });

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                ['games', 'vrchat', 'other'].forEach(type => {
                    if (document.getElementById(`${type}Section`).classList.contains('active')) {
                        updateCarouselPositions(type);
                    }
                });
            }, 250);
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9856ab606d5d6b19',t:'MTc1ODkzMDY4OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>